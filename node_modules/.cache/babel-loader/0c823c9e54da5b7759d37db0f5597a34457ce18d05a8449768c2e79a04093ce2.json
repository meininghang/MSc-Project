{"ast":null,"code":"require(\"core-js/modules/es.typed-array.to-reversed.js\");\nrequire(\"core-js/modules/es.typed-array.to-sorted.js\");\nrequire(\"core-js/modules/es.typed-array.with.js\");\nrequire(\"core-js/modules/es.array.push.js\");\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n// If the importer is in node compatibility mode or this is not an ESM\n// file that has been converted to a CommonJS file using a Babel-\n// compatible transform (i.e. \"__esModule\" has not been set), then set\n// \"default\" to the CommonJS \"module.exports\" for node compatibility.\nisNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n  value: mod,\n  enumerable: true\n}) : target, mod));\nvar __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n  value: true\n}), mod);\n\n// src/Crypto.ts\nvar Crypto_exports = {};\n__export(Crypto_exports, {\n  default: () => Crypto\n});\nmodule.exports = __toCommonJS(Crypto_exports);\nvar import_cipher = require(\"./util/cipher\");\nvar import_MindLake = require(\"./MindLake\");\nvar import_uuid = require(\"uuid\");\nvar import_result = __toESM(require(\"./util/result\"));\nvar Crypto = class {\n  constructor(sdk) {\n    this.service = sdk.service;\n    this.web3 = sdk.web3;\n    this.sdk = sdk;\n  }\n  /**\n   * encrypt method\n   * @param tableName\n   * @param columnName\n   * @param data\n   * @param schema\n   */\n  async encrypt(data, tableNameColumnName) {\n    try {\n      import_MindLake.MindLake.checkLogin();\n      this.sdk.checkRegistered();\n      const walletAddress = await this.web3.getWalletAccount();\n      let encType;\n      let ccEntry;\n      if (typeof tableNameColumnName === \"string\") {\n        const [tableName, columnName] = tableNameColumnName.split(\".\");\n        encType = await this.service.execute({\n          bizType: 107,\n          tableName,\n          column: columnName\n        });\n        ccEntry = await this._getOrGenDek(tableName, columnName, walletAddress);\n      } else {\n        encType = tableNameColumnName;\n        const {\n          ctxId,\n          algorithm,\n          encryptedDek\n        } = await this.service.execute({\n          bizType: 108\n        });\n        const mekBuffer = await this.web3.getMekBytes();\n        const [_, decryptedDek] = import_cipher.CipherHelper.decryptDekToBase64(mekBuffer, encryptedDek);\n        ccEntry = {\n          ctxId,\n          algorithm,\n          decryptedDek\n        };\n      }\n      if (encType > 4) {\n        encType += 1;\n      }\n      const encodeDataBuffer = import_cipher.CipherHelper.encodeDataByType(data, encType);\n      const header = this._genCryptoHeader(ccEntry.ctxId, encType);\n      const checkCode = this._genCheckCode(encodeDataBuffer, 1);\n      const data_to_enc = Buffer.concat([encodeDataBuffer, Buffer.from(checkCode)]);\n      let encrypted_data;\n      const iv = import_cipher.CipherHelper.randomBytes();\n      if (ccEntry.algorithm === 3) {\n        encrypted_data = import_cipher.CipherHelper.aesEncrypt(ccEntry.decryptedDek, iv, data_to_enc);\n      }\n      if (!encrypted_data) {\n        throw new Error(\"aesEncrypt error\");\n      }\n      const buf = Buffer.concat([header, iv, encrypted_data]);\n      const temp = buf.slice(1);\n      const checkCode2 = this._genCheckCode(temp, 1);\n      const result = Buffer.concat([checkCode2, temp]);\n      return import_result.default.success(`\\\\x${Buffer.from(result).toString(\"hex\")}`);\n    } catch (e) {\n      console.error(e);\n      return import_result.default.fail(e);\n    }\n  }\n  /**\n   *\n   * @param hex\n   */\n  async decrypt(hex) {\n    try {\n      import_MindLake.MindLake.checkLogin();\n      this.sdk.checkRegistered();\n      const mek = await this.web3.getMekBytes();\n      const encryptData = hex.replace(\"\\\\x\", \"\");\n      const encryptDataBuffer = Buffer.from(encryptData, \"hex\");\n      const header = this._extractCryptoHeader(encryptDataBuffer);\n      const cxtId = this._extractCtxId(header);\n      const {\n        encryptedDek,\n        algorithm\n      } = await this.service.execute({\n        bizType: 111,\n        ctxId: String(cxtId)\n      });\n      const [_, dek] = import_cipher.CipherHelper.decryptDekToBase64(mek, encryptedDek);\n      const afterEncType = this._extractEncType(header);\n      const idx = (header[1] & 7) + 2;\n      const iv = encryptDataBuffer.slice(idx, idx + 16);\n      const cipherBlob = encryptDataBuffer.slice(idx + 16);\n      const plainBlob = import_cipher.CipherHelper.aesDecrypt(dek, iv, cipherBlob);\n      const encodeResult = plainBlob.subarray(0, -1);\n      const checkCode = plainBlob.slice(-1);\n      const checkCode2 = this._genCheckCode(encodeResult, 1);\n      if (checkCode[0] != checkCode2[0]) {\n        throw new Error(\"Check code is not correct\");\n      }\n      const decryptData = import_cipher.CipherHelper.decodeDataByType(Uint8Array.from(encodeResult), afterEncType);\n      return import_result.default.success(decryptData);\n    } catch (e) {\n      console.error(e);\n      return import_result.default.fail(e);\n    }\n  }\n  /**\n   * get dek\n   * @param schema\n   * @param table\n   * @param column\n   * @param walletAddress\n   * @private\n   */\n  async _getOrGenDek(table, column, walletAddress) {\n    const mekBuffer = await this.web3.getMekBytes();\n    let cc = await this._queryCCEntryByName(table, column, walletAddress).catch(e => {});\n    if (!cc) {\n      cc = await this._genCCEntryFromLocal(table, column);\n    }\n    const {\n      ctxId,\n      dekId,\n      encryptedDek,\n      algorithm\n    } = cc;\n    const [, decryptedDek] = import_cipher.CipherHelper.decryptDekToBase64(mekBuffer, encryptedDek);\n    return {\n      ctxId,\n      decryptedDek,\n      algorithm\n    };\n  }\n  async _queryCCEntryByName(table, column, walletAddress) {\n    return await this.service.execute({\n      bizType: 108,\n      table,\n      column,\n      walletAddress\n    });\n  }\n  async _genCCEntryFromLocal(table, column) {\n    const dekId = await this.service.execute({\n      bizType: 109,\n      mekId: this.sdk.mekId\n    });\n    const dek = import_cipher.CipherHelper.randomBytes();\n    const mek = await this.web3.getMekBytes();\n    return this._genSQLInsertDek(this.sdk.mekId, dekId, mek, dek, 3, table, column);\n  }\n  async _genSQLInsertDek(mekId, dekId, mek, dek, alg = 3, table, column) {\n    var _a;\n    const dekCipherStr = import_cipher.CipherHelper.encryptDekToBase64(mek, dekId, dek);\n    const grpIdStr = (0, import_uuid.v4)();\n    const uuidStringWithoutHyphen = grpIdStr.replace(/-/g, \"\");\n    const _gripId = Buffer.from(((_a = uuidStringWithoutHyphen.match(/.{1,2}/g)) == null ? void 0 : _a.map(byte => parseInt(byte, 16))) || []);\n    const gAuthStr = import_cipher.CipherHelper.digest_gAuth(mek, _gripId, dekId);\n    return this.service.execute({\n      bizType: 110,\n      table,\n      column,\n      schema: \"public\",\n      mekId,\n      dekId,\n      dekCipherStr,\n      grpIdStr,\n      groupAuthStr: gAuthStr\n    });\n  }\n  _genCryptoHeader(ctxId, encType) {\n    let head = Buffer.from(\"0000\", \"hex\");\n    let tmp_value = head[1];\n    tmp_value = tmp_value & 4294967047;\n    tmp_value = tmp_value | encType << 3;\n    head[1] = tmp_value;\n    let tmp = ctxId;\n    while (tmp != 0) {\n      head = Buffer.concat([head, Buffer.alloc(1).fill(tmp & 255)]);\n      tmp >>= 8;\n    }\n    const ctxLen = head.length - 2;\n    let tmp_val = head[1];\n    tmp_val = tmp_val & 4294967288 | ctxLen & 7;\n    head[1] = tmp_val;\n    return head;\n  }\n  _extractCryptoHeader(data) {\n    let header = [];\n    let index = 0;\n    for (let i = 0; i < 1; i++) {\n      header.push(data[index]);\n      index++;\n    }\n    if (index !== 1) {\n      throw new Error(\"Invalid header index\");\n    }\n    header.push(data[index]);\n    index++;\n    const rng = header[1] & 7;\n    for (let i = 0; i < rng; i++) {\n      header.push(data[index]);\n      index++;\n    }\n    return Buffer.from(header);\n  }\n  _extractEncType(header) {\n    const tmp_value = header[1];\n    const type_value = (tmp_value & 248) >> 3;\n    return type_value;\n  }\n  _extractCtxId(header) {\n    const ctxIdLen = header[1] & 7;\n    if (header.length !== ctxIdLen + 2) {\n      throw new Error(\"Invalid header length\");\n    }\n    let ctxId = 0;\n    for (let i = 0; i < ctxIdLen; i++) {\n      const index = header.length - 1 - i;\n      ctxId = ctxId << 8 | header[index] & 255;\n    }\n    return ctxId;\n  }\n  _genCheckCode(encodeData, resultSize) {\n    let tmpCode = new Uint8Array(resultSize);\n    for (let i = 0; i < encodeData.length; i++) {\n      let n = i % resultSize;\n      tmpCode[n] ^= encodeData[i];\n    }\n    return Buffer.from(tmpCode);\n  }\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {});","map":{"version":3,"names":["__create","Object","create","__defProp","defineProperty","__getOwnPropDesc","getOwnPropertyDescriptor","__getOwnPropNames","getOwnPropertyNames","__getProtoOf","getPrototypeOf","__hasOwnProp","prototype","hasOwnProperty","__export","target","all","name","get","enumerable","__copyProps","to","from","except","desc","key","call","__toESM","mod","isNodeMode","__esModule","value","__toCommonJS","Crypto_exports","default","Crypto","module","exports","import_cipher","require","import_MindLake","import_uuid","import_result","constructor","sdk","service","web3","encrypt","data","tableNameColumnName","MindLake","checkLogin","checkRegistered","walletAddress","getWalletAccount","encType","ccEntry","tableName","columnName","split","execute","bizType","column","_getOrGenDek","ctxId","algorithm","encryptedDek","mekBuffer","getMekBytes","_","decryptedDek","CipherHelper","decryptDekToBase64","encodeDataBuffer","encodeDataByType","header","_genCryptoHeader","checkCode","_genCheckCode","data_to_enc","Buffer","concat","encrypted_data","iv","randomBytes","aesEncrypt","Error","buf","temp","slice","checkCode2","result","success","toString","e","console","error","fail","decrypt","hex","mek","encryptData","replace","encryptDataBuffer","_extractCryptoHeader","cxtId","_extractCtxId","String","dek","afterEncType","_extractEncType","idx","cipherBlob","plainBlob","aesDecrypt","encodeResult","subarray","decryptData","decodeDataByType","Uint8Array","table","cc","_queryCCEntryByName","catch","_genCCEntryFromLocal","dekId","mekId","_genSQLInsertDek","alg","_a","dekCipherStr","encryptDekToBase64","grpIdStr","v4","uuidStringWithoutHyphen","_gripId","match","map","byte","parseInt","gAuthStr","digest_gAuth","schema","groupAuthStr","head","tmp_value","tmp","alloc","fill","ctxLen","length","tmp_val","index","i","push","rng","type_value","ctxIdLen","encodeData","resultSize","tmpCode","n"],"sources":["E:/Amanda-project/vue2-project/project-vue2/node_modules/mind-lake-sdk/dist/Crypto.js"],"sourcesContent":["var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/Crypto.ts\nvar Crypto_exports = {};\n__export(Crypto_exports, {\n  default: () => Crypto\n});\nmodule.exports = __toCommonJS(Crypto_exports);\nvar import_cipher = require(\"./util/cipher\");\nvar import_MindLake = require(\"./MindLake\");\nvar import_uuid = require(\"uuid\");\nvar import_result = __toESM(require(\"./util/result\"));\nvar Crypto = class {\n  constructor(sdk) {\n    this.service = sdk.service;\n    this.web3 = sdk.web3;\n    this.sdk = sdk;\n  }\n  /**\n   * encrypt method\n   * @param tableName\n   * @param columnName\n   * @param data\n   * @param schema\n   */\n  async encrypt(data, tableNameColumnName) {\n    try {\n      import_MindLake.MindLake.checkLogin();\n      this.sdk.checkRegistered();\n      const walletAddress = await this.web3.getWalletAccount();\n      let encType;\n      let ccEntry;\n      if (typeof tableNameColumnName === \"string\") {\n        const [tableName, columnName] = tableNameColumnName.split(\".\");\n        encType = await this.service.execute({ bizType: 107, tableName, column: columnName });\n        ccEntry = await this._getOrGenDek(\n          tableName,\n          columnName,\n          walletAddress\n        );\n      } else {\n        encType = tableNameColumnName;\n        const { ctxId, algorithm, encryptedDek } = await this.service.execute({ bizType: 108 });\n        const mekBuffer = await this.web3.getMekBytes();\n        const [_, decryptedDek] = import_cipher.CipherHelper.decryptDekToBase64(mekBuffer, encryptedDek);\n        ccEntry = { ctxId, algorithm, decryptedDek };\n      }\n      if (encType > 4) {\n        encType += 1;\n      }\n      const encodeDataBuffer = import_cipher.CipherHelper.encodeDataByType(data, encType);\n      const header = this._genCryptoHeader(ccEntry.ctxId, encType);\n      const checkCode = this._genCheckCode(encodeDataBuffer, 1);\n      const data_to_enc = Buffer.concat([\n        encodeDataBuffer,\n        Buffer.from(checkCode)\n      ]);\n      let encrypted_data;\n      const iv = import_cipher.CipherHelper.randomBytes();\n      if (ccEntry.algorithm === 3) {\n        encrypted_data = import_cipher.CipherHelper.aesEncrypt(ccEntry.decryptedDek, iv, data_to_enc);\n      }\n      if (!encrypted_data) {\n        throw new Error(\"aesEncrypt error\");\n      }\n      const buf = Buffer.concat([header, iv, encrypted_data]);\n      const temp = buf.slice(1);\n      const checkCode2 = this._genCheckCode(temp, 1);\n      const result = Buffer.concat([checkCode2, temp]);\n      return import_result.default.success(`\\\\x${Buffer.from(result).toString(\"hex\")}`);\n    } catch (e) {\n      console.error(e);\n      return import_result.default.fail(e);\n    }\n  }\n  /**\n   *\n   * @param hex\n   */\n  async decrypt(hex) {\n    try {\n      import_MindLake.MindLake.checkLogin();\n      this.sdk.checkRegistered();\n      const mek = await this.web3.getMekBytes();\n      const encryptData = hex.replace(\"\\\\x\", \"\");\n      const encryptDataBuffer = Buffer.from(encryptData, \"hex\");\n      const header = this._extractCryptoHeader(encryptDataBuffer);\n      const cxtId = this._extractCtxId(header);\n      const { encryptedDek, algorithm } = await this.service.execute({\n        bizType: 111,\n        ctxId: String(cxtId)\n      });\n      const [_, dek] = import_cipher.CipherHelper.decryptDekToBase64(mek, encryptedDek);\n      const afterEncType = this._extractEncType(header);\n      const idx = (header[1] & 7) + 2;\n      const iv = encryptDataBuffer.slice(idx, idx + 16);\n      const cipherBlob = encryptDataBuffer.slice(idx + 16);\n      const plainBlob = import_cipher.CipherHelper.aesDecrypt(dek, iv, cipherBlob);\n      const encodeResult = plainBlob.subarray(0, -1);\n      const checkCode = plainBlob.slice(-1);\n      const checkCode2 = this._genCheckCode(encodeResult, 1);\n      if (checkCode[0] != checkCode2[0]) {\n        throw new Error(\"Check code is not correct\");\n      }\n      const decryptData = import_cipher.CipherHelper.decodeDataByType(\n        Uint8Array.from(encodeResult),\n        afterEncType\n      );\n      return import_result.default.success(decryptData);\n    } catch (e) {\n      console.error(e);\n      return import_result.default.fail(e);\n    }\n  }\n  /**\n   * get dek\n   * @param schema\n   * @param table\n   * @param column\n   * @param walletAddress\n   * @private\n   */\n  async _getOrGenDek(table, column, walletAddress) {\n    const mekBuffer = await this.web3.getMekBytes();\n    let cc = await this._queryCCEntryByName(\n      table,\n      column,\n      walletAddress\n    ).catch((e) => {\n    });\n    if (!cc) {\n      cc = await this._genCCEntryFromLocal(table, column);\n    }\n    const { ctxId, dekId, encryptedDek, algorithm } = cc;\n    const [, decryptedDek] = import_cipher.CipherHelper.decryptDekToBase64(\n      mekBuffer,\n      encryptedDek\n    );\n    return { ctxId, decryptedDek, algorithm };\n  }\n  async _queryCCEntryByName(table, column, walletAddress) {\n    return await this.service.execute({\n      bizType: 108,\n      table,\n      column,\n      walletAddress\n    });\n  }\n  async _genCCEntryFromLocal(table, column) {\n    const dekId = await this.service.execute({\n      bizType: 109,\n      mekId: this.sdk.mekId\n    });\n    const dek = import_cipher.CipherHelper.randomBytes();\n    const mek = await this.web3.getMekBytes();\n    return this._genSQLInsertDek(\n      this.sdk.mekId,\n      dekId,\n      mek,\n      dek,\n      3,\n      table,\n      column\n    );\n  }\n  async _genSQLInsertDek(mekId, dekId, mek, dek, alg = 3, table, column) {\n    var _a;\n    const dekCipherStr = import_cipher.CipherHelper.encryptDekToBase64(mek, dekId, dek);\n    const grpIdStr = (0, import_uuid.v4)();\n    const uuidStringWithoutHyphen = grpIdStr.replace(/-/g, \"\");\n    const _gripId = Buffer.from(\n      ((_a = uuidStringWithoutHyphen.match(/.{1,2}/g)) == null ? void 0 : _a.map((byte) => parseInt(byte, 16))) || []\n    );\n    const gAuthStr = import_cipher.CipherHelper.digest_gAuth(mek, _gripId, dekId);\n    return this.service.execute({\n      bizType: 110,\n      table,\n      column,\n      schema: \"public\",\n      mekId,\n      dekId,\n      dekCipherStr,\n      grpIdStr,\n      groupAuthStr: gAuthStr\n    });\n  }\n  _genCryptoHeader(ctxId, encType) {\n    let head = Buffer.from(\"0000\", \"hex\");\n    let tmp_value = head[1];\n    tmp_value = tmp_value & 4294967047;\n    tmp_value = tmp_value | encType << 3;\n    head[1] = tmp_value;\n    let tmp = ctxId;\n    while (tmp != 0) {\n      head = Buffer.concat([head, Buffer.alloc(1).fill(tmp & 255)]);\n      tmp >>= 8;\n    }\n    const ctxLen = head.length - 2;\n    let tmp_val = head[1];\n    tmp_val = tmp_val & 4294967288 | ctxLen & 7;\n    head[1] = tmp_val;\n    return head;\n  }\n  _extractCryptoHeader(data) {\n    let header = [];\n    let index = 0;\n    for (let i = 0; i < 1; i++) {\n      header.push(data[index]);\n      index++;\n    }\n    if (index !== 1) {\n      throw new Error(\"Invalid header index\");\n    }\n    header.push(data[index]);\n    index++;\n    const rng = header[1] & 7;\n    for (let i = 0; i < rng; i++) {\n      header.push(data[index]);\n      index++;\n    }\n    return Buffer.from(header);\n  }\n  _extractEncType(header) {\n    const tmp_value = header[1];\n    const type_value = (tmp_value & 248) >> 3;\n    return type_value;\n  }\n  _extractCtxId(header) {\n    const ctxIdLen = header[1] & 7;\n    if (header.length !== ctxIdLen + 2) {\n      throw new Error(\"Invalid header length\");\n    }\n    let ctxId = 0;\n    for (let i = 0; i < ctxIdLen; i++) {\n      const index = header.length - 1 - i;\n      ctxId = ctxId << 8 | header[index] & 255;\n    }\n    return ctxId;\n  }\n  _genCheckCode(encodeData, resultSize) {\n    let tmpCode = new Uint8Array(resultSize);\n    for (let i = 0; i < encodeData.length; i++) {\n      let n = i % resultSize;\n      tmpCode[n] ^= encodeData[i];\n    }\n    return Buffer.from(tmpCode);\n  }\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {});\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}