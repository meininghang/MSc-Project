{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.typed-array.to-reversed.js\");\nrequire(\"core-js/modules/es.typed-array.to-sorted.js\");\nrequire(\"core-js/modules/es.typed-array.with.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransactionUploader = void 0;\nconst transaction_1 = require(\"./transaction\");\nconst ArweaveUtils = require(\"./utils\");\nconst error_1 = require(\"./error\");\nconst merkle_1 = require(\"./merkle\");\n// Maximum amount of chunks we will upload in the body.\nconst MAX_CHUNKS_IN_BODY = 1;\n// We assume these errors are intermitment and we can try again after a delay:\n// - not_joined\n// - timeout\n// - data_root_not_found (we may have hit a node that just hasn't seen it yet)\n// - exceeds_disk_pool_size_limit\n// We also try again after any kind of unexpected network errors\n// Errors from /chunk we should never try and continue on.\nconst FATAL_CHUNK_UPLOAD_ERRORS = [\"invalid_json\", \"chunk_too_big\", \"data_path_too_big\", \"offset_too_big\", \"data_size_too_big\", \"chunk_proof_ratio_not_attractive\", \"invalid_proof\"];\n// Amount we will delay on receiving an error response but do want to continue.\nconst ERROR_DELAY = 1000 * 40;\nclass TransactionUploader {\n  get isComplete() {\n    return this.txPosted && this.chunkIndex === this.transaction.chunks.chunks.length;\n  }\n  get totalChunks() {\n    return this.transaction.chunks.chunks.length;\n  }\n  get uploadedChunks() {\n    return this.chunkIndex;\n  }\n  get pctComplete() {\n    return Math.trunc(this.uploadedChunks / this.totalChunks * 100);\n  }\n  constructor(api, transaction) {\n    this.api = api;\n    this.chunkIndex = 0;\n    this.txPosted = false;\n    this.lastRequestTimeEnd = 0;\n    this.totalErrors = 0; // Not serialized.\n    this.lastResponseStatus = 0;\n    this.lastResponseError = \"\";\n    if (!transaction.id) {\n      throw new Error(`Transaction is not signed`);\n    }\n    if (!transaction.chunks) {\n      throw new Error(`Transaction chunks not prepared`);\n    }\n    // Make a copy of transaction, zeroing the data so we can serialize.\n    this.data = transaction.data;\n    this.transaction = new transaction_1.default(Object.assign({}, transaction, {\n      data: new Uint8Array(0)\n    }));\n  }\n  /**\n   * Uploads the next part of the transaction.\n   * On the first call this posts the transaction\n   * itself and on any subsequent calls uploads the\n   * next chunk until it completes.\n   */\n  async uploadChunk(chunkIndex_) {\n    if (this.isComplete) {\n      throw new Error(`Upload is already complete`);\n    }\n    if (this.lastResponseError !== \"\") {\n      this.totalErrors++;\n    } else {\n      this.totalErrors = 0;\n    }\n    // We have been trying for about an hour receiving an\n    // error every time, so eventually bail.\n    if (this.totalErrors === 100) {\n      throw new Error(`Unable to complete upload: ${this.lastResponseStatus}: ${this.lastResponseError}`);\n    }\n    let delay = this.lastResponseError === \"\" ? 0 : Math.max(this.lastRequestTimeEnd + ERROR_DELAY - Date.now(), ERROR_DELAY);\n    if (delay > 0) {\n      // Jitter delay bcoz networks, subtract up to 30% from 40 seconds\n      delay = delay - delay * Math.random() * 0.3;\n      await new Promise(res => setTimeout(res, delay));\n    }\n    this.lastResponseError = \"\";\n    if (!this.txPosted) {\n      await this.postTransaction();\n      return;\n    }\n    if (chunkIndex_) {\n      this.chunkIndex = chunkIndex_;\n    }\n    const chunk = this.transaction.getChunk(chunkIndex_ || this.chunkIndex, this.data);\n    const chunkOk = await (0, merkle_1.validatePath)(this.transaction.chunks.data_root, parseInt(chunk.offset), 0, parseInt(chunk.data_size), ArweaveUtils.b64UrlToBuffer(chunk.data_path));\n    if (!chunkOk) {\n      throw new Error(`Unable to validate chunk ${this.chunkIndex}`);\n    }\n    // Catch network errors and turn them into objects with status -1 and an error message.\n    const resp = await this.api.post(`chunk`, this.transaction.getChunk(this.chunkIndex, this.data)).catch(e => {\n      console.error(e.message);\n      return {\n        status: -1,\n        data: {\n          error: e.message\n        }\n      };\n    });\n    this.lastRequestTimeEnd = Date.now();\n    this.lastResponseStatus = resp.status;\n    if (this.lastResponseStatus == 200) {\n      this.chunkIndex++;\n    } else {\n      this.lastResponseError = (0, error_1.getError)(resp);\n      if (FATAL_CHUNK_UPLOAD_ERRORS.includes(this.lastResponseError)) {\n        throw new Error(`Fatal error uploading chunk ${this.chunkIndex}: ${this.lastResponseError}`);\n      }\n    }\n  }\n  /**\n   * Reconstructs an upload from its serialized state and data.\n   * Checks if data matches the expected data_root.\n   *\n   * @param serialized\n   * @param data\n   */\n  static async fromSerialized(api, serialized, data) {\n    if (!serialized || typeof serialized.chunkIndex !== \"number\" || typeof serialized.transaction !== \"object\") {\n      throw new Error(`Serialized object does not match expected format.`);\n    }\n    // Everything looks ok, reconstruct the TransactionUpload,\n    // prepare the chunks again and verify the data_root matches\n    var transaction = new transaction_1.default(serialized.transaction);\n    if (!transaction.chunks) {\n      await transaction.prepareChunks(data);\n    }\n    const upload = new TransactionUploader(api, transaction);\n    // Copy the serialized upload information, and data passed in.\n    upload.chunkIndex = serialized.chunkIndex;\n    upload.lastRequestTimeEnd = serialized.lastRequestTimeEnd;\n    upload.lastResponseError = serialized.lastResponseError;\n    upload.lastResponseStatus = serialized.lastResponseStatus;\n    upload.txPosted = serialized.txPosted;\n    upload.data = data;\n    if (upload.transaction.data_root !== serialized.transaction.data_root) {\n      throw new Error(`Data mismatch: Uploader doesn't match provided data.`);\n    }\n    return upload;\n  }\n  /**\n   * Reconstruct an upload from the tx metadata, ie /tx/<id>.\n   *\n   * @param api\n   * @param id\n   * @param data\n   */\n  static async fromTransactionId(api, id) {\n    const resp = await api.get(`tx/${id}`);\n    if (resp.status !== 200) {\n      throw new Error(`Tx ${id} not found: ${resp.status}`);\n    }\n    const transaction = resp.data;\n    transaction.data = new Uint8Array(0);\n    const serialized = {\n      txPosted: true,\n      chunkIndex: 0,\n      lastResponseError: \"\",\n      lastRequestTimeEnd: 0,\n      lastResponseStatus: 0,\n      transaction\n    };\n    return serialized;\n  }\n  toJSON() {\n    return {\n      chunkIndex: this.chunkIndex,\n      transaction: this.transaction,\n      lastRequestTimeEnd: this.lastRequestTimeEnd,\n      lastResponseStatus: this.lastResponseStatus,\n      lastResponseError: this.lastResponseError,\n      txPosted: this.txPosted\n    };\n  }\n  // POST to /tx\n  async postTransaction() {\n    const uploadInBody = this.totalChunks <= MAX_CHUNKS_IN_BODY;\n    if (uploadInBody) {\n      // Post the transaction with data.\n      this.transaction.data = this.data;\n      const resp = await this.api.post(`tx`, this.transaction).catch(e => {\n        console.error(e);\n        return {\n          status: -1,\n          data: {\n            error: e.message\n          }\n        };\n      });\n      this.lastRequestTimeEnd = Date.now();\n      this.lastResponseStatus = resp.status;\n      this.transaction.data = new Uint8Array(0);\n      if (resp.status >= 200 && resp.status < 300) {\n        // We are complete.\n        this.txPosted = true;\n        this.chunkIndex = MAX_CHUNKS_IN_BODY;\n        return;\n      }\n      this.lastResponseError = (0, error_1.getError)(resp);\n      throw new Error(`Unable to upload transaction: ${resp.status}, ${this.lastResponseError}`);\n    }\n    // Post the transaction with no data.\n    const resp = await this.api.post(`tx`, this.transaction);\n    this.lastRequestTimeEnd = Date.now();\n    this.lastResponseStatus = resp.status;\n    if (!(resp.status >= 200 && resp.status < 300)) {\n      this.lastResponseError = (0, error_1.getError)(resp);\n      throw new Error(`Unable to upload transaction: ${resp.status}, ${this.lastResponseError}`);\n    }\n    this.txPosted = true;\n  }\n}\nexports.TransactionUploader = TransactionUploader;","map":{"version":3,"names":["transaction_1","require","ArweaveUtils","error_1","merkle_1","MAX_CHUNKS_IN_BODY","FATAL_CHUNK_UPLOAD_ERRORS","ERROR_DELAY","TransactionUploader","isComplete","txPosted","chunkIndex","transaction","chunks","length","totalChunks","uploadedChunks","pctComplete","Math","trunc","constructor","api","lastRequestTimeEnd","totalErrors","lastResponseStatus","lastResponseError","id","Error","data","default","Object","assign","Uint8Array","uploadChunk","chunkIndex_","delay","max","Date","now","random","Promise","res","setTimeout","postTransaction","chunk","getChunk","chunkOk","validatePath","data_root","parseInt","offset","data_size","b64UrlToBuffer","data_path","resp","post","catch","e","console","error","message","status","getError","includes","fromSerialized","serialized","prepareChunks","upload","fromTransactionId","get","toJSON","uploadInBody","exports"],"sources":["../../../../src/common/lib/transaction-uploader.ts"],"sourcesContent":[null],"mappings":";;;;;;;;;AAAA,MAAAA,aAAA,GAAAC,OAAA;AACA,MAAAC,YAAA,GAAAD,OAAA;AAEA,MAAAE,OAAA,GAAAF,OAAA;AACA,MAAAG,QAAA,GAAAH,OAAA;AAEA;AACA,MAAMI,kBAAkB,GAAG,CAAC;AAE5B;AACA;AACA;AACA;AACA;AACA;AAEA;AACA,MAAMC,yBAAyB,GAAG,CAChC,cAAc,EACd,eAAe,EACf,mBAAmB,EACnB,gBAAgB,EAChB,mBAAmB,EACnB,kCAAkC,EAClC,eAAe,CAChB;AAED;AACA,MAAMC,WAAW,GAAG,IAAI,GAAG,EAAE;AAW7B,MAAaC,mBAAmB;EAW9B,IAAWC,UAAUA,CAAA;IACnB,OACE,IAAI,CAACC,QAAQ,IACb,IAAI,CAACC,UAAU,KAAK,IAAI,CAACC,WAAW,CAACC,MAAO,CAACA,MAAM,CAACC,MAAM;EAE9D;EAEA,IAAWC,WAAWA,CAAA;IACpB,OAAO,IAAI,CAACH,WAAW,CAACC,MAAO,CAACA,MAAM,CAACC,MAAM;EAC/C;EAEA,IAAWE,cAAcA,CAAA;IACvB,OAAO,IAAI,CAACL,UAAU;EACxB;EAEA,IAAWM,WAAWA,CAAA;IACpB,OAAOC,IAAI,CAACC,KAAK,CAAE,IAAI,CAACH,cAAc,GAAG,IAAI,CAACD,WAAW,GAAI,GAAG,CAAC;EACnE;EAEAK,YAAoBC,GAAQ,EAAET,WAAwB;IAAlC,KAAAS,GAAG,GAAHA,GAAG;IA7Bf,KAAAV,UAAU,GAAW,CAAC;IACtB,KAAAD,QAAQ,GAAY,KAAK;IAEzB,KAAAY,kBAAkB,GAAW,CAAC;IAC9B,KAAAC,WAAW,GAAG,CAAC,CAAC,CAAC;IAGlB,KAAAC,kBAAkB,GAAW,CAAC;IAC9B,KAAAC,iBAAiB,GAAW,EAAE;IAsBnC,IAAI,CAACb,WAAW,CAACc,EAAE,EAAE;MACnB,MAAM,IAAIC,KAAK,CAAC,2BAA2B,CAAC;;IAE9C,IAAI,CAACf,WAAW,CAACC,MAAM,EAAE;MACvB,MAAM,IAAIc,KAAK,CAAC,iCAAiC,CAAC;;IAEpD;IACA,IAAI,CAACC,IAAI,GAAGhB,WAAW,CAACgB,IAAI;IAC5B,IAAI,CAAChB,WAAW,GAAG,IAAIZ,aAAA,CAAA6B,OAAW,CAChCC,MAAM,CAACC,MAAM,CAAC,EAAE,EAAEnB,WAAW,EAAE;MAAEgB,IAAI,EAAE,IAAII,UAAU,CAAC,CAAC;IAAC,CAAE,CAAC,CAC5D;EACH;EAEA;;;;;;EAMO,MAAMC,WAAWA,CAACC,WAAoB;IAC3C,IAAI,IAAI,CAACzB,UAAU,EAAE;MACnB,MAAM,IAAIkB,KAAK,CAAC,4BAA4B,CAAC;;IAG/C,IAAI,IAAI,CAACF,iBAAiB,KAAK,EAAE,EAAE;MACjC,IAAI,CAACF,WAAW,EAAE;KACnB,MAAM;MACL,IAAI,CAACA,WAAW,GAAG,CAAC;;IAGtB;IACA;IACA,IAAI,IAAI,CAACA,WAAW,KAAK,GAAG,EAAE;MAC5B,MAAM,IAAII,KAAK,CACb,8BAA8B,IAAI,CAACH,kBAAkB,KAAK,IAAI,CAACC,iBAAiB,EAAE,CACnF;;IAGH,IAAIU,KAAK,GACP,IAAI,CAACV,iBAAiB,KAAK,EAAE,GACzB,CAAC,GACDP,IAAI,CAACkB,GAAG,CACN,IAAI,CAACd,kBAAkB,GAAGf,WAAW,GAAG8B,IAAI,CAACC,GAAG,EAAE,EAClD/B,WAAW,CACZ;IAEP,IAAI4B,KAAK,GAAG,CAAC,EAAE;MACb;MACAA,KAAK,GAAGA,KAAK,GAAGA,KAAK,GAAGjB,IAAI,CAACqB,MAAM,EAAE,GAAG,GAAG;MAC3C,MAAM,IAAIC,OAAO,CAAEC,GAAG,IAAKC,UAAU,CAACD,GAAG,EAAEN,KAAK,CAAC,CAAC;;IAGpD,IAAI,CAACV,iBAAiB,GAAG,EAAE;IAE3B,IAAI,CAAC,IAAI,CAACf,QAAQ,EAAE;MAClB,MAAM,IAAI,CAACiC,eAAe,EAAE;MAC5B;;IAGF,IAAIT,WAAW,EAAE;MACf,IAAI,CAACvB,UAAU,GAAGuB,WAAW;;IAG/B,MAAMU,KAAK,GAAG,IAAI,CAAChC,WAAW,CAACiC,QAAQ,CACrCX,WAAW,IAAI,IAAI,CAACvB,UAAU,EAC9B,IAAI,CAACiB,IAAI,CACV;IAED,MAAMkB,OAAO,GAAG,MAAM,IAAA1C,QAAA,CAAA2C,YAAY,EAChC,IAAI,CAACnC,WAAW,CAACC,MAAO,CAACmC,SAAS,EAClCC,QAAQ,CAACL,KAAK,CAACM,MAAM,CAAC,EACtB,CAAC,EACDD,QAAQ,CAACL,KAAK,CAACO,SAAS,CAAC,EACzBjD,YAAY,CAACkD,cAAc,CAACR,KAAK,CAACS,SAAS,CAAC,CAC7C;IACD,IAAI,CAACP,OAAO,EAAE;MACZ,MAAM,IAAInB,KAAK,CAAC,4BAA4B,IAAI,CAAChB,UAAU,EAAE,CAAC;;IAGhE;IACA,MAAM2C,IAAI,GAAG,MAAM,IAAI,CAACjC,GAAG,CACxBkC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC3C,WAAW,CAACiC,QAAQ,CAAC,IAAI,CAAClC,UAAU,EAAE,IAAI,CAACiB,IAAI,CAAC,CAAC,CACpE4B,KAAK,CAAEC,CAAC,IAAI;MACXC,OAAO,CAACC,KAAK,CAACF,CAAC,CAACG,OAAO,CAAC;MACxB,OAAO;QAAEC,MAAM,EAAE,CAAC,CAAC;QAAEjC,IAAI,EAAE;UAAE+B,KAAK,EAAEF,CAAC,CAACG;QAAO;MAAE,CAAE;IACnD,CAAC,CAAC;IAEJ,IAAI,CAACtC,kBAAkB,GAAGe,IAAI,CAACC,GAAG,EAAE;IACpC,IAAI,CAACd,kBAAkB,GAAG8B,IAAI,CAACO,MAAM;IAErC,IAAI,IAAI,CAACrC,kBAAkB,IAAI,GAAG,EAAE;MAClC,IAAI,CAACb,UAAU,EAAE;KAClB,MAAM;MACL,IAAI,CAACc,iBAAiB,GAAG,IAAAtB,OAAA,CAAA2D,QAAQ,EAACR,IAAI,CAAC;MACvC,IAAIhD,yBAAyB,CAACyD,QAAQ,CAAC,IAAI,CAACtC,iBAAiB,CAAC,EAAE;QAC9D,MAAM,IAAIE,KAAK,CACb,+BAA+B,IAAI,CAAChB,UAAU,KAAK,IAAI,CAACc,iBAAiB,EAAE,CAC5E;;;EAGP;EAEA;;;;;;;EAOO,aAAauC,cAAcA,CAChC3C,GAAQ,EACR4C,UAA8B,EAC9BrC,IAAgB;IAEhB,IACE,CAACqC,UAAU,IACX,OAAOA,UAAU,CAACtD,UAAU,KAAK,QAAQ,IACzC,OAAOsD,UAAU,CAACrD,WAAW,KAAK,QAAQ,EAC1C;MACA,MAAM,IAAIe,KAAK,CAAC,mDAAmD,CAAC;;IAGtE;IACA;IACA,IAAIf,WAAW,GAAG,IAAIZ,aAAA,CAAA6B,OAAW,CAACoC,UAAU,CAACrD,WAAW,CAAC;IACzD,IAAI,CAACA,WAAW,CAACC,MAAM,EAAE;MACvB,MAAMD,WAAW,CAACsD,aAAa,CAACtC,IAAI,CAAC;;IAGvC,MAAMuC,MAAM,GAAG,IAAI3D,mBAAmB,CAACa,GAAG,EAAET,WAAW,CAAC;IAExD;IACAuD,MAAM,CAACxD,UAAU,GAAGsD,UAAU,CAACtD,UAAU;IACzCwD,MAAM,CAAC7C,kBAAkB,GAAG2C,UAAU,CAAC3C,kBAAkB;IACzD6C,MAAM,CAAC1C,iBAAiB,GAAGwC,UAAU,CAACxC,iBAAiB;IACvD0C,MAAM,CAAC3C,kBAAkB,GAAGyC,UAAU,CAACzC,kBAAkB;IACzD2C,MAAM,CAACzD,QAAQ,GAAGuD,UAAU,CAACvD,QAAQ;IACrCyD,MAAM,CAACvC,IAAI,GAAGA,IAAI;IAElB,IAAIuC,MAAM,CAACvD,WAAW,CAACoC,SAAS,KAAKiB,UAAU,CAACrD,WAAW,CAACoC,SAAS,EAAE;MACrE,MAAM,IAAIrB,KAAK,CAAC,sDAAsD,CAAC;;IAGzE,OAAOwC,MAAM;EACf;EAEA;;;;;;;EAOO,aAAaC,iBAAiBA,CACnC/C,GAAQ,EACRK,EAAU;IAEV,MAAM4B,IAAI,GAAG,MAAMjC,GAAG,CAACgD,GAAG,CAAC,MAAM3C,EAAE,EAAE,CAAC;IAEtC,IAAI4B,IAAI,CAACO,MAAM,KAAK,GAAG,EAAE;MACvB,MAAM,IAAIlC,KAAK,CAAC,MAAMD,EAAE,eAAe4B,IAAI,CAACO,MAAM,EAAE,CAAC;;IAGvD,MAAMjD,WAAW,GAAG0C,IAAI,CAAC1B,IAAI;IAC7BhB,WAAW,CAACgB,IAAI,GAAG,IAAII,UAAU,CAAC,CAAC,CAAC;IAEpC,MAAMiC,UAAU,GAAuB;MACrCvD,QAAQ,EAAE,IAAI;MACdC,UAAU,EAAE,CAAC;MACbc,iBAAiB,EAAE,EAAE;MACrBH,kBAAkB,EAAE,CAAC;MACrBE,kBAAkB,EAAE,CAAC;MACrBZ;KACD;IAED,OAAOqD,UAAU;EACnB;EAEOK,MAAMA,CAAA;IACX,OAAO;MACL3D,UAAU,EAAE,IAAI,CAACA,UAAU;MAC3BC,WAAW,EAAE,IAAI,CAACA,WAAW;MAC7BU,kBAAkB,EAAE,IAAI,CAACA,kBAAkB;MAC3CE,kBAAkB,EAAE,IAAI,CAACA,kBAAkB;MAC3CC,iBAAiB,EAAE,IAAI,CAACA,iBAAiB;MACzCf,QAAQ,EAAE,IAAI,CAACA;KAChB;EACH;EAEA;EACQ,MAAMiC,eAAeA,CAAA;IAC3B,MAAM4B,YAAY,GAAG,IAAI,CAACxD,WAAW,IAAIV,kBAAkB;IAE3D,IAAIkE,YAAY,EAAE;MAChB;MACA,IAAI,CAAC3D,WAAW,CAACgB,IAAI,GAAG,IAAI,CAACA,IAAI;MACjC,MAAM0B,IAAI,GAAG,MAAM,IAAI,CAACjC,GAAG,CAACkC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC3C,WAAW,CAAC,CAAC4C,KAAK,CAAEC,CAAC,IAAI;QACnEC,OAAO,CAACC,KAAK,CAACF,CAAC,CAAC;QAChB,OAAO;UAAEI,MAAM,EAAE,CAAC,CAAC;UAAEjC,IAAI,EAAE;YAAE+B,KAAK,EAAEF,CAAC,CAACG;UAAO;QAAE,CAAE;MACnD,CAAC,CAAC;MAEF,IAAI,CAACtC,kBAAkB,GAAGe,IAAI,CAACC,GAAG,EAAE;MACpC,IAAI,CAACd,kBAAkB,GAAG8B,IAAI,CAACO,MAAM;MACrC,IAAI,CAACjD,WAAW,CAACgB,IAAI,GAAG,IAAII,UAAU,CAAC,CAAC,CAAC;MAEzC,IAAIsB,IAAI,CAACO,MAAM,IAAI,GAAG,IAAIP,IAAI,CAACO,MAAM,GAAG,GAAG,EAAE;QAC3C;QACA,IAAI,CAACnD,QAAQ,GAAG,IAAI;QACpB,IAAI,CAACC,UAAU,GAAGN,kBAAkB;QACpC;;MAEF,IAAI,CAACoB,iBAAiB,GAAG,IAAAtB,OAAA,CAAA2D,QAAQ,EAACR,IAAI,CAAC;MACvC,MAAM,IAAI3B,KAAK,CACb,iCAAiC2B,IAAI,CAACO,MAAM,KAAK,IAAI,CAACpC,iBAAiB,EAAE,CAC1E;;IAGH;IACA,MAAM6B,IAAI,GAAG,MAAM,IAAI,CAACjC,GAAG,CAACkC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC3C,WAAW,CAAC;IACxD,IAAI,CAACU,kBAAkB,GAAGe,IAAI,CAACC,GAAG,EAAE;IACpC,IAAI,CAACd,kBAAkB,GAAG8B,IAAI,CAACO,MAAM;IACrC,IAAI,EAAEP,IAAI,CAACO,MAAM,IAAI,GAAG,IAAIP,IAAI,CAACO,MAAM,GAAG,GAAG,CAAC,EAAE;MAC9C,IAAI,CAACpC,iBAAiB,GAAG,IAAAtB,OAAA,CAAA2D,QAAQ,EAACR,IAAI,CAAC;MACvC,MAAM,IAAI3B,KAAK,CACb,iCAAiC2B,IAAI,CAACO,MAAM,KAAK,IAAI,CAACpC,iBAAiB,EAAE,CAC1E;;IAEH,IAAI,CAACf,QAAQ,GAAG,IAAI;EACtB;;AAnQF8D,OAAA,CAAAhE,mBAAA,GAAAA,mBAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}