{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.typed-array.to-reversed.js\");\nrequire(\"core-js/modules/es.typed-array.to-sorted.js\");\nrequire(\"core-js/modules/es.typed-array.with.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.debug = exports.validatePath = exports.arrayCompare = exports.bufferToInt = exports.intToBuffer = exports.arrayFlatten = exports.generateProofs = exports.buildLayers = exports.generateTransactionChunks = exports.generateTree = exports.computeRootHash = exports.generateLeaves = exports.chunkData = exports.MIN_CHUNK_SIZE = exports.MAX_CHUNK_SIZE = void 0;\n/**\n * @see {@link https://github.com/ArweaveTeam/arweave/blob/fbc381e0e36efffa45d13f2faa6199d3766edaa2/apps/arweave/src/ar_merkle.erl}\n */\nconst common_1 = require(\"../common\");\nconst utils_1 = require(\"./utils\");\nexports.MAX_CHUNK_SIZE = 256 * 1024;\nexports.MIN_CHUNK_SIZE = 32 * 1024;\nconst NOTE_SIZE = 32;\nconst HASH_SIZE = 32;\n/**\n * Takes the input data and chunks it into (mostly) equal sized chunks.\n * The last chunk will be a bit smaller as it contains the remainder\n * from the chunking process.\n */\nasync function chunkData(data) {\n  let chunks = [];\n  let rest = data;\n  let cursor = 0;\n  while (rest.byteLength >= exports.MAX_CHUNK_SIZE) {\n    let chunkSize = exports.MAX_CHUNK_SIZE;\n    // If the total bytes left will produce a chunk < MIN_CHUNK_SIZE,\n    // then adjust the amount we put in this 2nd last chunk.\n    let nextChunkSize = rest.byteLength - exports.MAX_CHUNK_SIZE;\n    if (nextChunkSize > 0 && nextChunkSize < exports.MIN_CHUNK_SIZE) {\n      chunkSize = Math.ceil(rest.byteLength / 2);\n      // console.log(`Last chunk will be: ${nextChunkSize} which is below ${MIN_CHUNK_SIZE}, adjusting current to ${chunkSize} with ${rest.byteLength} left.`)\n    }\n\n    const chunk = rest.slice(0, chunkSize);\n    const dataHash = await common_1.default.crypto.hash(chunk);\n    cursor += chunk.byteLength;\n    chunks.push({\n      dataHash,\n      minByteRange: cursor - chunk.byteLength,\n      maxByteRange: cursor\n    });\n    rest = rest.slice(chunkSize);\n  }\n  chunks.push({\n    dataHash: await common_1.default.crypto.hash(rest),\n    minByteRange: cursor,\n    maxByteRange: cursor + rest.byteLength\n  });\n  return chunks;\n}\nexports.chunkData = chunkData;\nasync function generateLeaves(chunks) {\n  return Promise.all(chunks.map(async ({\n    dataHash,\n    minByteRange,\n    maxByteRange\n  }) => {\n    return {\n      type: \"leaf\",\n      id: await hash(await Promise.all([hash(dataHash), hash(intToBuffer(maxByteRange))])),\n      dataHash: dataHash,\n      minByteRange,\n      maxByteRange\n    };\n  }));\n}\nexports.generateLeaves = generateLeaves;\n/**\n * Builds an arweave merkle tree and gets the root hash for the given input.\n */\nasync function computeRootHash(data) {\n  const rootNode = await generateTree(data);\n  return rootNode.id;\n}\nexports.computeRootHash = computeRootHash;\nasync function generateTree(data) {\n  const rootNode = await buildLayers(await generateLeaves(await chunkData(data)));\n  return rootNode;\n}\nexports.generateTree = generateTree;\n/**\n * Generates the data_root, chunks & proofs\n * needed for a transaction.\n *\n * This also checks if the last chunk is a zero-length\n * chunk and discards that chunk and proof if so.\n * (we do not need to upload this zero length chunk)\n *\n * @param data\n */\nasync function generateTransactionChunks(data) {\n  const chunks = await chunkData(data);\n  const leaves = await generateLeaves(chunks);\n  const root = await buildLayers(leaves);\n  const proofs = await generateProofs(root);\n  // Discard the last chunk & proof if it's zero length.\n  const lastChunk = chunks.slice(-1)[0];\n  if (lastChunk.maxByteRange - lastChunk.minByteRange === 0) {\n    chunks.splice(chunks.length - 1, 1);\n    proofs.splice(proofs.length - 1, 1);\n  }\n  return {\n    data_root: root.id,\n    chunks,\n    proofs\n  };\n}\nexports.generateTransactionChunks = generateTransactionChunks;\n/**\n * Starting with the bottom layer of leaf nodes, hash every second pair\n * into a new branch node, push those branch nodes onto a new layer,\n * and then recurse, building up the tree to it's root, where the\n * layer only consists of two items.\n */\nasync function buildLayers(nodes, level = 0) {\n  // If there is only 1 node left, this is going to be the root node\n  if (nodes.length < 2) {\n    const root = nodes[0];\n    // console.log(\"Root layer\", root);\n    return root;\n  }\n  const nextLayer = [];\n  for (let i = 0; i < nodes.length; i += 2) {\n    nextLayer.push(await hashBranch(nodes[i], nodes[i + 1]));\n  }\n  // console.log(\"Layer\", nextLayer);\n  return buildLayers(nextLayer, level + 1);\n}\nexports.buildLayers = buildLayers;\n/**\n * Recursively search through all branches of the tree,\n * and generate a proof for each leaf node.\n */\nfunction generateProofs(root) {\n  const proofs = resolveBranchProofs(root);\n  if (!Array.isArray(proofs)) {\n    return [proofs];\n  }\n  return arrayFlatten(proofs);\n}\nexports.generateProofs = generateProofs;\nfunction resolveBranchProofs(node, proof = new Uint8Array(), depth = 0) {\n  if (node.type == \"leaf\") {\n    return {\n      offset: node.maxByteRange - 1,\n      proof: (0, utils_1.concatBuffers)([proof, node.dataHash, intToBuffer(node.maxByteRange)])\n    };\n  }\n  if (node.type == \"branch\") {\n    const partialProof = (0, utils_1.concatBuffers)([proof, node.leftChild.id, node.rightChild.id, intToBuffer(node.byteRange)]);\n    return [resolveBranchProofs(node.leftChild, partialProof, depth + 1), resolveBranchProofs(node.rightChild, partialProof, depth + 1)];\n  }\n  throw new Error(`Unexpected node type`);\n}\nfunction arrayFlatten(input) {\n  const flat = [];\n  input.forEach(item => {\n    if (Array.isArray(item)) {\n      flat.push(...arrayFlatten(item));\n    } else {\n      flat.push(item);\n    }\n  });\n  return flat;\n}\nexports.arrayFlatten = arrayFlatten;\nasync function hashBranch(left, right) {\n  if (!right) {\n    return left;\n  }\n  let branch = {\n    type: \"branch\",\n    id: await hash([await hash(left.id), await hash(right.id), await hash(intToBuffer(left.maxByteRange))]),\n    byteRange: left.maxByteRange,\n    maxByteRange: right.maxByteRange,\n    leftChild: left,\n    rightChild: right\n  };\n  return branch;\n}\nasync function hash(data) {\n  if (Array.isArray(data)) {\n    data = common_1.default.utils.concatBuffers(data);\n  }\n  return new Uint8Array(await common_1.default.crypto.hash(data));\n}\nfunction intToBuffer(note) {\n  const buffer = new Uint8Array(NOTE_SIZE);\n  for (var i = buffer.length - 1; i >= 0; i--) {\n    var byte = note % 256;\n    buffer[i] = byte;\n    note = (note - byte) / 256;\n  }\n  return buffer;\n}\nexports.intToBuffer = intToBuffer;\nfunction bufferToInt(buffer) {\n  let value = 0;\n  for (var i = 0; i < buffer.length; i++) {\n    value *= 256;\n    value += buffer[i];\n  }\n  return value;\n}\nexports.bufferToInt = bufferToInt;\nconst arrayCompare = (a, b) => a.every((value, index) => b[index] === value);\nexports.arrayCompare = arrayCompare;\nasync function validatePath(id, dest, leftBound, rightBound, path) {\n  if (rightBound <= 0) {\n    return false;\n  }\n  if (dest >= rightBound) {\n    return validatePath(id, 0, rightBound - 1, rightBound, path);\n  }\n  if (dest < 0) {\n    return validatePath(id, 0, 0, rightBound, path);\n  }\n  if (path.length == HASH_SIZE + NOTE_SIZE) {\n    const pathData = path.slice(0, HASH_SIZE);\n    const endOffsetBuffer = path.slice(pathData.length, pathData.length + NOTE_SIZE);\n    const pathDataHash = await hash([await hash(pathData), await hash(endOffsetBuffer)]);\n    let result = (0, exports.arrayCompare)(id, pathDataHash);\n    if (result) {\n      return {\n        offset: rightBound - 1,\n        leftBound: leftBound,\n        rightBound: rightBound,\n        chunkSize: rightBound - leftBound\n      };\n    }\n    return false;\n  }\n  const left = path.slice(0, HASH_SIZE);\n  const right = path.slice(left.length, left.length + HASH_SIZE);\n  const offsetBuffer = path.slice(left.length + right.length, left.length + right.length + NOTE_SIZE);\n  const offset = bufferToInt(offsetBuffer);\n  const remainder = path.slice(left.length + right.length + offsetBuffer.length);\n  const pathHash = await hash([await hash(left), await hash(right), await hash(offsetBuffer)]);\n  if ((0, exports.arrayCompare)(id, pathHash)) {\n    if (dest < offset) {\n      return await validatePath(left, dest, leftBound, Math.min(rightBound, offset), remainder);\n    }\n    return await validatePath(right, dest, Math.max(leftBound, offset), rightBound, remainder);\n  }\n  return false;\n}\nexports.validatePath = validatePath;\n/**\n * Inspect an arweave chunk proof.\n * Takes proof, parses, reads and displays the values for console logging.\n * One proof section per line\n * Format: left,right,offset => hash\n */\nasync function debug(proof, output = \"\") {\n  if (proof.byteLength < 1) {\n    return output;\n  }\n  const left = proof.slice(0, HASH_SIZE);\n  const right = proof.slice(left.length, left.length + HASH_SIZE);\n  const offsetBuffer = proof.slice(left.length + right.length, left.length + right.length + NOTE_SIZE);\n  const offset = bufferToInt(offsetBuffer);\n  const remainder = proof.slice(left.length + right.length + offsetBuffer.length);\n  const pathHash = await hash([await hash(left), await hash(right), await hash(offsetBuffer)]);\n  const updatedOutput = `${output}\\n${JSON.stringify(Buffer.from(left))},${JSON.stringify(Buffer.from(right))},${offset} => ${JSON.stringify(pathHash)}`;\n  return debug(remainder, updatedOutput);\n}\nexports.debug = debug;","map":{"version":3,"names":["common_1","require","utils_1","exports","MAX_CHUNK_SIZE","MIN_CHUNK_SIZE","NOTE_SIZE","HASH_SIZE","chunkData","data","chunks","rest","cursor","byteLength","chunkSize","nextChunkSize","Math","ceil","chunk","slice","dataHash","default","crypto","hash","push","minByteRange","maxByteRange","generateLeaves","Promise","all","map","type","id","intToBuffer","computeRootHash","rootNode","generateTree","buildLayers","generateTransactionChunks","leaves","root","proofs","generateProofs","lastChunk","splice","length","data_root","nodes","level","nextLayer","i","hashBranch","resolveBranchProofs","Array","isArray","arrayFlatten","node","proof","Uint8Array","depth","offset","concatBuffers","partialProof","leftChild","rightChild","byteRange","Error","input","flat","forEach","item","left","right","branch","utils","note","buffer","byte","bufferToInt","value","arrayCompare","a","b","every","index","validatePath","dest","leftBound","rightBound","path","pathData","endOffsetBuffer","pathDataHash","result","offsetBuffer","remainder","pathHash","min","max","debug","output","updatedOutput","JSON","stringify","Buffer","from"],"sources":["../../../../src/common/lib/merkle.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}