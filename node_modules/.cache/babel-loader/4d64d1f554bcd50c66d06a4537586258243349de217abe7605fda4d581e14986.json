{"ast":null,"code":"\"use strict\";\n\n/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nrequire(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.typed-array.to-reversed.js\");\nrequire(\"core-js/modules/es.typed-array.to-sorted.js\");\nrequire(\"core-js/modules/es.typed-array.with.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.utils = exports.curve25519 = exports.getSharedSecret = exports.sync = exports.verify = exports.sign = exports.getPublicKey = exports.Signature = exports.Point = exports.RistrettoPoint = exports.ExtendedPoint = exports.CURVE = void 0;\nconst nodeCrypto = require(\"crypto\");\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _8n = BigInt(8);\nconst CU_O = BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989');\nconst CURVE = Object.freeze({\n  a: BigInt(-1),\n  d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),\n  P: BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819949'),\n  l: CU_O,\n  n: CU_O,\n  h: BigInt(8),\n  Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),\n  Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960')\n});\nexports.CURVE = CURVE;\nconst POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');\nconst SQRT_M1 = BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');\nconst SQRT_D = BigInt('6853475219497561581579357271197624642482790079785650197046958215289687604742');\nconst SQRT_AD_MINUS_ONE = BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');\nconst INVSQRT_A_MINUS_D = BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');\nconst ONE_MINUS_D_SQ = BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');\nconst D_MINUS_ONE_SQ = BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');\nclass ExtendedPoint {\n  constructor(x, y, z, t) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.t = t;\n  }\n  static fromAffine(p) {\n    if (!(p instanceof Point)) {\n      throw new TypeError('ExtendedPoint#fromAffine: expected Point');\n    }\n    if (p.equals(Point.ZERO)) return ExtendedPoint.ZERO;\n    return new ExtendedPoint(p.x, p.y, _1n, mod(p.x * p.y));\n  }\n  static toAffineBatch(points) {\n    const toInv = invertBatch(points.map(p => p.z));\n    return points.map((p, i) => p.toAffine(toInv[i]));\n  }\n  static normalizeZ(points) {\n    return this.toAffineBatch(points).map(this.fromAffine);\n  }\n  equals(other) {\n    assertExtPoint(other);\n    const {\n      x: X1,\n      y: Y1,\n      z: Z1\n    } = this;\n    const {\n      x: X2,\n      y: Y2,\n      z: Z2\n    } = other;\n    const X1Z2 = mod(X1 * Z2);\n    const X2Z1 = mod(X2 * Z1);\n    const Y1Z2 = mod(Y1 * Z2);\n    const Y2Z1 = mod(Y2 * Z1);\n    return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n  }\n  negate() {\n    return new ExtendedPoint(mod(-this.x), this.y, this.z, mod(-this.t));\n  }\n  double() {\n    const {\n      x: X1,\n      y: Y1,\n      z: Z1\n    } = this;\n    const {\n      a\n    } = CURVE;\n    const A = mod(X1 * X1);\n    const B = mod(Y1 * Y1);\n    const C = mod(_2n * mod(Z1 * Z1));\n    const D = mod(a * A);\n    const x1y1 = X1 + Y1;\n    const E = mod(mod(x1y1 * x1y1) - A - B);\n    const G = D + B;\n    const F = G - C;\n    const H = D - B;\n    const X3 = mod(E * F);\n    const Y3 = mod(G * H);\n    const T3 = mod(E * H);\n    const Z3 = mod(F * G);\n    return new ExtendedPoint(X3, Y3, Z3, T3);\n  }\n  add(other) {\n    assertExtPoint(other);\n    const {\n      x: X1,\n      y: Y1,\n      z: Z1,\n      t: T1\n    } = this;\n    const {\n      x: X2,\n      y: Y2,\n      z: Z2,\n      t: T2\n    } = other;\n    const A = mod((Y1 - X1) * (Y2 + X2));\n    const B = mod((Y1 + X1) * (Y2 - X2));\n    const F = mod(B - A);\n    if (F === _0n) return this.double();\n    const C = mod(Z1 * _2n * T2);\n    const D = mod(T1 * _2n * Z2);\n    const E = D + C;\n    const G = B + A;\n    const H = D - C;\n    const X3 = mod(E * F);\n    const Y3 = mod(G * H);\n    const T3 = mod(E * H);\n    const Z3 = mod(F * G);\n    return new ExtendedPoint(X3, Y3, Z3, T3);\n  }\n  subtract(other) {\n    return this.add(other.negate());\n  }\n  precomputeWindow(W) {\n    const windows = 1 + 256 / W;\n    const points = [];\n    let p = this;\n    let base = p;\n    for (let window = 0; window < windows; window++) {\n      base = p;\n      points.push(base);\n      for (let i = 1; i < 2 ** (W - 1); i++) {\n        base = base.add(p);\n        points.push(base);\n      }\n      p = base.double();\n    }\n    return points;\n  }\n  wNAF(n, affinePoint) {\n    if (!affinePoint && this.equals(ExtendedPoint.BASE)) affinePoint = Point.BASE;\n    const W = affinePoint && affinePoint._WINDOW_SIZE || 1;\n    if (256 % W) {\n      throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n    }\n    let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n    if (!precomputes) {\n      precomputes = this.precomputeWindow(W);\n      if (affinePoint && W !== 1) {\n        precomputes = ExtendedPoint.normalizeZ(precomputes);\n        pointPrecomputes.set(affinePoint, precomputes);\n      }\n    }\n    let p = ExtendedPoint.ZERO;\n    let f = ExtendedPoint.BASE;\n    const windows = 1 + 256 / W;\n    const windowSize = 2 ** (W - 1);\n    const mask = BigInt(2 ** W - 1);\n    const maxNumber = 2 ** W;\n    const shiftBy = BigInt(W);\n    for (let window = 0; window < windows; window++) {\n      const offset = window * windowSize;\n      let wbits = Number(n & mask);\n      n >>= shiftBy;\n      if (wbits > windowSize) {\n        wbits -= maxNumber;\n        n += _1n;\n      }\n      const offset1 = offset;\n      const offset2 = offset + Math.abs(wbits) - 1;\n      const cond1 = window % 2 !== 0;\n      const cond2 = wbits < 0;\n      if (wbits === 0) {\n        f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n      } else {\n        p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n      }\n    }\n    return ExtendedPoint.normalizeZ([p, f])[0];\n  }\n  multiply(scalar, affinePoint) {\n    return this.wNAF(normalizeScalar(scalar, CURVE.l), affinePoint);\n  }\n  multiplyUnsafe(scalar) {\n    let n = normalizeScalar(scalar, CURVE.l, false);\n    const G = ExtendedPoint.BASE;\n    const P0 = ExtendedPoint.ZERO;\n    if (n === _0n) return P0;\n    if (this.equals(P0) || n === _1n) return this;\n    if (this.equals(G)) return this.wNAF(n);\n    let p = P0;\n    let d = this;\n    while (n > _0n) {\n      if (n & _1n) p = p.add(d);\n      d = d.double();\n      n >>= _1n;\n    }\n    return p;\n  }\n  isSmallOrder() {\n    return this.multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);\n  }\n  isTorsionFree() {\n    let p = this.multiplyUnsafe(CURVE.l / _2n).double();\n    if (CURVE.l % _2n) p = p.add(this);\n    return p.equals(ExtendedPoint.ZERO);\n  }\n  toAffine(invZ) {\n    const {\n      x,\n      y,\n      z\n    } = this;\n    const is0 = this.equals(ExtendedPoint.ZERO);\n    if (invZ == null) invZ = is0 ? _8n : invert(z);\n    const ax = mod(x * invZ);\n    const ay = mod(y * invZ);\n    const zz = mod(z * invZ);\n    if (is0) return Point.ZERO;\n    if (zz !== _1n) throw new Error('invZ was invalid');\n    return new Point(ax, ay);\n  }\n  fromRistrettoBytes() {\n    legacyRist();\n  }\n  toRistrettoBytes() {\n    legacyRist();\n  }\n  fromRistrettoHash() {\n    legacyRist();\n  }\n}\nexports.ExtendedPoint = ExtendedPoint;\nExtendedPoint.BASE = new ExtendedPoint(CURVE.Gx, CURVE.Gy, _1n, mod(CURVE.Gx * CURVE.Gy));\nExtendedPoint.ZERO = new ExtendedPoint(_0n, _1n, _1n, _0n);\nfunction constTimeNegate(condition, item) {\n  const neg = item.negate();\n  return condition ? neg : item;\n}\nfunction assertExtPoint(other) {\n  if (!(other instanceof ExtendedPoint)) throw new TypeError('ExtendedPoint expected');\n}\nfunction assertRstPoint(other) {\n  if (!(other instanceof RistrettoPoint)) throw new TypeError('RistrettoPoint expected');\n}\nfunction legacyRist() {\n  throw new Error('Legacy method: switch to RistrettoPoint');\n}\nclass RistrettoPoint {\n  constructor(ep) {\n    this.ep = ep;\n  }\n  static calcElligatorRistrettoMap(r0) {\n    const {\n      d\n    } = CURVE;\n    const r = mod(SQRT_M1 * r0 * r0);\n    const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);\n    let c = BigInt(-1);\n    const D = mod((c - d * r) * mod(r + d));\n    let {\n      isValid: Ns_D_is_sq,\n      value: s\n    } = uvRatio(Ns, D);\n    let s_ = mod(s * r0);\n    if (!edIsNegative(s_)) s_ = mod(-s_);\n    if (!Ns_D_is_sq) s = s_;\n    if (!Ns_D_is_sq) c = r;\n    const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);\n    const s2 = s * s;\n    const W0 = mod((s + s) * D);\n    const W1 = mod(Nt * SQRT_AD_MINUS_ONE);\n    const W2 = mod(_1n - s2);\n    const W3 = mod(_1n + s2);\n    return new ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n  }\n  static hashToCurve(hex) {\n    hex = ensureBytes(hex, 64);\n    const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n    const R1 = this.calcElligatorRistrettoMap(r1);\n    const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n    const R2 = this.calcElligatorRistrettoMap(r2);\n    return new RistrettoPoint(R1.add(R2));\n  }\n  static fromHex(hex) {\n    hex = ensureBytes(hex, 32);\n    const {\n      a,\n      d\n    } = CURVE;\n    const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n    const s = bytes255ToNumberLE(hex);\n    if (!equalBytes(numberTo32BytesLE(s), hex) || edIsNegative(s)) throw new Error(emsg);\n    const s2 = mod(s * s);\n    const u1 = mod(_1n + a * s2);\n    const u2 = mod(_1n - a * s2);\n    const u1_2 = mod(u1 * u1);\n    const u2_2 = mod(u2 * u2);\n    const v = mod(a * d * u1_2 - u2_2);\n    const {\n      isValid,\n      value: I\n    } = invertSqrt(mod(v * u2_2));\n    const Dx = mod(I * u2);\n    const Dy = mod(I * Dx * v);\n    let x = mod((s + s) * Dx);\n    if (edIsNegative(x)) x = mod(-x);\n    const y = mod(u1 * Dy);\n    const t = mod(x * y);\n    if (!isValid || edIsNegative(t) || y === _0n) throw new Error(emsg);\n    return new RistrettoPoint(new ExtendedPoint(x, y, _1n, t));\n  }\n  toRawBytes() {\n    let {\n      x,\n      y,\n      z,\n      t\n    } = this.ep;\n    const u1 = mod(mod(z + y) * mod(z - y));\n    const u2 = mod(x * y);\n    const u2sq = mod(u2 * u2);\n    const {\n      value: invsqrt\n    } = invertSqrt(mod(u1 * u2sq));\n    const D1 = mod(invsqrt * u1);\n    const D2 = mod(invsqrt * u2);\n    const zInv = mod(D1 * D2 * t);\n    let D;\n    if (edIsNegative(t * zInv)) {\n      let _x = mod(y * SQRT_M1);\n      let _y = mod(x * SQRT_M1);\n      x = _x;\n      y = _y;\n      D = mod(D1 * INVSQRT_A_MINUS_D);\n    } else {\n      D = D2;\n    }\n    if (edIsNegative(x * zInv)) y = mod(-y);\n    let s = mod((z - y) * D);\n    if (edIsNegative(s)) s = mod(-s);\n    return numberTo32BytesLE(s);\n  }\n  toHex() {\n    return bytesToHex(this.toRawBytes());\n  }\n  toString() {\n    return this.toHex();\n  }\n  equals(other) {\n    assertRstPoint(other);\n    const a = this.ep;\n    const b = other.ep;\n    const one = mod(a.x * b.y) === mod(a.y * b.x);\n    const two = mod(a.y * b.y) === mod(a.x * b.x);\n    return one || two;\n  }\n  add(other) {\n    assertRstPoint(other);\n    return new RistrettoPoint(this.ep.add(other.ep));\n  }\n  subtract(other) {\n    assertRstPoint(other);\n    return new RistrettoPoint(this.ep.subtract(other.ep));\n  }\n  multiply(scalar) {\n    return new RistrettoPoint(this.ep.multiply(scalar));\n  }\n  multiplyUnsafe(scalar) {\n    return new RistrettoPoint(this.ep.multiplyUnsafe(scalar));\n  }\n}\nexports.RistrettoPoint = RistrettoPoint;\nRistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);\nRistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);\nconst pointPrecomputes = new WeakMap();\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n  _setWindowSize(windowSize) {\n    this._WINDOW_SIZE = windowSize;\n    pointPrecomputes.delete(this);\n  }\n  static fromHex(hex, strict = true) {\n    const {\n      d,\n      P\n    } = CURVE;\n    hex = ensureBytes(hex, 32);\n    const normed = hex.slice();\n    normed[31] = hex[31] & ~0x80;\n    const y = bytesToNumberLE(normed);\n    if (strict && y >= P) throw new Error('Expected 0 < hex < P');\n    if (!strict && y >= POW_2_256) throw new Error('Expected 0 < hex < 2**256');\n    const y2 = mod(y * y);\n    const u = mod(y2 - _1n);\n    const v = mod(d * y2 + _1n);\n    let {\n      isValid,\n      value: x\n    } = uvRatio(u, v);\n    if (!isValid) throw new Error('Point.fromHex: invalid y coordinate');\n    const isXOdd = (x & _1n) === _1n;\n    const isLastByteOdd = (hex[31] & 0x80) !== 0;\n    if (isLastByteOdd !== isXOdd) {\n      x = mod(-x);\n    }\n    return new Point(x, y);\n  }\n  static async fromPrivateKey(privateKey) {\n    return (await getExtendedPublicKey(privateKey)).point;\n  }\n  toRawBytes() {\n    const bytes = numberTo32BytesLE(this.y);\n    bytes[31] |= this.x & _1n ? 0x80 : 0;\n    return bytes;\n  }\n  toHex() {\n    return bytesToHex(this.toRawBytes());\n  }\n  toX25519() {\n    const {\n      y\n    } = this;\n    const u = mod((_1n + y) * invert(_1n - y));\n    return numberTo32BytesLE(u);\n  }\n  isTorsionFree() {\n    return ExtendedPoint.fromAffine(this).isTorsionFree();\n  }\n  equals(other) {\n    return this.x === other.x && this.y === other.y;\n  }\n  negate() {\n    return new Point(mod(-this.x), this.y);\n  }\n  add(other) {\n    return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();\n  }\n  subtract(other) {\n    return this.add(other.negate());\n  }\n  multiply(scalar) {\n    return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();\n  }\n}\nexports.Point = Point;\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _1n);\nclass Signature {\n  constructor(r, s) {\n    this.r = r;\n    this.s = s;\n    this.assertValidity();\n  }\n  static fromHex(hex) {\n    const bytes = ensureBytes(hex, 64);\n    const r = Point.fromHex(bytes.slice(0, 32), false);\n    const s = bytesToNumberLE(bytes.slice(32, 64));\n    return new Signature(r, s);\n  }\n  assertValidity() {\n    const {\n      r,\n      s\n    } = this;\n    if (!(r instanceof Point)) throw new Error('Expected Point instance');\n    normalizeScalar(s, CURVE.l, false);\n    return this;\n  }\n  toRawBytes() {\n    const u8 = new Uint8Array(64);\n    u8.set(this.r.toRawBytes());\n    u8.set(numberTo32BytesLE(this.s), 32);\n    return u8;\n  }\n  toHex() {\n    return bytesToHex(this.toRawBytes());\n  }\n}\nexports.Signature = Signature;\nfunction concatBytes(...arrays) {\n  if (!arrays.every(a => a instanceof Uint8Array)) throw new Error('Expected Uint8Array list');\n  if (arrays.length === 1) return arrays[0];\n  const length = arrays.reduce((a, arr) => a + arr.length, 0);\n  const result = new Uint8Array(length);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const arr = arrays[i];\n    result.set(arr, pad);\n    pad += arr.length;\n  }\n  return result;\n}\nconst hexes = Array.from({\n  length: 256\n}, (v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(uint8a) {\n  if (!(uint8a instanceof Uint8Array)) throw new Error('Uint8Array expected');\n  let hex = '';\n  for (let i = 0; i < uint8a.length; i++) {\n    hex += hexes[uint8a[i]];\n  }\n  return hex;\n}\nfunction hexToBytes(hex) {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n  }\n  if (hex.length % 2) throw new Error('hexToBytes: received invalid unpadded hex');\n  const array = new Uint8Array(hex.length / 2);\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\nfunction numberTo32BytesBE(num) {\n  const length = 32;\n  const hex = num.toString(16).padStart(length * 2, '0');\n  return hexToBytes(hex);\n}\nfunction numberTo32BytesLE(num) {\n  return numberTo32BytesBE(num).reverse();\n}\nfunction edIsNegative(num) {\n  return (mod(num) & _1n) === _1n;\n}\nfunction bytesToNumberLE(uint8a) {\n  if (!(uint8a instanceof Uint8Array)) throw new Error('Expected Uint8Array');\n  return BigInt('0x' + bytesToHex(Uint8Array.from(uint8a).reverse()));\n}\nconst MAX_255B = BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\nfunction bytes255ToNumberLE(bytes) {\n  return mod(bytesToNumberLE(bytes) & MAX_255B);\n}\nfunction mod(a, b = CURVE.P) {\n  const res = a % b;\n  return res >= _0n ? res : b + res;\n}\nfunction invert(number, modulo = CURVE.P) {\n  if (number === _0n || modulo <= _0n) {\n    throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n  }\n  let a = mod(number, modulo);\n  let b = modulo;\n  let x = _0n,\n    y = _1n,\n    u = _1n,\n    v = _0n;\n  while (a !== _0n) {\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n  const gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\nfunction invertBatch(nums, p = CURVE.P) {\n  const tmp = new Array(nums.length);\n  const lastMultiplied = nums.reduce((acc, num, i) => {\n    if (num === _0n) return acc;\n    tmp[i] = acc;\n    return mod(acc * num, p);\n  }, _1n);\n  const inverted = invert(lastMultiplied, p);\n  nums.reduceRight((acc, num, i) => {\n    if (num === _0n) return acc;\n    tmp[i] = mod(acc * tmp[i], p);\n    return mod(acc * num, p);\n  }, inverted);\n  return tmp;\n}\nfunction pow2(x, power) {\n  const {\n    P\n  } = CURVE;\n  let res = x;\n  while (power-- > _0n) {\n    res *= res;\n    res %= P;\n  }\n  return res;\n}\nfunction pow_2_252_3(x) {\n  const {\n    P\n  } = CURVE;\n  const _5n = BigInt(5);\n  const _10n = BigInt(10);\n  const _20n = BigInt(20);\n  const _40n = BigInt(40);\n  const _80n = BigInt(80);\n  const x2 = x * x % P;\n  const b2 = x2 * x % P;\n  const b4 = pow2(b2, _2n) * b2 % P;\n  const b5 = pow2(b4, _1n) * x % P;\n  const b10 = pow2(b5, _5n) * b5 % P;\n  const b20 = pow2(b10, _10n) * b10 % P;\n  const b40 = pow2(b20, _20n) * b20 % P;\n  const b80 = pow2(b40, _40n) * b40 % P;\n  const b160 = pow2(b80, _80n) * b80 % P;\n  const b240 = pow2(b160, _80n) * b80 % P;\n  const b250 = pow2(b240, _10n) * b10 % P;\n  const pow_p_5_8 = pow2(b250, _2n) * x % P;\n  return {\n    pow_p_5_8,\n    b2\n  };\n}\nfunction uvRatio(u, v) {\n  const v3 = mod(v * v * v);\n  const v7 = mod(v3 * v3 * v);\n  const pow = pow_2_252_3(u * v7).pow_p_5_8;\n  let x = mod(u * v3 * pow);\n  const vx2 = mod(v * x * x);\n  const root1 = x;\n  const root2 = mod(x * SQRT_M1);\n  const useRoot1 = vx2 === u;\n  const useRoot2 = vx2 === mod(-u);\n  const noRoot = vx2 === mod(-u * SQRT_M1);\n  if (useRoot1) x = root1;\n  if (useRoot2 || noRoot) x = root2;\n  if (edIsNegative(x)) x = mod(-x);\n  return {\n    isValid: useRoot1 || useRoot2,\n    value: x\n  };\n}\nfunction invertSqrt(number) {\n  return uvRatio(_1n, number);\n}\nfunction modlLE(hash) {\n  return mod(bytesToNumberLE(hash), CURVE.l);\n}\nfunction equalBytes(b1, b2) {\n  if (b1.length !== b2.length) {\n    return false;\n  }\n  for (let i = 0; i < b1.length; i++) {\n    if (b1[i] !== b2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction ensureBytes(hex, expectedLength) {\n  const bytes = hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n  if (typeof expectedLength === 'number' && bytes.length !== expectedLength) throw new Error(`Expected ${expectedLength} bytes`);\n  return bytes;\n}\nfunction normalizeScalar(num, max, strict = true) {\n  if (!max) throw new TypeError('Specify max value');\n  if (typeof num === 'number' && Number.isSafeInteger(num)) num = BigInt(num);\n  if (typeof num === 'bigint' && num < max) {\n    if (strict) {\n      if (_0n < num) return num;\n    } else {\n      if (_0n <= num) return num;\n    }\n  }\n  throw new TypeError('Expected valid scalar: 0 < scalar < max');\n}\nfunction adjustBytes25519(bytes) {\n  bytes[0] &= 248;\n  bytes[31] &= 127;\n  bytes[31] |= 64;\n  return bytes;\n}\nfunction decodeScalar25519(n) {\n  return bytesToNumberLE(adjustBytes25519(ensureBytes(n, 32)));\n}\nfunction checkPrivateKey(key) {\n  key = typeof key === 'bigint' || typeof key === 'number' ? numberTo32BytesBE(normalizeScalar(key, POW_2_256)) : ensureBytes(key);\n  if (key.length !== 32) throw new Error(`Expected 32 bytes`);\n  return key;\n}\nfunction getKeyFromHash(hashed) {\n  const head = adjustBytes25519(hashed.slice(0, 32));\n  const prefix = hashed.slice(32, 64);\n  const scalar = modlLE(head);\n  const point = Point.BASE.multiply(scalar);\n  const pointBytes = point.toRawBytes();\n  return {\n    head,\n    prefix,\n    scalar,\n    point,\n    pointBytes\n  };\n}\nlet _sha512Sync;\nfunction sha512s(...m) {\n  if (typeof _sha512Sync !== 'function') throw new Error('utils.sha512Sync must be set to use sync methods');\n  return _sha512Sync(...m);\n}\nasync function getExtendedPublicKey(key) {\n  return getKeyFromHash(await exports.utils.sha512(checkPrivateKey(key)));\n}\nfunction getExtendedPublicKeySync(key) {\n  return getKeyFromHash(sha512s(checkPrivateKey(key)));\n}\nasync function getPublicKey(privateKey) {\n  return (await getExtendedPublicKey(privateKey)).pointBytes;\n}\nexports.getPublicKey = getPublicKey;\nfunction getPublicKeySync(privateKey) {\n  return getExtendedPublicKeySync(privateKey).pointBytes;\n}\nasync function sign(message, privateKey) {\n  message = ensureBytes(message);\n  const {\n    prefix,\n    scalar,\n    pointBytes\n  } = await getExtendedPublicKey(privateKey);\n  const r = modlLE(await exports.utils.sha512(prefix, message));\n  const R = Point.BASE.multiply(r);\n  const k = modlLE(await exports.utils.sha512(R.toRawBytes(), pointBytes, message));\n  const s = mod(r + k * scalar, CURVE.l);\n  return new Signature(R, s).toRawBytes();\n}\nexports.sign = sign;\nfunction signSync(message, privateKey) {\n  message = ensureBytes(message);\n  const {\n    prefix,\n    scalar,\n    pointBytes\n  } = getExtendedPublicKeySync(privateKey);\n  const r = modlLE(sha512s(prefix, message));\n  const R = Point.BASE.multiply(r);\n  const k = modlLE(sha512s(R.toRawBytes(), pointBytes, message));\n  const s = mod(r + k * scalar, CURVE.l);\n  return new Signature(R, s).toRawBytes();\n}\nfunction prepareVerification(sig, message, publicKey) {\n  message = ensureBytes(message);\n  if (!(publicKey instanceof Point)) publicKey = Point.fromHex(publicKey, false);\n  const {\n    r,\n    s\n  } = sig instanceof Signature ? sig.assertValidity() : Signature.fromHex(sig);\n  const SB = ExtendedPoint.BASE.multiplyUnsafe(s);\n  return {\n    r,\n    s,\n    SB,\n    pub: publicKey,\n    msg: message\n  };\n}\nfunction finishVerification(publicKey, r, SB, hashed) {\n  const k = modlLE(hashed);\n  const kA = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(k);\n  const RkA = ExtendedPoint.fromAffine(r).add(kA);\n  return RkA.subtract(SB).multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);\n}\nasync function verify(sig, message, publicKey) {\n  const {\n    r,\n    SB,\n    msg,\n    pub\n  } = prepareVerification(sig, message, publicKey);\n  const hashed = await exports.utils.sha512(r.toRawBytes(), pub.toRawBytes(), msg);\n  return finishVerification(pub, r, SB, hashed);\n}\nexports.verify = verify;\nfunction verifySync(sig, message, publicKey) {\n  const {\n    r,\n    SB,\n    msg,\n    pub\n  } = prepareVerification(sig, message, publicKey);\n  const hashed = sha512s(r.toRawBytes(), pub.toRawBytes(), msg);\n  return finishVerification(pub, r, SB, hashed);\n}\nexports.sync = {\n  getExtendedPublicKey: getExtendedPublicKeySync,\n  getPublicKey: getPublicKeySync,\n  sign: signSync,\n  verify: verifySync\n};\nasync function getSharedSecret(privateKey, publicKey) {\n  const {\n    head\n  } = await getExtendedPublicKey(privateKey);\n  const u = Point.fromHex(publicKey).toX25519();\n  return exports.curve25519.scalarMult(head, u);\n}\nexports.getSharedSecret = getSharedSecret;\nPoint.BASE._setWindowSize(8);\nfunction cswap(swap, x_2, x_3) {\n  const dummy = mod(swap * (x_2 - x_3));\n  x_2 = mod(x_2 - dummy);\n  x_3 = mod(x_3 + dummy);\n  return [x_2, x_3];\n}\nfunction montgomeryLadder(pointU, scalar) {\n  const {\n    P\n  } = CURVE;\n  const u = normalizeScalar(pointU, P);\n  const k = normalizeScalar(scalar, P);\n  const a24 = BigInt(121665);\n  const x_1 = u;\n  let x_2 = _1n;\n  let z_2 = _0n;\n  let x_3 = u;\n  let z_3 = _1n;\n  let swap = _0n;\n  let sw;\n  for (let t = BigInt(255 - 1); t >= _0n; t--) {\n    const k_t = k >> t & _1n;\n    swap ^= k_t;\n    sw = cswap(swap, x_2, x_3);\n    x_2 = sw[0];\n    x_3 = sw[1];\n    sw = cswap(swap, z_2, z_3);\n    z_2 = sw[0];\n    z_3 = sw[1];\n    swap = k_t;\n    const A = x_2 + z_2;\n    const AA = mod(A * A);\n    const B = x_2 - z_2;\n    const BB = mod(B * B);\n    const E = AA - BB;\n    const C = x_3 + z_3;\n    const D = x_3 - z_3;\n    const DA = mod(D * A);\n    const CB = mod(C * B);\n    const dacb = DA + CB;\n    const da_cb = DA - CB;\n    x_3 = mod(dacb * dacb);\n    z_3 = mod(x_1 * mod(da_cb * da_cb));\n    x_2 = mod(AA * BB);\n    z_2 = mod(E * (AA + mod(a24 * E)));\n  }\n  sw = cswap(swap, x_2, x_3);\n  x_2 = sw[0];\n  x_3 = sw[1];\n  sw = cswap(swap, z_2, z_3);\n  z_2 = sw[0];\n  z_3 = sw[1];\n  const {\n    pow_p_5_8,\n    b2\n  } = pow_2_252_3(z_2);\n  const xp2 = mod(pow2(pow_p_5_8, BigInt(3)) * b2);\n  return mod(x_2 * xp2);\n}\nfunction encodeUCoordinate(u) {\n  return numberTo32BytesLE(mod(u, CURVE.P));\n}\nfunction decodeUCoordinate(uEnc) {\n  const u = ensureBytes(uEnc, 32);\n  u[31] &= 127;\n  return bytesToNumberLE(u);\n}\nexports.curve25519 = {\n  BASE_POINT_U: '0900000000000000000000000000000000000000000000000000000000000000',\n  scalarMult(privateKey, publicKey) {\n    const u = decodeUCoordinate(publicKey);\n    const p = decodeScalar25519(privateKey);\n    const pu = montgomeryLadder(u, p);\n    if (pu === _0n) throw new Error('Invalid private or public key received');\n    return encodeUCoordinate(pu);\n  },\n  scalarMultBase(privateKey) {\n    return exports.curve25519.scalarMult(privateKey, exports.curve25519.BASE_POINT_U);\n  }\n};\nconst crypto = {\n  node: nodeCrypto,\n  web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined\n};\nexports.utils = {\n  bytesToHex,\n  hexToBytes,\n  concatBytes,\n  getExtendedPublicKey,\n  mod,\n  invert,\n  TORSION_SUBGROUP: ['0100000000000000000000000000000000000000000000000000000000000000', 'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a', '0000000000000000000000000000000000000000000000000000000000000080', '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05', 'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f', '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85', '0000000000000000000000000000000000000000000000000000000000000000', 'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa'],\n  hashToPrivateScalar: hash => {\n    hash = ensureBytes(hash);\n    if (hash.length < 40 || hash.length > 1024) throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');\n    return mod(bytesToNumberLE(hash), CURVE.l - _1n) + _1n;\n  },\n  randomBytes: (bytesLength = 32) => {\n    if (crypto.web) {\n      return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n    } else if (crypto.node) {\n      const {\n        randomBytes\n      } = crypto.node;\n      return new Uint8Array(randomBytes(bytesLength).buffer);\n    } else {\n      throw new Error(\"The environment doesn't have randomBytes function\");\n    }\n  },\n  randomPrivateKey: () => {\n    return exports.utils.randomBytes(32);\n  },\n  sha512: async (...messages) => {\n    const message = concatBytes(...messages);\n    if (crypto.web) {\n      const buffer = await crypto.web.subtle.digest('SHA-512', message.buffer);\n      return new Uint8Array(buffer);\n    } else if (crypto.node) {\n      return Uint8Array.from(crypto.node.createHash('sha512').update(message).digest());\n    } else {\n      throw new Error(\"The environment doesn't have sha512 function\");\n    }\n  },\n  precompute(windowSize = 8, point = Point.BASE) {\n    const cached = point.equals(Point.BASE) ? point : new Point(point.x, point.y);\n    cached._setWindowSize(windowSize);\n    cached.multiply(_2n);\n    return cached;\n  },\n  sha512Sync: undefined\n};\nObject.defineProperties(exports.utils, {\n  sha512Sync: {\n    configurable: false,\n    get() {\n      return _sha512Sync;\n    },\n    set(val) {\n      if (!_sha512Sync) _sha512Sync = val;\n    }\n  }\n});","map":{"version":3,"names":["require","Object","defineProperty","exports","value","utils","curve25519","getSharedSecret","sync","verify","sign","getPublicKey","Signature","Point","RistrettoPoint","ExtendedPoint","CURVE","nodeCrypto","_0n","BigInt","_1n","_2n","_8n","CU_O","freeze","a","d","P","l","n","h","Gx","Gy","POW_2_256","SQRT_M1","SQRT_D","SQRT_AD_MINUS_ONE","INVSQRT_A_MINUS_D","ONE_MINUS_D_SQ","D_MINUS_ONE_SQ","constructor","x","y","z","t","fromAffine","p","TypeError","equals","ZERO","mod","toAffineBatch","points","toInv","invertBatch","map","i","toAffine","normalizeZ","other","assertExtPoint","X1","Y1","Z1","X2","Y2","Z2","X1Z2","X2Z1","Y1Z2","Y2Z1","negate","double","A","B","C","D","x1y1","E","G","F","H","X3","Y3","T3","Z3","add","T1","T2","subtract","precomputeWindow","W","windows","base","window","push","wNAF","affinePoint","BASE","_WINDOW_SIZE","Error","precomputes","pointPrecomputes","get","set","f","windowSize","mask","maxNumber","shiftBy","offset","wbits","Number","offset1","offset2","Math","abs","cond1","cond2","constTimeNegate","multiply","scalar","normalizeScalar","multiplyUnsafe","P0","isSmallOrder","isTorsionFree","invZ","is0","invert","ax","ay","zz","fromRistrettoBytes","legacyRist","toRistrettoBytes","fromRistrettoHash","condition","item","neg","assertRstPoint","ep","calcElligatorRistrettoMap","r0","r","Ns","c","isValid","Ns_D_is_sq","s","uvRatio","s_","edIsNegative","Nt","s2","W0","W1","W2","W3","hashToCurve","hex","ensureBytes","r1","bytes255ToNumberLE","slice","R1","r2","R2","fromHex","emsg","equalBytes","numberTo32BytesLE","u1","u2","u1_2","u2_2","v","I","invertSqrt","Dx","Dy","toRawBytes","u2sq","invsqrt","D1","D2","zInv","_x","_y","toHex","bytesToHex","toString","b","one","two","WeakMap","_setWindowSize","delete","strict","normed","bytesToNumberLE","y2","u","isXOdd","isLastByteOdd","fromPrivateKey","privateKey","getExtendedPublicKey","point","bytes","toX25519","assertValidity","u8","Uint8Array","concatBytes","arrays","every","length","reduce","arr","result","pad","hexes","Array","from","padStart","uint8a","hexToBytes","array","j","hexByte","byte","parseInt","isNaN","numberTo32BytesBE","num","reverse","MAX_255B","res","number","modulo","q","m","gcd","nums","tmp","lastMultiplied","acc","inverted","reduceRight","pow2","power","pow_2_252_3","_5n","_10n","_20n","_40n","_80n","x2","b2","b4","b5","b10","b20","b40","b80","b160","b240","b250","pow_p_5_8","v3","v7","pow","vx2","root1","root2","useRoot1","useRoot2","noRoot","modlLE","hash","b1","expectedLength","max","isSafeInteger","adjustBytes25519","decodeScalar25519","checkPrivateKey","key","getKeyFromHash","hashed","head","prefix","pointBytes","_sha512Sync","sha512s","sha512","getExtendedPublicKeySync","getPublicKeySync","message","R","k","signSync","prepareVerification","sig","publicKey","SB","pub","msg","finishVerification","kA","RkA","verifySync","scalarMult","cswap","swap","x_2","x_3","dummy","montgomeryLadder","pointU","a24","x_1","z_2","z_3","sw","k_t","AA","BB","DA","CB","dacb","da_cb","xp2","encodeUCoordinate","decodeUCoordinate","uEnc","BASE_POINT_U","pu","scalarMultBase","crypto","node","web","self","undefined","TORSION_SUBGROUP","hashToPrivateScalar","randomBytes","bytesLength","getRandomValues","buffer","randomPrivateKey","messages","subtle","digest","createHash","update","precompute","cached","sha512Sync","defineProperties","configurable","val"],"sources":["E:/Amanda-project/vue2-project/project-vue2/node_modules/@noble/ed25519/lib/index.js"],"sourcesContent":["\"use strict\";\n/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.utils = exports.curve25519 = exports.getSharedSecret = exports.sync = exports.verify = exports.sign = exports.getPublicKey = exports.Signature = exports.Point = exports.RistrettoPoint = exports.ExtendedPoint = exports.CURVE = void 0;\nconst nodeCrypto = require(\"crypto\");\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _8n = BigInt(8);\nconst CU_O = BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989');\nconst CURVE = Object.freeze({\n    a: BigInt(-1),\n    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),\n    P: BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819949'),\n    l: CU_O,\n    n: CU_O,\n    h: BigInt(8),\n    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),\n    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),\n});\nexports.CURVE = CURVE;\nconst POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');\nconst SQRT_M1 = BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');\nconst SQRT_D = BigInt('6853475219497561581579357271197624642482790079785650197046958215289687604742');\nconst SQRT_AD_MINUS_ONE = BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');\nconst INVSQRT_A_MINUS_D = BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');\nconst ONE_MINUS_D_SQ = BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');\nconst D_MINUS_ONE_SQ = BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');\nclass ExtendedPoint {\n    constructor(x, y, z, t) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.t = t;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError('ExtendedPoint#fromAffine: expected Point');\n        }\n        if (p.equals(Point.ZERO))\n            return ExtendedPoint.ZERO;\n        return new ExtendedPoint(p.x, p.y, _1n, mod(p.x * p.y));\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p) => p.z));\n        return points.map((p, i) => p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return this.toAffineBatch(points).map(this.fromAffine);\n    }\n    equals(other) {\n        assertExtPoint(other);\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        const X1Z2 = mod(X1 * Z2);\n        const X2Z1 = mod(X2 * Z1);\n        const Y1Z2 = mod(Y1 * Z2);\n        const Y2Z1 = mod(Y2 * Z1);\n        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n    negate() {\n        return new ExtendedPoint(mod(-this.x), this.y, this.z, mod(-this.t));\n    }\n    double() {\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { a } = CURVE;\n        const A = mod(X1 * X1);\n        const B = mod(Y1 * Y1);\n        const C = mod(_2n * mod(Z1 * Z1));\n        const D = mod(a * A);\n        const x1y1 = X1 + Y1;\n        const E = mod(mod(x1y1 * x1y1) - A - B);\n        const G = D + B;\n        const F = G - C;\n        const H = D - B;\n        const X3 = mod(E * F);\n        const Y3 = mod(G * H);\n        const T3 = mod(E * H);\n        const Z3 = mod(F * G);\n        return new ExtendedPoint(X3, Y3, Z3, T3);\n    }\n    add(other) {\n        assertExtPoint(other);\n        const { x: X1, y: Y1, z: Z1, t: T1 } = this;\n        const { x: X2, y: Y2, z: Z2, t: T2 } = other;\n        const A = mod((Y1 - X1) * (Y2 + X2));\n        const B = mod((Y1 + X1) * (Y2 - X2));\n        const F = mod(B - A);\n        if (F === _0n)\n            return this.double();\n        const C = mod(Z1 * _2n * T2);\n        const D = mod(T1 * _2n * Z2);\n        const E = D + C;\n        const G = B + A;\n        const H = D - C;\n        const X3 = mod(E * F);\n        const Y3 = mod(G * H);\n        const T3 = mod(E * H);\n        const Z3 = mod(F * G);\n        return new ExtendedPoint(X3, Y3, Z3, T3);\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    precomputeWindow(W) {\n        const windows = 1 + 256 / W;\n        const points = [];\n        let p = this;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            for (let i = 1; i < 2 ** (W - 1); i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(ExtendedPoint.BASE))\n            affinePoint = Point.BASE;\n        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;\n        if (256 % W) {\n            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = ExtendedPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = ExtendedPoint.ZERO;\n        let f = ExtendedPoint.BASE;\n        const windows = 1 + 256 / W;\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for (let window = 0; window < windows; window++) {\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += _1n;\n            }\n            const offset1 = offset;\n            const offset2 = offset + Math.abs(wbits) - 1;\n            const cond1 = window % 2 !== 0;\n            const cond2 = wbits < 0;\n            if (wbits === 0) {\n                f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n            }\n            else {\n                p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n            }\n        }\n        return ExtendedPoint.normalizeZ([p, f])[0];\n    }\n    multiply(scalar, affinePoint) {\n        return this.wNAF(normalizeScalar(scalar, CURVE.l), affinePoint);\n    }\n    multiplyUnsafe(scalar) {\n        let n = normalizeScalar(scalar, CURVE.l, false);\n        const G = ExtendedPoint.BASE;\n        const P0 = ExtendedPoint.ZERO;\n        if (n === _0n)\n            return P0;\n        if (this.equals(P0) || n === _1n)\n            return this;\n        if (this.equals(G))\n            return this.wNAF(n);\n        let p = P0;\n        let d = this;\n        while (n > _0n) {\n            if (n & _1n)\n                p = p.add(d);\n            d = d.double();\n            n >>= _1n;\n        }\n        return p;\n    }\n    isSmallOrder() {\n        return this.multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);\n    }\n    isTorsionFree() {\n        let p = this.multiplyUnsafe(CURVE.l / _2n).double();\n        if (CURVE.l % _2n)\n            p = p.add(this);\n        return p.equals(ExtendedPoint.ZERO);\n    }\n    toAffine(invZ) {\n        const { x, y, z } = this;\n        const is0 = this.equals(ExtendedPoint.ZERO);\n        if (invZ == null)\n            invZ = is0 ? _8n : invert(z);\n        const ax = mod(x * invZ);\n        const ay = mod(y * invZ);\n        const zz = mod(z * invZ);\n        if (is0)\n            return Point.ZERO;\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return new Point(ax, ay);\n    }\n    fromRistrettoBytes() {\n        legacyRist();\n    }\n    toRistrettoBytes() {\n        legacyRist();\n    }\n    fromRistrettoHash() {\n        legacyRist();\n    }\n}\nexports.ExtendedPoint = ExtendedPoint;\nExtendedPoint.BASE = new ExtendedPoint(CURVE.Gx, CURVE.Gy, _1n, mod(CURVE.Gx * CURVE.Gy));\nExtendedPoint.ZERO = new ExtendedPoint(_0n, _1n, _1n, _0n);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nfunction assertExtPoint(other) {\n    if (!(other instanceof ExtendedPoint))\n        throw new TypeError('ExtendedPoint expected');\n}\nfunction assertRstPoint(other) {\n    if (!(other instanceof RistrettoPoint))\n        throw new TypeError('RistrettoPoint expected');\n}\nfunction legacyRist() {\n    throw new Error('Legacy method: switch to RistrettoPoint');\n}\nclass RistrettoPoint {\n    constructor(ep) {\n        this.ep = ep;\n    }\n    static calcElligatorRistrettoMap(r0) {\n        const { d } = CURVE;\n        const r = mod(SQRT_M1 * r0 * r0);\n        const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);\n        let c = BigInt(-1);\n        const D = mod((c - d * r) * mod(r + d));\n        let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);\n        let s_ = mod(s * r0);\n        if (!edIsNegative(s_))\n            s_ = mod(-s_);\n        if (!Ns_D_is_sq)\n            s = s_;\n        if (!Ns_D_is_sq)\n            c = r;\n        const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);\n        const s2 = s * s;\n        const W0 = mod((s + s) * D);\n        const W1 = mod(Nt * SQRT_AD_MINUS_ONE);\n        const W2 = mod(_1n - s2);\n        const W3 = mod(_1n + s2);\n        return new ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n    }\n    static hashToCurve(hex) {\n        hex = ensureBytes(hex, 64);\n        const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n        const R1 = this.calcElligatorRistrettoMap(r1);\n        const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n        const R2 = this.calcElligatorRistrettoMap(r2);\n        return new RistrettoPoint(R1.add(R2));\n    }\n    static fromHex(hex) {\n        hex = ensureBytes(hex, 32);\n        const { a, d } = CURVE;\n        const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n        const s = bytes255ToNumberLE(hex);\n        if (!equalBytes(numberTo32BytesLE(s), hex) || edIsNegative(s))\n            throw new Error(emsg);\n        const s2 = mod(s * s);\n        const u1 = mod(_1n + a * s2);\n        const u2 = mod(_1n - a * s2);\n        const u1_2 = mod(u1 * u1);\n        const u2_2 = mod(u2 * u2);\n        const v = mod(a * d * u1_2 - u2_2);\n        const { isValid, value: I } = invertSqrt(mod(v * u2_2));\n        const Dx = mod(I * u2);\n        const Dy = mod(I * Dx * v);\n        let x = mod((s + s) * Dx);\n        if (edIsNegative(x))\n            x = mod(-x);\n        const y = mod(u1 * Dy);\n        const t = mod(x * y);\n        if (!isValid || edIsNegative(t) || y === _0n)\n            throw new Error(emsg);\n        return new RistrettoPoint(new ExtendedPoint(x, y, _1n, t));\n    }\n    toRawBytes() {\n        let { x, y, z, t } = this.ep;\n        const u1 = mod(mod(z + y) * mod(z - y));\n        const u2 = mod(x * y);\n        const u2sq = mod(u2 * u2);\n        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq));\n        const D1 = mod(invsqrt * u1);\n        const D2 = mod(invsqrt * u2);\n        const zInv = mod(D1 * D2 * t);\n        let D;\n        if (edIsNegative(t * zInv)) {\n            let _x = mod(y * SQRT_M1);\n            let _y = mod(x * SQRT_M1);\n            x = _x;\n            y = _y;\n            D = mod(D1 * INVSQRT_A_MINUS_D);\n        }\n        else {\n            D = D2;\n        }\n        if (edIsNegative(x * zInv))\n            y = mod(-y);\n        let s = mod((z - y) * D);\n        if (edIsNegative(s))\n            s = mod(-s);\n        return numberTo32BytesLE(s);\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n    toString() {\n        return this.toHex();\n    }\n    equals(other) {\n        assertRstPoint(other);\n        const a = this.ep;\n        const b = other.ep;\n        const one = mod(a.x * b.y) === mod(a.y * b.x);\n        const two = mod(a.y * b.y) === mod(a.x * b.x);\n        return one || two;\n    }\n    add(other) {\n        assertRstPoint(other);\n        return new RistrettoPoint(this.ep.add(other.ep));\n    }\n    subtract(other) {\n        assertRstPoint(other);\n        return new RistrettoPoint(this.ep.subtract(other.ep));\n    }\n    multiply(scalar) {\n        return new RistrettoPoint(this.ep.multiply(scalar));\n    }\n    multiplyUnsafe(scalar) {\n        return new RistrettoPoint(this.ep.multiplyUnsafe(scalar));\n    }\n}\nexports.RistrettoPoint = RistrettoPoint;\nRistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);\nRistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);\nconst pointPrecomputes = new WeakMap();\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    static fromHex(hex, strict = true) {\n        const { d, P } = CURVE;\n        hex = ensureBytes(hex, 32);\n        const normed = hex.slice();\n        normed[31] = hex[31] & ~0x80;\n        const y = bytesToNumberLE(normed);\n        if (strict && y >= P)\n            throw new Error('Expected 0 < hex < P');\n        if (!strict && y >= POW_2_256)\n            throw new Error('Expected 0 < hex < 2**256');\n        const y2 = mod(y * y);\n        const u = mod(y2 - _1n);\n        const v = mod(d * y2 + _1n);\n        let { isValid, value: x } = uvRatio(u, v);\n        if (!isValid)\n            throw new Error('Point.fromHex: invalid y coordinate');\n        const isXOdd = (x & _1n) === _1n;\n        const isLastByteOdd = (hex[31] & 0x80) !== 0;\n        if (isLastByteOdd !== isXOdd) {\n            x = mod(-x);\n        }\n        return new Point(x, y);\n    }\n    static async fromPrivateKey(privateKey) {\n        return (await getExtendedPublicKey(privateKey)).point;\n    }\n    toRawBytes() {\n        const bytes = numberTo32BytesLE(this.y);\n        bytes[31] |= this.x & _1n ? 0x80 : 0;\n        return bytes;\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n    toX25519() {\n        const { y } = this;\n        const u = mod((_1n + y) * invert(_1n - y));\n        return numberTo32BytesLE(u);\n    }\n    isTorsionFree() {\n        return ExtendedPoint.fromAffine(this).isTorsionFree();\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(mod(-this.x), this.y);\n    }\n    add(other) {\n        return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n}\nexports.Point = Point;\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _1n);\nclass Signature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex, 64);\n        const r = Point.fromHex(bytes.slice(0, 32), false);\n        const s = bytesToNumberLE(bytes.slice(32, 64));\n        return new Signature(r, s);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!(r instanceof Point))\n            throw new Error('Expected Point instance');\n        normalizeScalar(s, CURVE.l, false);\n        return this;\n    }\n    toRawBytes() {\n        const u8 = new Uint8Array(64);\n        u8.set(this.r.toRawBytes());\n        u8.set(numberTo32BytesLE(this.s), 32);\n        return u8;\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n}\nexports.Signature = Signature;\nfunction concatBytes(...arrays) {\n    if (!arrays.every((a) => a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array list');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Uint8Array expected');\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex');\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nfunction numberTo32BytesBE(num) {\n    const length = 32;\n    const hex = num.toString(16).padStart(length * 2, '0');\n    return hexToBytes(hex);\n}\nfunction numberTo32BytesLE(num) {\n    return numberTo32BytesBE(num).reverse();\n}\nfunction edIsNegative(num) {\n    return (mod(num) & _1n) === _1n;\n}\nfunction bytesToNumberLE(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    return BigInt('0x' + bytesToHex(Uint8Array.from(uint8a).reverse()));\n}\nconst MAX_255B = BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\nfunction bytes255ToNumberLE(bytes) {\n    return mod(bytesToNumberLE(bytes) & MAX_255B);\n}\nfunction mod(a, b = CURVE.P) {\n    const res = a % b;\n    return res >= _0n ? res : b + res;\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, p = CURVE.P) {\n    const tmp = new Array(nums.length);\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        tmp[i] = acc;\n        return mod(acc * num, p);\n    }, _1n);\n    const inverted = invert(lastMultiplied, p);\n    nums.reduceRight((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        tmp[i] = mod(acc * tmp[i], p);\n        return mod(acc * num, p);\n    }, inverted);\n    return tmp;\n}\nfunction pow2(x, power) {\n    const { P } = CURVE;\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= P;\n    }\n    return res;\n}\nfunction pow_2_252_3(x) {\n    const { P } = CURVE;\n    const _5n = BigInt(5);\n    const _10n = BigInt(10);\n    const _20n = BigInt(20);\n    const _40n = BigInt(40);\n    const _80n = BigInt(80);\n    const x2 = (x * x) % P;\n    const b2 = (x2 * x) % P;\n    const b4 = (pow2(b2, _2n) * b2) % P;\n    const b5 = (pow2(b4, _1n) * x) % P;\n    const b10 = (pow2(b5, _5n) * b5) % P;\n    const b20 = (pow2(b10, _10n) * b10) % P;\n    const b40 = (pow2(b20, _20n) * b20) % P;\n    const b80 = (pow2(b40, _40n) * b40) % P;\n    const b160 = (pow2(b80, _80n) * b80) % P;\n    const b240 = (pow2(b160, _80n) * b80) % P;\n    const b250 = (pow2(b240, _10n) * b10) % P;\n    const pow_p_5_8 = (pow2(b250, _2n) * x) % P;\n    return { pow_p_5_8, b2 };\n}\nfunction uvRatio(u, v) {\n    const v3 = mod(v * v * v);\n    const v7 = mod(v3 * v3 * v);\n    const pow = pow_2_252_3(u * v7).pow_p_5_8;\n    let x = mod(u * v3 * pow);\n    const vx2 = mod(v * x * x);\n    const root1 = x;\n    const root2 = mod(x * SQRT_M1);\n    const useRoot1 = vx2 === u;\n    const useRoot2 = vx2 === mod(-u);\n    const noRoot = vx2 === mod(-u * SQRT_M1);\n    if (useRoot1)\n        x = root1;\n    if (useRoot2 || noRoot)\n        x = root2;\n    if (edIsNegative(x))\n        x = mod(-x);\n    return { isValid: useRoot1 || useRoot2, value: x };\n}\nfunction invertSqrt(number) {\n    return uvRatio(_1n, number);\n}\nfunction modlLE(hash) {\n    return mod(bytesToNumberLE(hash), CURVE.l);\n}\nfunction equalBytes(b1, b2) {\n    if (b1.length !== b2.length) {\n        return false;\n    }\n    for (let i = 0; i < b1.length; i++) {\n        if (b1[i] !== b2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction ensureBytes(hex, expectedLength) {\n    const bytes = hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n    if (typeof expectedLength === 'number' && bytes.length !== expectedLength)\n        throw new Error(`Expected ${expectedLength} bytes`);\n    return bytes;\n}\nfunction normalizeScalar(num, max, strict = true) {\n    if (!max)\n        throw new TypeError('Specify max value');\n    if (typeof num === 'number' && Number.isSafeInteger(num))\n        num = BigInt(num);\n    if (typeof num === 'bigint' && num < max) {\n        if (strict) {\n            if (_0n < num)\n                return num;\n        }\n        else {\n            if (_0n <= num)\n                return num;\n        }\n    }\n    throw new TypeError('Expected valid scalar: 0 < scalar < max');\n}\nfunction adjustBytes25519(bytes) {\n    bytes[0] &= 248;\n    bytes[31] &= 127;\n    bytes[31] |= 64;\n    return bytes;\n}\nfunction decodeScalar25519(n) {\n    return bytesToNumberLE(adjustBytes25519(ensureBytes(n, 32)));\n}\nfunction checkPrivateKey(key) {\n    key =\n        typeof key === 'bigint' || typeof key === 'number'\n            ? numberTo32BytesBE(normalizeScalar(key, POW_2_256))\n            : ensureBytes(key);\n    if (key.length !== 32)\n        throw new Error(`Expected 32 bytes`);\n    return key;\n}\nfunction getKeyFromHash(hashed) {\n    const head = adjustBytes25519(hashed.slice(0, 32));\n    const prefix = hashed.slice(32, 64);\n    const scalar = modlLE(head);\n    const point = Point.BASE.multiply(scalar);\n    const pointBytes = point.toRawBytes();\n    return { head, prefix, scalar, point, pointBytes };\n}\nlet _sha512Sync;\nfunction sha512s(...m) {\n    if (typeof _sha512Sync !== 'function')\n        throw new Error('utils.sha512Sync must be set to use sync methods');\n    return _sha512Sync(...m);\n}\nasync function getExtendedPublicKey(key) {\n    return getKeyFromHash(await exports.utils.sha512(checkPrivateKey(key)));\n}\nfunction getExtendedPublicKeySync(key) {\n    return getKeyFromHash(sha512s(checkPrivateKey(key)));\n}\nasync function getPublicKey(privateKey) {\n    return (await getExtendedPublicKey(privateKey)).pointBytes;\n}\nexports.getPublicKey = getPublicKey;\nfunction getPublicKeySync(privateKey) {\n    return getExtendedPublicKeySync(privateKey).pointBytes;\n}\nasync function sign(message, privateKey) {\n    message = ensureBytes(message);\n    const { prefix, scalar, pointBytes } = await getExtendedPublicKey(privateKey);\n    const r = modlLE(await exports.utils.sha512(prefix, message));\n    const R = Point.BASE.multiply(r);\n    const k = modlLE(await exports.utils.sha512(R.toRawBytes(), pointBytes, message));\n    const s = mod(r + k * scalar, CURVE.l);\n    return new Signature(R, s).toRawBytes();\n}\nexports.sign = sign;\nfunction signSync(message, privateKey) {\n    message = ensureBytes(message);\n    const { prefix, scalar, pointBytes } = getExtendedPublicKeySync(privateKey);\n    const r = modlLE(sha512s(prefix, message));\n    const R = Point.BASE.multiply(r);\n    const k = modlLE(sha512s(R.toRawBytes(), pointBytes, message));\n    const s = mod(r + k * scalar, CURVE.l);\n    return new Signature(R, s).toRawBytes();\n}\nfunction prepareVerification(sig, message, publicKey) {\n    message = ensureBytes(message);\n    if (!(publicKey instanceof Point))\n        publicKey = Point.fromHex(publicKey, false);\n    const { r, s } = sig instanceof Signature ? sig.assertValidity() : Signature.fromHex(sig);\n    const SB = ExtendedPoint.BASE.multiplyUnsafe(s);\n    return { r, s, SB, pub: publicKey, msg: message };\n}\nfunction finishVerification(publicKey, r, SB, hashed) {\n    const k = modlLE(hashed);\n    const kA = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(k);\n    const RkA = ExtendedPoint.fromAffine(r).add(kA);\n    return RkA.subtract(SB).multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);\n}\nasync function verify(sig, message, publicKey) {\n    const { r, SB, msg, pub } = prepareVerification(sig, message, publicKey);\n    const hashed = await exports.utils.sha512(r.toRawBytes(), pub.toRawBytes(), msg);\n    return finishVerification(pub, r, SB, hashed);\n}\nexports.verify = verify;\nfunction verifySync(sig, message, publicKey) {\n    const { r, SB, msg, pub } = prepareVerification(sig, message, publicKey);\n    const hashed = sha512s(r.toRawBytes(), pub.toRawBytes(), msg);\n    return finishVerification(pub, r, SB, hashed);\n}\nexports.sync = {\n    getExtendedPublicKey: getExtendedPublicKeySync,\n    getPublicKey: getPublicKeySync,\n    sign: signSync,\n    verify: verifySync,\n};\nasync function getSharedSecret(privateKey, publicKey) {\n    const { head } = await getExtendedPublicKey(privateKey);\n    const u = Point.fromHex(publicKey).toX25519();\n    return exports.curve25519.scalarMult(head, u);\n}\nexports.getSharedSecret = getSharedSecret;\nPoint.BASE._setWindowSize(8);\nfunction cswap(swap, x_2, x_3) {\n    const dummy = mod(swap * (x_2 - x_3));\n    x_2 = mod(x_2 - dummy);\n    x_3 = mod(x_3 + dummy);\n    return [x_2, x_3];\n}\nfunction montgomeryLadder(pointU, scalar) {\n    const { P } = CURVE;\n    const u = normalizeScalar(pointU, P);\n    const k = normalizeScalar(scalar, P);\n    const a24 = BigInt(121665);\n    const x_1 = u;\n    let x_2 = _1n;\n    let z_2 = _0n;\n    let x_3 = u;\n    let z_3 = _1n;\n    let swap = _0n;\n    let sw;\n    for (let t = BigInt(255 - 1); t >= _0n; t--) {\n        const k_t = (k >> t) & _1n;\n        swap ^= k_t;\n        sw = cswap(swap, x_2, x_3);\n        x_2 = sw[0];\n        x_3 = sw[1];\n        sw = cswap(swap, z_2, z_3);\n        z_2 = sw[0];\n        z_3 = sw[1];\n        swap = k_t;\n        const A = x_2 + z_2;\n        const AA = mod(A * A);\n        const B = x_2 - z_2;\n        const BB = mod(B * B);\n        const E = AA - BB;\n        const C = x_3 + z_3;\n        const D = x_3 - z_3;\n        const DA = mod(D * A);\n        const CB = mod(C * B);\n        const dacb = DA + CB;\n        const da_cb = DA - CB;\n        x_3 = mod(dacb * dacb);\n        z_3 = mod(x_1 * mod(da_cb * da_cb));\n        x_2 = mod(AA * BB);\n        z_2 = mod(E * (AA + mod(a24 * E)));\n    }\n    sw = cswap(swap, x_2, x_3);\n    x_2 = sw[0];\n    x_3 = sw[1];\n    sw = cswap(swap, z_2, z_3);\n    z_2 = sw[0];\n    z_3 = sw[1];\n    const { pow_p_5_8, b2 } = pow_2_252_3(z_2);\n    const xp2 = mod(pow2(pow_p_5_8, BigInt(3)) * b2);\n    return mod(x_2 * xp2);\n}\nfunction encodeUCoordinate(u) {\n    return numberTo32BytesLE(mod(u, CURVE.P));\n}\nfunction decodeUCoordinate(uEnc) {\n    const u = ensureBytes(uEnc, 32);\n    u[31] &= 127;\n    return bytesToNumberLE(u);\n}\nexports.curve25519 = {\n    BASE_POINT_U: '0900000000000000000000000000000000000000000000000000000000000000',\n    scalarMult(privateKey, publicKey) {\n        const u = decodeUCoordinate(publicKey);\n        const p = decodeScalar25519(privateKey);\n        const pu = montgomeryLadder(u, p);\n        if (pu === _0n)\n            throw new Error('Invalid private or public key received');\n        return encodeUCoordinate(pu);\n    },\n    scalarMultBase(privateKey) {\n        return exports.curve25519.scalarMult(privateKey, exports.curve25519.BASE_POINT_U);\n    },\n};\nconst crypto = {\n    node: nodeCrypto,\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\nexports.utils = {\n    bytesToHex,\n    hexToBytes,\n    concatBytes,\n    getExtendedPublicKey,\n    mod,\n    invert,\n    TORSION_SUBGROUP: [\n        '0100000000000000000000000000000000000000000000000000000000000000',\n        'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n        '0000000000000000000000000000000000000000000000000000000000000080',\n        '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n        'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n        '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n        '0000000000000000000000000000000000000000000000000000000000000000',\n        'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n    ],\n    hashToPrivateScalar: (hash) => {\n        hash = ensureBytes(hash);\n        if (hash.length < 40 || hash.length > 1024)\n            throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');\n        return mod(bytesToNumberLE(hash), CURVE.l - _1n) + _1n;\n    },\n    randomBytes: (bytesLength = 32) => {\n        if (crypto.web) {\n            return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n        }\n        else if (crypto.node) {\n            const { randomBytes } = crypto.node;\n            return new Uint8Array(randomBytes(bytesLength).buffer);\n        }\n        else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    randomPrivateKey: () => {\n        return exports.utils.randomBytes(32);\n    },\n    sha512: async (...messages) => {\n        const message = concatBytes(...messages);\n        if (crypto.web) {\n            const buffer = await crypto.web.subtle.digest('SHA-512', message.buffer);\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            return Uint8Array.from(crypto.node.createHash('sha512').update(message).digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have sha512 function\");\n        }\n    },\n    precompute(windowSize = 8, point = Point.BASE) {\n        const cached = point.equals(Point.BASE) ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(_2n);\n        return cached;\n    },\n    sha512Sync: undefined,\n};\nObject.defineProperties(exports.utils, {\n    sha512Sync: {\n        configurable: false,\n        get() {\n            return _sha512Sync;\n        },\n        set(val) {\n            if (!_sha512Sync)\n                _sha512Sync = val;\n        },\n    },\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}