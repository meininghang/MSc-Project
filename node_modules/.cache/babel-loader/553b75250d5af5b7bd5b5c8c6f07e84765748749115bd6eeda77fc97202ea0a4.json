{"ast":null,"code":"import { ethers, Contract, utils, providers } from 'ethers';\nimport erc20Abi from '../constants/abi/erc20';\nimport { getTokenAddrByChainType } from '../utils/util';\nimport { NATIVE_CHAIN_TOKENS } from '../constants';\n// 参考自 zkSync\n// https://github.com/WalletConnect/walletconnect-monorepo/issues/347#issuecomment-880553018\nconst signMessageAsync = async (ethConnectedSigner, address, message) => {\n  const messageBytes = utils.toUtf8Bytes(message);\n  if (ethConnectedSigner instanceof providers.JsonRpcSigner) {\n    try {\n      const signature = await ethConnectedSigner.provider.send('personal_sign', [utils.hexlify(messageBytes), address.toLowerCase()]);\n      return signature;\n    } catch (e) {\n      const noPersonalSign = e.message.includes('personal_sign');\n      if (noPersonalSign) {\n        return await ethConnectedSigner.signMessage(messageBytes);\n      }\n      throw e;\n    }\n  } else {\n    return await ethConnectedSigner.signMessage(messageBytes);\n  }\n};\nconst verifySigAsync = async (address, messageData, sig) => {\n  const recoveredAddress = await ethers.utils.verifyMessage(messageData, sig);\n  return recoveredAddress.toLowerCase() === address.toLowerCase();\n};\nconst transferAsync = async (ethConnectedSigner, chainType, {\n  symbol,\n  token,\n  from,\n  to,\n  value\n}) => {\n  let transactionResponse;\n  const foundNative = NATIVE_CHAIN_TOKENS.find(t => {\n    return t.chainType === chainType && t.nativeSymbol === symbol.toLowerCase();\n  });\n  // TODO: check balance\n  if (foundNative != null) {\n    const transactionRequest = {\n      from: from.toLowerCase(),\n      to: to === null || to === void 0 ? void 0 : to.toLowerCase(),\n      gasLimit: 25000,\n      value\n    };\n    transactionResponse = await ethConnectedSigner.sendTransaction(transactionRequest);\n  } else {\n    const tokenID = getTokenAddrByChainType(token, chainType);\n    const erc20RW = new Contract(tokenID.toLowerCase(), erc20Abi, ethConnectedSigner);\n    transactionResponse = await erc20RW.transfer(to, value, {\n      gasLimit: 200000\n    });\n  }\n  return transactionResponse;\n};\nexport default {\n  signMessageAsync,\n  verifySigAsync,\n  transferAsync\n};","map":{"version":3,"names":["ethers","Contract","utils","providers","erc20Abi","getTokenAddrByChainType","NATIVE_CHAIN_TOKENS","signMessageAsync","ethConnectedSigner","address","message","messageBytes","toUtf8Bytes","JsonRpcSigner","signature","provider","send","hexlify","toLowerCase","e","noPersonalSign","includes","signMessage","verifySigAsync","messageData","sig","recoveredAddress","verifyMessage","transferAsync","chainType","symbol","token","from","to","value","transactionResponse","foundNative","find","t","nativeSymbol","transactionRequest","gasLimit","sendTransaction","tokenID","erc20RW","transfer"],"sources":["E:/Amanda-project/vue2-project/project-vue2/node_modules/everpay/esm/lib/ethereum.js"],"sourcesContent":["import { ethers, Contract, utils, providers } from 'ethers';\nimport erc20Abi from '../constants/abi/erc20';\nimport { getTokenAddrByChainType } from '../utils/util';\nimport { NATIVE_CHAIN_TOKENS } from '../constants';\n// 参考自 zkSync\n// https://github.com/WalletConnect/walletconnect-monorepo/issues/347#issuecomment-880553018\nconst signMessageAsync = async (ethConnectedSigner, address, message) => {\n    const messageBytes = utils.toUtf8Bytes(message);\n    if (ethConnectedSigner instanceof providers.JsonRpcSigner) {\n        try {\n            const signature = await ethConnectedSigner.provider.send('personal_sign', [\n                utils.hexlify(messageBytes),\n                address.toLowerCase()\n            ]);\n            return signature;\n        }\n        catch (e) {\n            const noPersonalSign = e.message.includes('personal_sign');\n            if (noPersonalSign) {\n                return await ethConnectedSigner.signMessage(messageBytes);\n            }\n            throw e;\n        }\n    }\n    else {\n        return await ethConnectedSigner.signMessage(messageBytes);\n    }\n};\nconst verifySigAsync = async (address, messageData, sig) => {\n    const recoveredAddress = await ethers.utils.verifyMessage(messageData, sig);\n    return recoveredAddress.toLowerCase() === address.toLowerCase();\n};\nconst transferAsync = async (ethConnectedSigner, chainType, { symbol, token, from, to, value }) => {\n    let transactionResponse;\n    const foundNative = NATIVE_CHAIN_TOKENS.find(t => {\n        return t.chainType === chainType && t.nativeSymbol === symbol.toLowerCase();\n    });\n    // TODO: check balance\n    if (foundNative != null) {\n        const transactionRequest = {\n            from: from.toLowerCase(),\n            to: to === null || to === void 0 ? void 0 : to.toLowerCase(),\n            gasLimit: 25000,\n            value\n        };\n        transactionResponse = await ethConnectedSigner.sendTransaction(transactionRequest);\n    }\n    else {\n        const tokenID = getTokenAddrByChainType(token, chainType);\n        const erc20RW = new Contract(tokenID.toLowerCase(), erc20Abi, ethConnectedSigner);\n        transactionResponse = await erc20RW.transfer(to, value, {\n            gasLimit: 200000\n        });\n    }\n    return transactionResponse;\n};\nexport default {\n    signMessageAsync,\n    verifySigAsync,\n    transferAsync\n};\n"],"mappings":"AAAA,SAASA,MAAM,EAAEC,QAAQ,EAAEC,KAAK,EAAEC,SAAS,QAAQ,QAAQ;AAC3D,OAAOC,QAAQ,MAAM,wBAAwB;AAC7C,SAASC,uBAAuB,QAAQ,eAAe;AACvD,SAASC,mBAAmB,QAAQ,cAAc;AAClD;AACA;AACA,MAAMC,gBAAgB,GAAG,MAAAA,CAAOC,kBAAkB,EAAEC,OAAO,EAAEC,OAAO,KAAK;EACrE,MAAMC,YAAY,GAAGT,KAAK,CAACU,WAAW,CAACF,OAAO,CAAC;EAC/C,IAAIF,kBAAkB,YAAYL,SAAS,CAACU,aAAa,EAAE;IACvD,IAAI;MACA,MAAMC,SAAS,GAAG,MAAMN,kBAAkB,CAACO,QAAQ,CAACC,IAAI,CAAC,eAAe,EAAE,CACtEd,KAAK,CAACe,OAAO,CAACN,YAAY,CAAC,EAC3BF,OAAO,CAACS,WAAW,CAAC,CAAC,CACxB,CAAC;MACF,OAAOJ,SAAS;IACpB,CAAC,CACD,OAAOK,CAAC,EAAE;MACN,MAAMC,cAAc,GAAGD,CAAC,CAACT,OAAO,CAACW,QAAQ,CAAC,eAAe,CAAC;MAC1D,IAAID,cAAc,EAAE;QAChB,OAAO,MAAMZ,kBAAkB,CAACc,WAAW,CAACX,YAAY,CAAC;MAC7D;MACA,MAAMQ,CAAC;IACX;EACJ,CAAC,MACI;IACD,OAAO,MAAMX,kBAAkB,CAACc,WAAW,CAACX,YAAY,CAAC;EAC7D;AACJ,CAAC;AACD,MAAMY,cAAc,GAAG,MAAAA,CAAOd,OAAO,EAAEe,WAAW,EAAEC,GAAG,KAAK;EACxD,MAAMC,gBAAgB,GAAG,MAAM1B,MAAM,CAACE,KAAK,CAACyB,aAAa,CAACH,WAAW,EAAEC,GAAG,CAAC;EAC3E,OAAOC,gBAAgB,CAACR,WAAW,CAAC,CAAC,KAAKT,OAAO,CAACS,WAAW,CAAC,CAAC;AACnE,CAAC;AACD,MAAMU,aAAa,GAAG,MAAAA,CAAOpB,kBAAkB,EAAEqB,SAAS,EAAE;EAAEC,MAAM;EAAEC,KAAK;EAAEC,IAAI;EAAEC,EAAE;EAAEC;AAAM,CAAC,KAAK;EAC/F,IAAIC,mBAAmB;EACvB,MAAMC,WAAW,GAAG9B,mBAAmB,CAAC+B,IAAI,CAACC,CAAC,IAAI;IAC9C,OAAOA,CAAC,CAACT,SAAS,KAAKA,SAAS,IAAIS,CAAC,CAACC,YAAY,KAAKT,MAAM,CAACZ,WAAW,CAAC,CAAC;EAC/E,CAAC,CAAC;EACF;EACA,IAAIkB,WAAW,IAAI,IAAI,EAAE;IACrB,MAAMI,kBAAkB,GAAG;MACvBR,IAAI,EAAEA,IAAI,CAACd,WAAW,CAAC,CAAC;MACxBe,EAAE,EAAEA,EAAE,KAAK,IAAI,IAAIA,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACf,WAAW,CAAC,CAAC;MAC5DuB,QAAQ,EAAE,KAAK;MACfP;IACJ,CAAC;IACDC,mBAAmB,GAAG,MAAM3B,kBAAkB,CAACkC,eAAe,CAACF,kBAAkB,CAAC;EACtF,CAAC,MACI;IACD,MAAMG,OAAO,GAAGtC,uBAAuB,CAAC0B,KAAK,EAAEF,SAAS,CAAC;IACzD,MAAMe,OAAO,GAAG,IAAI3C,QAAQ,CAAC0C,OAAO,CAACzB,WAAW,CAAC,CAAC,EAAEd,QAAQ,EAAEI,kBAAkB,CAAC;IACjF2B,mBAAmB,GAAG,MAAMS,OAAO,CAACC,QAAQ,CAACZ,EAAE,EAAEC,KAAK,EAAE;MACpDO,QAAQ,EAAE;IACd,CAAC,CAAC;EACN;EACA,OAAON,mBAAmB;AAC9B,CAAC;AACD,eAAe;EACX5B,gBAAgB;EAChBgB,cAAc;EACdK;AACJ,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}