{"ast":null,"code":"var ber = require('asn1').Ber;\nvar _ = require('../utils')._;\nvar utils = require('../utils');\nconst PRIVATE_OPENING_BOUNDARY = '-----BEGIN RSA PRIVATE KEY-----';\nconst PRIVATE_CLOSING_BOUNDARY = '-----END RSA PRIVATE KEY-----';\nconst PUBLIC_OPENING_BOUNDARY = '-----BEGIN RSA PUBLIC KEY-----';\nconst PUBLIC_CLOSING_BOUNDARY = '-----END RSA PUBLIC KEY-----';\nmodule.exports = {\n  privateExport: function (key, options) {\n    options = options || {};\n    var n = key.n.toBuffer();\n    var d = key.d.toBuffer();\n    var p = key.p.toBuffer();\n    var q = key.q.toBuffer();\n    var dmp1 = key.dmp1.toBuffer();\n    var dmq1 = key.dmq1.toBuffer();\n    var coeff = key.coeff.toBuffer();\n    var length = n.length + d.length + p.length + q.length + dmp1.length + dmq1.length + coeff.length + 512; // magic\n    var writer = new ber.Writer({\n      size: length\n    });\n    writer.startSequence();\n    writer.writeInt(0);\n    writer.writeBuffer(n, 2);\n    writer.writeInt(key.e);\n    writer.writeBuffer(d, 2);\n    writer.writeBuffer(p, 2);\n    writer.writeBuffer(q, 2);\n    writer.writeBuffer(dmp1, 2);\n    writer.writeBuffer(dmq1, 2);\n    writer.writeBuffer(coeff, 2);\n    writer.endSequence();\n    if (options.type === 'der') {\n      return writer.buffer;\n    } else {\n      return PRIVATE_OPENING_BOUNDARY + '\\n' + utils.linebrk(writer.buffer.toString('base64'), 64) + '\\n' + PRIVATE_CLOSING_BOUNDARY;\n    }\n  },\n  privateImport: function (key, data, options) {\n    options = options || {};\n    var buffer;\n    if (options.type !== 'der') {\n      if (Buffer.isBuffer(data)) {\n        data = data.toString('utf8');\n      }\n      if (_.isString(data)) {\n        var pem = utils.trimSurroundingText(data, PRIVATE_OPENING_BOUNDARY, PRIVATE_CLOSING_BOUNDARY).replace(/\\s+|\\n\\r|\\n|\\r$/gm, '');\n        buffer = Buffer.from(pem, 'base64');\n      } else {\n        throw Error('Unsupported key format');\n      }\n    } else if (Buffer.isBuffer(data)) {\n      buffer = data;\n    } else {\n      throw Error('Unsupported key format');\n    }\n    var reader = new ber.Reader(buffer);\n    reader.readSequence();\n    reader.readString(2, true); // just zero\n    key.setPrivate(reader.readString(2, true),\n    // modulus\n    reader.readString(2, true),\n    // publicExponent\n    reader.readString(2, true),\n    // privateExponent\n    reader.readString(2, true),\n    // prime1\n    reader.readString(2, true),\n    // prime2\n    reader.readString(2, true),\n    // exponent1 -- d mod (p1)\n    reader.readString(2, true),\n    // exponent2 -- d mod (q-1)\n    reader.readString(2, true) // coefficient -- (inverse of q) mod p\n    );\n  },\n\n  publicExport: function (key, options) {\n    options = options || {};\n    var n = key.n.toBuffer();\n    var length = n.length + 512; // magic\n\n    var bodyWriter = new ber.Writer({\n      size: length\n    });\n    bodyWriter.startSequence();\n    bodyWriter.writeBuffer(n, 2);\n    bodyWriter.writeInt(key.e);\n    bodyWriter.endSequence();\n    if (options.type === 'der') {\n      return bodyWriter.buffer;\n    } else {\n      return PUBLIC_OPENING_BOUNDARY + '\\n' + utils.linebrk(bodyWriter.buffer.toString('base64'), 64) + '\\n' + PUBLIC_CLOSING_BOUNDARY;\n    }\n  },\n  publicImport: function (key, data, options) {\n    options = options || {};\n    var buffer;\n    if (options.type !== 'der') {\n      if (Buffer.isBuffer(data)) {\n        data = data.toString('utf8');\n      }\n      if (_.isString(data)) {\n        var pem = utils.trimSurroundingText(data, PUBLIC_OPENING_BOUNDARY, PUBLIC_CLOSING_BOUNDARY).replace(/\\s+|\\n\\r|\\n|\\r$/gm, '');\n        buffer = Buffer.from(pem, 'base64');\n      }\n    } else if (Buffer.isBuffer(data)) {\n      buffer = data;\n    } else {\n      throw Error('Unsupported key format');\n    }\n    var body = new ber.Reader(buffer);\n    body.readSequence();\n    key.setPublic(body.readString(0x02, true),\n    // modulus\n    body.readString(0x02, true) // publicExponent\n    );\n  },\n\n  /**\n   * Trying autodetect and import key\n   * @param key\n   * @param data\n   */\n  autoImport: function (key, data) {\n    // [\\S\\s]* matches zero or more of any character\n    if (/^[\\S\\s]*-----BEGIN RSA PRIVATE KEY-----\\s*(?=(([A-Za-z0-9+/=]+\\s*)+))\\1-----END RSA PRIVATE KEY-----[\\S\\s]*$/g.test(data)) {\n      module.exports.privateImport(key, data);\n      return true;\n    }\n    if (/^[\\S\\s]*-----BEGIN RSA PUBLIC KEY-----\\s*(?=(([A-Za-z0-9+/=]+\\s*)+))\\1-----END RSA PUBLIC KEY-----[\\S\\s]*$/g.test(data)) {\n      module.exports.publicImport(key, data);\n      return true;\n    }\n    return false;\n  }\n};","map":{"version":3,"names":["ber","require","Ber","_","utils","PRIVATE_OPENING_BOUNDARY","PRIVATE_CLOSING_BOUNDARY","PUBLIC_OPENING_BOUNDARY","PUBLIC_CLOSING_BOUNDARY","module","exports","privateExport","key","options","n","toBuffer","d","p","q","dmp1","dmq1","coeff","length","writer","Writer","size","startSequence","writeInt","writeBuffer","e","endSequence","type","buffer","linebrk","toString","privateImport","data","Buffer","isBuffer","isString","pem","trimSurroundingText","replace","from","Error","reader","Reader","readSequence","readString","setPrivate","publicExport","bodyWriter","publicImport","body","setPublic","autoImport","test"],"sources":["E:/Amanda-project/vue2-project/project-vue2/node_modules/node-rsa/src/formats/pkcs1.js"],"sourcesContent":["var ber = require('asn1').Ber;\nvar _ = require('../utils')._;\nvar utils = require('../utils');\n\nconst PRIVATE_OPENING_BOUNDARY = '-----BEGIN RSA PRIVATE KEY-----';\nconst PRIVATE_CLOSING_BOUNDARY = '-----END RSA PRIVATE KEY-----';\n\nconst PUBLIC_OPENING_BOUNDARY = '-----BEGIN RSA PUBLIC KEY-----';\nconst PUBLIC_CLOSING_BOUNDARY = '-----END RSA PUBLIC KEY-----';\n\nmodule.exports = {\n    privateExport: function (key, options) {\n        options = options || {};\n\n        var n = key.n.toBuffer();\n        var d = key.d.toBuffer();\n        var p = key.p.toBuffer();\n        var q = key.q.toBuffer();\n        var dmp1 = key.dmp1.toBuffer();\n        var dmq1 = key.dmq1.toBuffer();\n        var coeff = key.coeff.toBuffer();\n\n        var length = n.length + d.length + p.length + q.length + dmp1.length + dmq1.length + coeff.length + 512; // magic\n        var writer = new ber.Writer({size: length});\n\n        writer.startSequence();\n        writer.writeInt(0);\n        writer.writeBuffer(n, 2);\n        writer.writeInt(key.e);\n        writer.writeBuffer(d, 2);\n        writer.writeBuffer(p, 2);\n        writer.writeBuffer(q, 2);\n        writer.writeBuffer(dmp1, 2);\n        writer.writeBuffer(dmq1, 2);\n        writer.writeBuffer(coeff, 2);\n        writer.endSequence();\n\n        if (options.type === 'der') {\n            return writer.buffer;\n        } else {\n            return PRIVATE_OPENING_BOUNDARY + '\\n' + utils.linebrk(writer.buffer.toString('base64'), 64) + '\\n' + PRIVATE_CLOSING_BOUNDARY;\n        }\n    },\n\n    privateImport: function (key, data, options) {\n        options = options || {};\n        var buffer;\n\n        if (options.type !== 'der') {\n            if (Buffer.isBuffer(data)) {\n                data = data.toString('utf8');\n            }\n\n            if (_.isString(data)) {\n                var pem = utils.trimSurroundingText(data, PRIVATE_OPENING_BOUNDARY, PRIVATE_CLOSING_BOUNDARY)\n                    .replace(/\\s+|\\n\\r|\\n|\\r$/gm, '');\n                buffer = Buffer.from(pem, 'base64');\n            } else {\n                throw Error('Unsupported key format');\n            }\n        } else if (Buffer.isBuffer(data)) {\n            buffer = data;\n        } else {\n            throw Error('Unsupported key format');\n        }\n\n        var reader = new ber.Reader(buffer);\n        reader.readSequence();\n        reader.readString(2, true); // just zero\n        key.setPrivate(\n            reader.readString(2, true),  // modulus\n            reader.readString(2, true),  // publicExponent\n            reader.readString(2, true),  // privateExponent\n            reader.readString(2, true),  // prime1\n            reader.readString(2, true),  // prime2\n            reader.readString(2, true),  // exponent1 -- d mod (p1)\n            reader.readString(2, true),  // exponent2 -- d mod (q-1)\n            reader.readString(2, true)   // coefficient -- (inverse of q) mod p\n        );\n    },\n\n    publicExport: function (key, options) {\n        options = options || {};\n\n        var n = key.n.toBuffer();\n        var length = n.length + 512; // magic\n\n        var bodyWriter = new ber.Writer({size: length});\n        bodyWriter.startSequence();\n        bodyWriter.writeBuffer(n, 2);\n        bodyWriter.writeInt(key.e);\n        bodyWriter.endSequence();\n\n        if (options.type === 'der') {\n            return bodyWriter.buffer;\n        } else {\n            return PUBLIC_OPENING_BOUNDARY + '\\n' + utils.linebrk(bodyWriter.buffer.toString('base64'), 64) + '\\n' + PUBLIC_CLOSING_BOUNDARY;\n        }\n    },\n\n    publicImport: function (key, data, options) {\n        options = options || {};\n        var buffer;\n\n        if (options.type !== 'der') {\n            if (Buffer.isBuffer(data)) {\n                data = data.toString('utf8');\n            }\n\n            if (_.isString(data)) {\n                var pem = utils.trimSurroundingText(data, PUBLIC_OPENING_BOUNDARY, PUBLIC_CLOSING_BOUNDARY)\n                    .replace(/\\s+|\\n\\r|\\n|\\r$/gm, '');\n                buffer = Buffer.from(pem, 'base64');\n            }\n        } else if (Buffer.isBuffer(data)) {\n            buffer = data;\n        } else {\n            throw Error('Unsupported key format');\n        }\n\n        var body = new ber.Reader(buffer);\n        body.readSequence();\n        key.setPublic(\n            body.readString(0x02, true), // modulus\n            body.readString(0x02, true)  // publicExponent\n        );\n    },\n\n    /**\n     * Trying autodetect and import key\n     * @param key\n     * @param data\n     */\n    autoImport: function (key, data) {\n        // [\\S\\s]* matches zero or more of any character\n        if (/^[\\S\\s]*-----BEGIN RSA PRIVATE KEY-----\\s*(?=(([A-Za-z0-9+/=]+\\s*)+))\\1-----END RSA PRIVATE KEY-----[\\S\\s]*$/g.test(data)) {\n            module.exports.privateImport(key, data);\n            return true;\n        }\n\n        if (/^[\\S\\s]*-----BEGIN RSA PUBLIC KEY-----\\s*(?=(([A-Za-z0-9+/=]+\\s*)+))\\1-----END RSA PUBLIC KEY-----[\\S\\s]*$/g.test(data)) {\n            module.exports.publicImport(key, data);\n            return true;\n        }\n\n        return false;\n    }\n};"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}