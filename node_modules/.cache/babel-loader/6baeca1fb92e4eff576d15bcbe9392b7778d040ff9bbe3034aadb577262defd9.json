{"ast":null,"code":"/**\r\n * PSS signature scheme\r\n */\n\nvar BigInteger = require('../libs/jsbn');\nvar crypt = require('crypto');\nmodule.exports = {\n  isEncryption: false,\n  isSignature: true\n};\nvar DEFAULT_HASH_FUNCTION = 'sha1';\nvar DEFAULT_SALT_LENGTH = 20;\nmodule.exports.makeScheme = function (key, options) {\n  var OAEP = require('./schemes').pkcs1_oaep;\n\n  /**\r\n   * @param key\r\n   * @param options\r\n   * options    [Object]    An object that contains the following keys that specify certain options for encoding.\r\n   *  └>signingSchemeOptions\r\n   *     ├>hash    [String]    Hash function to use when encoding and generating masks. Must be a string accepted by node's crypto.createHash function. (default = \"sha1\")\r\n   *     ├>mgf    [function]    The mask generation function to use when encoding. (default = mgf1SHA1)\r\n   *     └>sLen    [uint]        The length of the salt to generate. (default = 20)\r\n   * @constructor\r\n   */\n  function Scheme(key, options) {\n    this.key = key;\n    this.options = options;\n  }\n  Scheme.prototype.sign = function (buffer) {\n    var mHash = crypt.createHash(this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION);\n    mHash.update(buffer);\n    var encoded = this.emsa_pss_encode(mHash.digest(), this.key.keySize - 1);\n    return this.key.$doPrivate(new BigInteger(encoded)).toBuffer(this.key.encryptedDataLength);\n  };\n  Scheme.prototype.verify = function (buffer, signature, signature_encoding) {\n    if (signature_encoding) {\n      signature = Buffer.from(signature, signature_encoding);\n    }\n    signature = new BigInteger(signature);\n    var emLen = Math.ceil((this.key.keySize - 1) / 8);\n    var m = this.key.$doPublic(signature).toBuffer(emLen);\n    var mHash = crypt.createHash(this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION);\n    mHash.update(buffer);\n    return this.emsa_pss_verify(mHash.digest(), m, this.key.keySize - 1);\n  };\n\n  /*\r\n   * https://tools.ietf.org/html/rfc3447#section-9.1.1\r\n   *\r\n   * mHash\t[Buffer]\tHashed message to encode\r\n   * emBits\t[uint]\t\tMaximum length of output in bits. Must be at least 8hLen + 8sLen + 9 (hLen = Hash digest length in bytes | sLen = length of salt in bytes)\r\n   * @returns {Buffer} The encoded message\r\n   */\n  Scheme.prototype.emsa_pss_encode = function (mHash, emBits) {\n    var hash = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;\n    var mgf = this.options.signingSchemeOptions.mgf || OAEP.eme_oaep_mgf1;\n    var sLen = this.options.signingSchemeOptions.saltLength || DEFAULT_SALT_LENGTH;\n    var hLen = OAEP.digestLength[hash];\n    var emLen = Math.ceil(emBits / 8);\n    if (emLen < hLen + sLen + 2) {\n      throw new Error(\"Output length passed to emBits(\" + emBits + \") is too small for the options \" + \"specified(\" + hash + \", \" + sLen + \"). To fix this issue increase the value of emBits. (minimum size: \" + (8 * hLen + 8 * sLen + 9) + \")\");\n    }\n    var salt = crypt.randomBytes(sLen);\n    var Mapostrophe = Buffer.alloc(8 + hLen + sLen);\n    Mapostrophe.fill(0, 0, 8);\n    mHash.copy(Mapostrophe, 8);\n    salt.copy(Mapostrophe, 8 + mHash.length);\n    var H = crypt.createHash(hash);\n    H.update(Mapostrophe);\n    H = H.digest();\n    var PS = Buffer.alloc(emLen - salt.length - hLen - 2);\n    PS.fill(0);\n    var DB = Buffer.alloc(PS.length + 1 + salt.length);\n    PS.copy(DB);\n    DB[PS.length] = 0x01;\n    salt.copy(DB, PS.length + 1);\n    var dbMask = mgf(H, DB.length, hash);\n\n    // XOR DB and dbMask together\n    var maskedDB = Buffer.alloc(DB.length);\n    for (var i = 0; i < dbMask.length; i++) {\n      maskedDB[i] = DB[i] ^ dbMask[i];\n    }\n    var bits = 8 * emLen - emBits;\n    var mask = 255 ^ 255 >> 8 - bits << 8 - bits;\n    maskedDB[0] = maskedDB[0] & mask;\n    var EM = Buffer.alloc(maskedDB.length + H.length + 1);\n    maskedDB.copy(EM, 0);\n    H.copy(EM, maskedDB.length);\n    EM[EM.length - 1] = 0xbc;\n    return EM;\n  };\n\n  /*\r\n   * https://tools.ietf.org/html/rfc3447#section-9.1.2\r\n   *\r\n   * mHash\t[Buffer]\tHashed message\r\n   * EM\t\t[Buffer]\tSignature\r\n   * emBits\t[uint]\t\tLength of EM in bits. Must be at least 8hLen + 8sLen + 9 to be a valid signature. (hLen = Hash digest length in bytes | sLen = length of salt in bytes)\r\n   * @returns {Boolean} True if signature(EM) matches message(M)\r\n   */\n  Scheme.prototype.emsa_pss_verify = function (mHash, EM, emBits) {\n    var hash = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;\n    var mgf = this.options.signingSchemeOptions.mgf || OAEP.eme_oaep_mgf1;\n    var sLen = this.options.signingSchemeOptions.saltLength || DEFAULT_SALT_LENGTH;\n    var hLen = OAEP.digestLength[hash];\n    var emLen = Math.ceil(emBits / 8);\n    if (emLen < hLen + sLen + 2 || EM[EM.length - 1] != 0xbc) {\n      return false;\n    }\n    var DB = Buffer.alloc(emLen - hLen - 1);\n    EM.copy(DB, 0, 0, emLen - hLen - 1);\n    var mask = 0;\n    for (var i = 0, bits = 8 * emLen - emBits; i < bits; i++) {\n      mask |= 1 << 7 - i;\n    }\n    if ((DB[0] & mask) !== 0) {\n      return false;\n    }\n    var H = EM.slice(emLen - hLen - 1, emLen - 1);\n    var dbMask = mgf(H, DB.length, hash);\n\n    // Unmask DB\n    for (i = 0; i < DB.length; i++) {\n      DB[i] ^= dbMask[i];\n    }\n    bits = 8 * emLen - emBits;\n    mask = 255 ^ 255 >> 8 - bits << 8 - bits;\n    DB[0] = DB[0] & mask;\n\n    // Filter out padding\n    for (i = 0; DB[i] === 0 && i < DB.length; i++);\n    if (DB[i] != 1) {\n      return false;\n    }\n    var salt = DB.slice(DB.length - sLen);\n    var Mapostrophe = Buffer.alloc(8 + hLen + sLen);\n    Mapostrophe.fill(0, 0, 8);\n    mHash.copy(Mapostrophe, 8);\n    salt.copy(Mapostrophe, 8 + mHash.length);\n    var Hapostrophe = crypt.createHash(hash);\n    Hapostrophe.update(Mapostrophe);\n    Hapostrophe = Hapostrophe.digest();\n    return H.toString(\"hex\") === Hapostrophe.toString(\"hex\");\n  };\n  return new Scheme(key, options);\n};","map":{"version":3,"names":["BigInteger","require","crypt","module","exports","isEncryption","isSignature","DEFAULT_HASH_FUNCTION","DEFAULT_SALT_LENGTH","makeScheme","key","options","OAEP","pkcs1_oaep","Scheme","prototype","sign","buffer","mHash","createHash","signingSchemeOptions","hash","update","encoded","emsa_pss_encode","digest","keySize","$doPrivate","toBuffer","encryptedDataLength","verify","signature","signature_encoding","Buffer","from","emLen","Math","ceil","m","$doPublic","emsa_pss_verify","emBits","mgf","eme_oaep_mgf1","sLen","saltLength","hLen","digestLength","Error","salt","randomBytes","Mapostrophe","alloc","fill","copy","length","H","PS","DB","dbMask","maskedDB","i","bits","mask","EM","slice","Hapostrophe","toString"],"sources":["E:/Amanda-project/vue2-project/project-vue2/node_modules/node-rsa/src/schemes/pss.js"],"sourcesContent":["/**\r\n * PSS signature scheme\r\n */\r\n\r\nvar BigInteger = require('../libs/jsbn');\r\nvar crypt = require('crypto');\r\n\r\nmodule.exports = {\r\n    isEncryption: false,\r\n    isSignature: true\r\n};\r\n\r\nvar DEFAULT_HASH_FUNCTION = 'sha1';\r\nvar DEFAULT_SALT_LENGTH = 20;\r\n\r\nmodule.exports.makeScheme = function (key, options) {\r\n    var OAEP = require('./schemes').pkcs1_oaep;\r\n\r\n    /**\r\n     * @param key\r\n     * @param options\r\n     * options    [Object]    An object that contains the following keys that specify certain options for encoding.\r\n     *  └>signingSchemeOptions\r\n     *     ├>hash    [String]    Hash function to use when encoding and generating masks. Must be a string accepted by node's crypto.createHash function. (default = \"sha1\")\r\n     *     ├>mgf    [function]    The mask generation function to use when encoding. (default = mgf1SHA1)\r\n     *     └>sLen    [uint]        The length of the salt to generate. (default = 20)\r\n     * @constructor\r\n     */\r\n    function Scheme(key, options) {\r\n        this.key = key;\r\n        this.options = options;\r\n    }\r\n\r\n    Scheme.prototype.sign = function (buffer) {\r\n        var mHash = crypt.createHash(this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION);\r\n        mHash.update(buffer);\r\n\r\n        var encoded = this.emsa_pss_encode(mHash.digest(), this.key.keySize - 1);\r\n        return this.key.$doPrivate(new BigInteger(encoded)).toBuffer(this.key.encryptedDataLength);\r\n    };\r\n\r\n    Scheme.prototype.verify = function (buffer, signature, signature_encoding) {\r\n        if (signature_encoding) {\r\n            signature = Buffer.from(signature, signature_encoding);\r\n        }\r\n        signature = new BigInteger(signature);\r\n\r\n        var emLen = Math.ceil((this.key.keySize - 1) / 8);\r\n        var m = this.key.$doPublic(signature).toBuffer(emLen);\r\n\r\n        var mHash = crypt.createHash(this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION);\r\n        mHash.update(buffer);\r\n\r\n        return this.emsa_pss_verify(mHash.digest(), m, this.key.keySize - 1);\r\n    };\r\n\r\n    /*\r\n     * https://tools.ietf.org/html/rfc3447#section-9.1.1\r\n     *\r\n     * mHash\t[Buffer]\tHashed message to encode\r\n     * emBits\t[uint]\t\tMaximum length of output in bits. Must be at least 8hLen + 8sLen + 9 (hLen = Hash digest length in bytes | sLen = length of salt in bytes)\r\n     * @returns {Buffer} The encoded message\r\n     */\r\n    Scheme.prototype.emsa_pss_encode = function (mHash, emBits) {\r\n        var hash = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;\r\n        var mgf = this.options.signingSchemeOptions.mgf || OAEP.eme_oaep_mgf1;\r\n        var sLen = this.options.signingSchemeOptions.saltLength || DEFAULT_SALT_LENGTH;\r\n\r\n        var hLen = OAEP.digestLength[hash];\r\n        var emLen = Math.ceil(emBits / 8);\r\n\r\n        if (emLen < hLen + sLen + 2) {\r\n            throw new Error(\"Output length passed to emBits(\" + emBits + \") is too small for the options \" +\r\n                \"specified(\" + hash + \", \" + sLen + \"). To fix this issue increase the value of emBits. (minimum size: \" +\r\n                (8 * hLen + 8 * sLen + 9) + \")\"\r\n            );\r\n        }\r\n\r\n        var salt = crypt.randomBytes(sLen);\r\n\r\n        var Mapostrophe = Buffer.alloc(8 + hLen + sLen);\r\n        Mapostrophe.fill(0, 0, 8);\r\n        mHash.copy(Mapostrophe, 8);\r\n        salt.copy(Mapostrophe, 8 + mHash.length);\r\n\r\n        var H = crypt.createHash(hash);\r\n        H.update(Mapostrophe);\r\n        H = H.digest();\r\n\r\n        var PS = Buffer.alloc(emLen - salt.length - hLen - 2);\r\n        PS.fill(0);\r\n\r\n        var DB = Buffer.alloc(PS.length + 1 + salt.length);\r\n        PS.copy(DB);\r\n        DB[PS.length] = 0x01;\r\n        salt.copy(DB, PS.length + 1);\r\n\r\n        var dbMask = mgf(H, DB.length, hash);\r\n\r\n        // XOR DB and dbMask together\r\n        var maskedDB = Buffer.alloc(DB.length);\r\n        for (var i = 0; i < dbMask.length; i++) {\r\n            maskedDB[i] = DB[i] ^ dbMask[i];\r\n        }\r\n\r\n        var bits = 8 * emLen - emBits;\r\n        var mask = 255 ^ (255 >> 8 - bits << 8 - bits);\r\n        maskedDB[0] = maskedDB[0] & mask;\r\n\r\n        var EM = Buffer.alloc(maskedDB.length + H.length + 1);\r\n        maskedDB.copy(EM, 0);\r\n        H.copy(EM, maskedDB.length);\r\n        EM[EM.length - 1] = 0xbc;\r\n\r\n        return EM;\r\n    };\r\n\r\n    /*\r\n     * https://tools.ietf.org/html/rfc3447#section-9.1.2\r\n     *\r\n     * mHash\t[Buffer]\tHashed message\r\n     * EM\t\t[Buffer]\tSignature\r\n     * emBits\t[uint]\t\tLength of EM in bits. Must be at least 8hLen + 8sLen + 9 to be a valid signature. (hLen = Hash digest length in bytes | sLen = length of salt in bytes)\r\n     * @returns {Boolean} True if signature(EM) matches message(M)\r\n     */\r\n    Scheme.prototype.emsa_pss_verify = function (mHash, EM, emBits) {\r\n        var hash = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;\r\n        var mgf = this.options.signingSchemeOptions.mgf || OAEP.eme_oaep_mgf1;\r\n        var sLen = this.options.signingSchemeOptions.saltLength || DEFAULT_SALT_LENGTH;\r\n\r\n        var hLen = OAEP.digestLength[hash];\r\n        var emLen = Math.ceil(emBits / 8);\r\n\r\n        if (emLen < hLen + sLen + 2 || EM[EM.length - 1] != 0xbc) {\r\n            return false;\r\n        }\r\n\r\n        var DB = Buffer.alloc(emLen - hLen - 1);\r\n        EM.copy(DB, 0, 0, emLen - hLen - 1);\r\n\r\n        var mask = 0;\r\n        for (var i = 0, bits = 8 * emLen - emBits; i < bits; i++) {\r\n            mask |= 1 << (7 - i);\r\n        }\r\n\r\n        if ((DB[0] & mask) !== 0) {\r\n            return false;\r\n        }\r\n\r\n        var H = EM.slice(emLen - hLen - 1, emLen - 1);\r\n        var dbMask = mgf(H, DB.length, hash);\r\n\r\n        // Unmask DB\r\n        for (i = 0; i < DB.length; i++) {\r\n            DB[i] ^= dbMask[i];\r\n        }\r\n\r\n        bits = 8 * emLen - emBits;\r\n        mask = 255 ^ (255 >> 8 - bits << 8 - bits);\r\n        DB[0] = DB[0] & mask;\r\n\r\n        // Filter out padding\r\n        for (i = 0; DB[i] === 0 && i < DB.length; i++);\r\n        if (DB[i] != 1) {\r\n            return false;\r\n        }\r\n\r\n        var salt = DB.slice(DB.length - sLen);\r\n\r\n        var Mapostrophe = Buffer.alloc(8 + hLen + sLen);\r\n        Mapostrophe.fill(0, 0, 8);\r\n        mHash.copy(Mapostrophe, 8);\r\n        salt.copy(Mapostrophe, 8 + mHash.length);\r\n\r\n        var Hapostrophe = crypt.createHash(hash);\r\n        Hapostrophe.update(Mapostrophe);\r\n        Hapostrophe = Hapostrophe.digest();\r\n\r\n        return H.toString(\"hex\") === Hapostrophe.toString(\"hex\");\r\n    };\r\n\r\n    return new Scheme(key, options);\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}