{"ast":null,"code":"/* jshint node: true */\n\n// TODO: Add streams which prefix each record with its length.\n\n'use strict';\n\n/**\n * This module defines custom streams to write and read Avro files.\n *\n * In particular, the `Block{En,De}coder` streams are able to deal with Avro\n * container files. None of the streams below depend on the filesystem however,\n * this way they can also be used in the browser (for example to parse HTTP\n * responses).\n */\nrequire(\"core-js/modules/es.array.push.js\");\nvar types = require('./types'),\n  utils = require('./utils'),\n  stream = require('stream'),\n  util = require('util'),\n  zlib = require('zlib');\nvar OPTS = {\n  namespace: 'org.apache.avro.file'\n};\nvar LONG_TYPE = types.Type.forSchema('long', OPTS);\nvar MAP_BYTES_TYPE = types.Type.forSchema({\n  type: 'map',\n  values: 'bytes'\n}, OPTS);\nvar HEADER_TYPE = types.Type.forSchema({\n  name: 'Header',\n  type: 'record',\n  fields: [{\n    name: 'magic',\n    type: {\n      type: 'fixed',\n      name: 'Magic',\n      size: 4\n    }\n  }, {\n    name: 'meta',\n    type: MAP_BYTES_TYPE\n  }, {\n    name: 'sync',\n    type: {\n      type: 'fixed',\n      name: 'Sync',\n      size: 16\n    }\n  }]\n}, OPTS);\nvar BLOCK_TYPE = types.Type.forSchema({\n  name: 'Block',\n  type: 'record',\n  fields: [{\n    name: 'count',\n    type: 'long'\n  }, {\n    name: 'data',\n    type: 'bytes'\n  }, {\n    name: 'sync',\n    type: 'Sync'\n  }]\n}, OPTS);\n\n// First 4 bytes of an Avro object container file.\nvar MAGIC_BYTES = utils.bufferFrom('Obj\\x01');\n\n// Convenience.\nvar f = util.format;\nvar Tap = utils.Tap;\n\n/** Duplex stream for decoding fragments. */\nfunction RawDecoder(schema, opts) {\n  opts = opts || {};\n  var noDecode = !!opts.noDecode;\n  stream.Duplex.call(this, {\n    readableObjectMode: !noDecode,\n    allowHalfOpen: false\n  });\n  this._type = types.Type.forSchema(schema);\n  this._tap = new Tap(utils.newBuffer(0));\n  this._writeCb = null;\n  this._needPush = false;\n  this._readValue = createReader(noDecode, this._type);\n  this._finished = false;\n  this.on('finish', function () {\n    this._finished = true;\n    this._read();\n  });\n}\nutil.inherits(RawDecoder, stream.Duplex);\nRawDecoder.prototype._write = function (chunk, encoding, cb) {\n  // Store the write callback and call it when we are done decoding all records\n  // in this chunk. If we call it right away, we risk loading the entire input\n  // in memory. We only need to store the latest callback since the stream API\n  // guarantees that `_write` won't be called again until we call the previous.\n  this._writeCb = cb;\n  var tap = this._tap;\n  tap.buf = Buffer.concat([tap.buf.slice(tap.pos), chunk]);\n  tap.pos = 0;\n  if (this._needPush) {\n    this._needPush = false;\n    this._read();\n  }\n};\nRawDecoder.prototype._read = function () {\n  this._needPush = false;\n  var tap = this._tap;\n  var pos = tap.pos;\n  var val = this._readValue(tap);\n  if (tap.isValid()) {\n    this.push(val);\n  } else if (!this._finished) {\n    tap.pos = pos;\n    this._needPush = true;\n    if (this._writeCb) {\n      // This should only ever be false on the first read, and only if it\n      // happens before the first write.\n      this._writeCb();\n    }\n  } else {\n    this.push(null);\n  }\n};\n\n/** Duplex stream for decoding object container files. */\nfunction BlockDecoder(opts) {\n  opts = opts || {};\n  var noDecode = !!opts.noDecode;\n  stream.Duplex.call(this, {\n    allowHalfOpen: true,\n    // For async decompressors.\n    readableObjectMode: !noDecode\n  });\n  this._rType = opts.readerSchema !== undefined ? types.Type.forSchema(opts.readerSchema) : undefined;\n  this._wType = null;\n  this._codecs = opts.codecs;\n  this._codec = undefined;\n  this._parseHook = opts.parseHook;\n  this._tap = new Tap(utils.newBuffer(0));\n  this._blockTap = new Tap(utils.newBuffer(0));\n  this._syncMarker = null;\n  this._readValue = null;\n  this._noDecode = noDecode;\n  this._queue = new utils.OrderedQueue();\n  this._decompress = null; // Decompression function.\n  this._index = 0; // Next block index.\n  this._remaining = undefined; // In the current block.\n  this._needPush = false;\n  this._finished = false;\n  this.on('finish', function () {\n    this._finished = true;\n    if (this._needPush) {\n      this._read();\n    }\n  });\n}\nutil.inherits(BlockDecoder, stream.Duplex);\nBlockDecoder.defaultCodecs = function () {\n  return {\n    'null': function (buf, cb) {\n      cb(null, buf);\n    },\n    'deflate': zlib.inflateRaw\n  };\n};\nBlockDecoder.getDefaultCodecs = BlockDecoder.defaultCodecs;\nBlockDecoder.prototype._decodeHeader = function () {\n  var tap = this._tap;\n  if (tap.buf.length < MAGIC_BYTES.length) {\n    // Wait until more data arrives.\n    return false;\n  }\n  if (!MAGIC_BYTES.equals(tap.buf.slice(0, MAGIC_BYTES.length))) {\n    this.emit('error', new Error('invalid magic bytes'));\n    return false;\n  }\n  var header = HEADER_TYPE._read(tap);\n  if (!tap.isValid()) {\n    return false;\n  }\n  this._codec = (header.meta['avro.codec'] || 'null').toString();\n  var codecs = this._codecs || BlockDecoder.getDefaultCodecs();\n  this._decompress = codecs[this._codec];\n  if (!this._decompress) {\n    this.emit('error', new Error(f('unknown codec: %s', this._codec)));\n    return;\n  }\n  try {\n    var schema = JSON.parse(header.meta['avro.schema'].toString());\n    if (this._parseHook) {\n      schema = this._parseHook(schema);\n    }\n    this._wType = types.Type.forSchema(schema);\n  } catch (err) {\n    this.emit('error', err);\n    return;\n  }\n  this._readValue = createReader(this._noDecode, this._wType, this._rType);\n  this._syncMarker = header.sync;\n  this.emit('metadata', this._wType, this._codec, header);\n  return true;\n};\nBlockDecoder.prototype._write = function (chunk, encoding, cb) {\n  var tap = this._tap;\n  tap.buf = Buffer.concat([tap.buf, chunk]);\n  tap.pos = 0;\n  if (!this._decodeHeader()) {\n    process.nextTick(cb);\n    return;\n  }\n\n  // We got the header, switch to block decoding mode. Also, call it directly\n  // in case we already have all the data (in which case `_write` wouldn't get\n  // called anymore).\n  this._write = this._writeChunk;\n  this._write(utils.newBuffer(0), encoding, cb);\n};\nBlockDecoder.prototype._writeChunk = function (chunk, encoding, cb) {\n  var tap = this._tap;\n  tap.buf = Buffer.concat([tap.buf.slice(tap.pos), chunk]);\n  tap.pos = 0;\n  var nBlocks = 1;\n  var block;\n  while (block = tryReadBlock(tap)) {\n    if (!this._syncMarker.equals(block.sync)) {\n      this.emit('error', new Error('invalid sync marker'));\n      return;\n    }\n    nBlocks++;\n    this._decompress(block.data, this._createBlockCallback(block.count, chunkCb));\n  }\n  chunkCb();\n  function chunkCb() {\n    if (! --nBlocks) {\n      cb();\n    }\n  }\n};\nBlockDecoder.prototype._createBlockCallback = function (count, cb) {\n  var self = this;\n  var index = this._index++;\n  return function (cause, data) {\n    if (cause) {\n      var err = new Error(f('%s codec decompression error', self._codec));\n      err.cause = cause;\n      self.emit('error', err);\n      cb();\n    } else {\n      self._queue.push(new BlockData(index, data, cb, count));\n      if (self._needPush) {\n        self._read();\n      }\n    }\n  };\n};\nBlockDecoder.prototype._read = function () {\n  this._needPush = false;\n  var tap = this._blockTap;\n  if (!this._remaining) {\n    var data = this._queue.pop();\n    if (!data || !data.count) {\n      if (this._finished) {\n        this.push(null);\n      } else {\n        this._needPush = true;\n      }\n      if (data) {\n        data.cb();\n      }\n      return; // Wait for more data.\n    }\n\n    data.cb();\n    this._remaining = data.count;\n    tap.buf = data.buf;\n    tap.pos = 0;\n  }\n  this._remaining--;\n  this.push(this._readValue(tap)); // The read is guaranteed valid.\n};\n\n/** Duplex stream for encoding. */\nfunction RawEncoder(schema, opts) {\n  opts = opts || {};\n  stream.Transform.call(this, {\n    writableObjectMode: true,\n    allowHalfOpen: false\n  });\n  this._type = types.Type.forSchema(schema);\n  this._writeValue = function (tap, val) {\n    try {\n      this._type._write(tap, val);\n    } catch (err) {\n      this.emit('error', err);\n    }\n  };\n  this._tap = new Tap(utils.newBuffer(opts.batchSize || 65536));\n}\nutil.inherits(RawEncoder, stream.Transform);\nRawEncoder.prototype._transform = function (val, encoding, cb) {\n  var tap = this._tap;\n  var buf = tap.buf;\n  var pos = tap.pos;\n  this._writeValue(tap, val);\n  if (!tap.isValid()) {\n    if (pos) {\n      // Emit any valid data.\n      this.push(copyBuffer(tap.buf, 0, pos));\n    }\n    var len = tap.pos - pos;\n    if (len > buf.length) {\n      // Not enough space for last written object, need to resize.\n      tap.buf = utils.newBuffer(2 * len);\n    }\n    tap.pos = 0;\n    this._writeValue(tap, val); // Rewrite last failed write.\n  }\n\n  cb();\n};\nRawEncoder.prototype._flush = function (cb) {\n  var tap = this._tap;\n  var pos = tap.pos;\n  if (pos) {\n    // This should only ever be false if nothing is written to the stream.\n    this.push(tap.buf.slice(0, pos));\n  }\n  cb();\n};\n\n/**\n * Duplex stream to write object container files.\n *\n * @param schema\n * @param opts {Object}\n *\n *  + `blockSize`, uncompressed.\n *  + `codec`\n *  + `codecs`\n *  + `metadata``\n *  + `noCheck`\n *  + `omitHeader`, useful to append to an existing block file.\n */\nfunction BlockEncoder(schema, opts) {\n  opts = opts || {};\n  stream.Duplex.call(this, {\n    allowHalfOpen: true,\n    // To support async compressors.\n    writableObjectMode: true\n  });\n  var type;\n  if (types.Type.isType(schema)) {\n    type = schema;\n    schema = undefined;\n  } else {\n    // Keep full schema to be able to write it to the header later.\n    type = types.Type.forSchema(schema);\n  }\n  this._schema = schema;\n  this._type = type;\n  this._writeValue = function (tap, val) {\n    try {\n      this._type._write(tap, val);\n    } catch (err) {\n      this.emit('error', err);\n    }\n  };\n  this._blockSize = opts.blockSize || 65536;\n  this._tap = new Tap(utils.newBuffer(this._blockSize));\n  this._codecs = opts.codecs;\n  this._codec = opts.codec || 'null';\n  this._blockCount = 0;\n  this._syncMarker = opts.syncMarker || new utils.Lcg().nextBuffer(16);\n  this._queue = new utils.OrderedQueue();\n  this._pending = 0;\n  this._finished = false;\n  this._needHeader = false;\n  this._needPush = false;\n  this._metadata = opts.metadata || {};\n  if (!MAP_BYTES_TYPE.isValid(this._metadata)) {\n    throw new Error('invalid metadata');\n  }\n  var codec = this._codec;\n  this._compress = (this._codecs || BlockEncoder.getDefaultCodecs())[codec];\n  if (!this._compress) {\n    throw new Error(f('unsupported codec: %s', codec));\n  }\n  if (opts.omitHeader !== undefined) {\n    // Legacy option.\n    opts.writeHeader = opts.omitHeader ? 'never' : 'auto';\n  }\n  switch (opts.writeHeader) {\n    case false:\n    case 'never':\n      break;\n    case undefined: // Backwards-compatibility (eager default would be better).\n    case 'auto':\n      this._needHeader = true;\n      break;\n    default:\n      this._writeHeader();\n  }\n  this.on('finish', function () {\n    this._finished = true;\n    if (this._blockCount) {\n      this._flushChunk();\n    } else if (this._finished && this._needPush) {\n      // We don't need to check `_isPending` since `_blockCount` is always\n      // positive after the first flush.\n      this.push(null);\n    }\n  });\n}\nutil.inherits(BlockEncoder, stream.Duplex);\nBlockEncoder.defaultCodecs = function () {\n  return {\n    'null': function (buf, cb) {\n      cb(null, buf);\n    },\n    'deflate': zlib.deflateRaw\n  };\n};\nBlockEncoder.getDefaultCodecs = BlockEncoder.defaultCodecs;\nBlockEncoder.prototype._writeHeader = function () {\n  var schema = JSON.stringify(this._schema ? this._schema : this._type.getSchema({\n    exportAttrs: true\n  }));\n  var meta = utils.copyOwnProperties(this._metadata, {\n    'avro.schema': utils.bufferFrom(schema),\n    'avro.codec': utils.bufferFrom(this._codec)\n  }, true // Overwrite.\n  );\n\n  var Header = HEADER_TYPE.getRecordConstructor();\n  var header = new Header(MAGIC_BYTES, meta, this._syncMarker);\n  this.push(header.toBuffer());\n};\nBlockEncoder.prototype._write = function (val, encoding, cb) {\n  if (this._needHeader) {\n    this._writeHeader();\n    this._needHeader = false;\n  }\n  var tap = this._tap;\n  var pos = tap.pos;\n  var flushing = false;\n  this._writeValue(tap, val);\n  if (!tap.isValid()) {\n    if (pos) {\n      this._flushChunk(pos, cb);\n      flushing = true;\n    }\n    var len = tap.pos - pos;\n    if (len > this._blockSize) {\n      // Not enough space for last written object, need to resize.\n      this._blockSize = len * 2;\n    }\n    tap.buf = utils.newBuffer(this._blockSize);\n    tap.pos = 0;\n    this._writeValue(tap, val); // Rewrite last failed write.\n  }\n\n  this._blockCount++;\n  if (!flushing) {\n    cb();\n  }\n};\nBlockEncoder.prototype._flushChunk = function (pos, cb) {\n  var tap = this._tap;\n  pos = pos || tap.pos;\n  this._compress(tap.buf.slice(0, pos), this._createBlockCallback(cb));\n  this._blockCount = 0;\n};\nBlockEncoder.prototype._read = function () {\n  var self = this;\n  var data = this._queue.pop();\n  if (!data) {\n    if (this._finished && !this._pending) {\n      process.nextTick(function () {\n        self.push(null);\n      });\n    } else {\n      this._needPush = true;\n    }\n    return;\n  }\n  this.push(LONG_TYPE.toBuffer(data.count, true));\n  this.push(LONG_TYPE.toBuffer(data.buf.length, true));\n  this.push(data.buf);\n  this.push(this._syncMarker);\n  if (!this._finished) {\n    data.cb();\n  }\n};\nBlockEncoder.prototype._createBlockCallback = function (cb) {\n  var self = this;\n  var index = this._index++;\n  var count = this._blockCount;\n  this._pending++;\n  return function (cause, data) {\n    if (cause) {\n      var err = new Error(f('%s codec compression error', self._codec));\n      err.cause = cause;\n      self.emit('error', err);\n      return;\n    }\n    self._pending--;\n    self._queue.push(new BlockData(index, data, cb, count));\n    if (self._needPush) {\n      self._needPush = false;\n      self._read();\n    }\n  };\n};\n\n// Helpers.\n\n/**\n * An indexed block.\n *\n * This can be used to preserve block order since compression and decompression\n * can cause some some blocks to be returned out of order.\n */\nfunction BlockData(index, buf, cb, count) {\n  this.index = index;\n  this.buf = buf;\n  this.cb = cb;\n  this.count = count | 0;\n}\n\n/** Maybe get a block. */\nfunction tryReadBlock(tap) {\n  var pos = tap.pos;\n  var block = BLOCK_TYPE._read(tap);\n  if (!tap.isValid()) {\n    tap.pos = pos;\n    return null;\n  }\n  return block;\n}\n\n/** Create bytes consumer, either reading or skipping records. */\nfunction createReader(noDecode, writerType, readerType) {\n  if (noDecode) {\n    return function (skipper) {\n      return function (tap) {\n        var pos = tap.pos;\n        skipper(tap);\n        return tap.buf.slice(pos, tap.pos);\n      };\n    }(writerType._skip);\n  } else if (readerType) {\n    var resolver = readerType.createResolver(writerType);\n    return function (tap) {\n      return resolver._read(tap);\n    };\n  } else {\n    return function (tap) {\n      return writerType._read(tap);\n    };\n  }\n}\n\n/** Copy a buffer. This avoids creating a slice of the original buffer. */\nfunction copyBuffer(buf, pos, len) {\n  var copy = utils.newBuffer(len);\n  buf.copy(copy, 0, pos, pos + len);\n  return copy;\n}\nmodule.exports = {\n  BLOCK_TYPE: BLOCK_TYPE,\n  // For tests.\n  HEADER_TYPE: HEADER_TYPE,\n  // Idem.\n  MAGIC_BYTES: MAGIC_BYTES,\n  // Idem.\n  streams: {\n    BlockDecoder: BlockDecoder,\n    BlockEncoder: BlockEncoder,\n    RawDecoder: RawDecoder,\n    RawEncoder: RawEncoder\n  }\n};","map":{"version":3,"names":["require","types","utils","stream","util","zlib","OPTS","namespace","LONG_TYPE","Type","forSchema","MAP_BYTES_TYPE","type","values","HEADER_TYPE","name","fields","size","BLOCK_TYPE","MAGIC_BYTES","bufferFrom","f","format","Tap","RawDecoder","schema","opts","noDecode","Duplex","call","readableObjectMode","allowHalfOpen","_type","_tap","newBuffer","_writeCb","_needPush","_readValue","createReader","_finished","on","_read","inherits","prototype","_write","chunk","encoding","cb","tap","buf","Buffer","concat","slice","pos","val","isValid","push","BlockDecoder","_rType","readerSchema","undefined","_wType","_codecs","codecs","_codec","_parseHook","parseHook","_blockTap","_syncMarker","_noDecode","_queue","OrderedQueue","_decompress","_index","_remaining","defaultCodecs","null","inflateRaw","getDefaultCodecs","_decodeHeader","length","equals","emit","Error","header","meta","toString","JSON","parse","err","sync","process","nextTick","_writeChunk","nBlocks","block","tryReadBlock","data","_createBlockCallback","count","chunkCb","self","index","cause","BlockData","pop","RawEncoder","Transform","writableObjectMode","_writeValue","batchSize","_transform","copyBuffer","len","_flush","BlockEncoder","isType","_schema","_blockSize","blockSize","codec","_blockCount","syncMarker","Lcg","nextBuffer","_pending","_needHeader","_metadata","metadata","_compress","omitHeader","writeHeader","_writeHeader","_flushChunk","deflateRaw","stringify","getSchema","exportAttrs","copyOwnProperties","Header","getRecordConstructor","toBuffer","flushing","writerType","readerType","skipper","_skip","resolver","createResolver","copy","module","exports","streams"],"sources":["E:/Amanda-project/vue2-project/project-vue2/node_modules/avsc/lib/containers.js"],"sourcesContent":["/* jshint node: true */\n\n// TODO: Add streams which prefix each record with its length.\n\n'use strict';\n\n/**\n * This module defines custom streams to write and read Avro files.\n *\n * In particular, the `Block{En,De}coder` streams are able to deal with Avro\n * container files. None of the streams below depend on the filesystem however,\n * this way they can also be used in the browser (for example to parse HTTP\n * responses).\n */\n\nvar types = require('./types'),\n    utils = require('./utils'),\n    stream = require('stream'),\n    util = require('util'),\n    zlib = require('zlib');\n\n\nvar OPTS = {namespace: 'org.apache.avro.file'};\n\nvar LONG_TYPE = types.Type.forSchema('long', OPTS);\n\nvar MAP_BYTES_TYPE = types.Type.forSchema({type: 'map', values: 'bytes'}, OPTS);\n\nvar HEADER_TYPE = types.Type.forSchema({\n  name: 'Header',\n  type: 'record',\n  fields : [\n    {name: 'magic', type: {type: 'fixed', name: 'Magic', size: 4}},\n    {name: 'meta', type: MAP_BYTES_TYPE},\n    {name: 'sync', type: {type: 'fixed', name: 'Sync', size: 16}}\n  ]\n}, OPTS);\n\nvar BLOCK_TYPE = types.Type.forSchema({\n  name: 'Block',\n  type: 'record',\n  fields : [\n    {name: 'count', type: 'long'},\n    {name: 'data', type: 'bytes'},\n    {name: 'sync', type: 'Sync'}\n  ]\n}, OPTS);\n\n// First 4 bytes of an Avro object container file.\nvar MAGIC_BYTES = utils.bufferFrom('Obj\\x01');\n\n// Convenience.\nvar f = util.format;\nvar Tap = utils.Tap;\n\n\n/** Duplex stream for decoding fragments. */\nfunction RawDecoder(schema, opts) {\n  opts = opts || {};\n\n  var noDecode = !!opts.noDecode;\n  stream.Duplex.call(this, {\n    readableObjectMode: !noDecode,\n    allowHalfOpen: false\n  });\n\n  this._type = types.Type.forSchema(schema);\n  this._tap = new Tap(utils.newBuffer(0));\n  this._writeCb = null;\n  this._needPush = false;\n  this._readValue = createReader(noDecode, this._type);\n  this._finished = false;\n\n  this.on('finish', function () {\n    this._finished = true;\n    this._read();\n  });\n}\nutil.inherits(RawDecoder, stream.Duplex);\n\nRawDecoder.prototype._write = function (chunk, encoding, cb) {\n  // Store the write callback and call it when we are done decoding all records\n  // in this chunk. If we call it right away, we risk loading the entire input\n  // in memory. We only need to store the latest callback since the stream API\n  // guarantees that `_write` won't be called again until we call the previous.\n  this._writeCb = cb;\n\n  var tap = this._tap;\n  tap.buf = Buffer.concat([tap.buf.slice(tap.pos), chunk]);\n  tap.pos = 0;\n  if (this._needPush) {\n    this._needPush = false;\n    this._read();\n  }\n};\n\nRawDecoder.prototype._read = function () {\n  this._needPush = false;\n\n  var tap = this._tap;\n  var pos = tap.pos;\n  var val = this._readValue(tap);\n  if (tap.isValid()) {\n    this.push(val);\n  } else if (!this._finished) {\n    tap.pos = pos;\n    this._needPush = true;\n    if (this._writeCb) {\n      // This should only ever be false on the first read, and only if it\n      // happens before the first write.\n      this._writeCb();\n    }\n  } else {\n    this.push(null);\n  }\n};\n\n\n/** Duplex stream for decoding object container files. */\nfunction BlockDecoder(opts) {\n  opts = opts || {};\n\n  var noDecode = !!opts.noDecode;\n  stream.Duplex.call(this, {\n    allowHalfOpen: true, // For async decompressors.\n    readableObjectMode: !noDecode\n  });\n\n  this._rType = opts.readerSchema !== undefined ?\n    types.Type.forSchema(opts.readerSchema) :\n    undefined;\n  this._wType = null;\n  this._codecs = opts.codecs;\n  this._codec = undefined;\n  this._parseHook = opts.parseHook;\n  this._tap = new Tap(utils.newBuffer(0));\n  this._blockTap = new Tap(utils.newBuffer(0));\n  this._syncMarker = null;\n  this._readValue = null;\n  this._noDecode = noDecode;\n  this._queue = new utils.OrderedQueue();\n  this._decompress = null; // Decompression function.\n  this._index = 0; // Next block index.\n  this._remaining = undefined; // In the current block.\n  this._needPush = false;\n  this._finished = false;\n\n  this.on('finish', function () {\n    this._finished = true;\n    if (this._needPush) {\n      this._read();\n    }\n  });\n}\nutil.inherits(BlockDecoder, stream.Duplex);\n\nBlockDecoder.defaultCodecs = function () {\n  return {\n    'null': function (buf, cb) { cb(null, buf); },\n    'deflate': zlib.inflateRaw\n  };\n};\n\nBlockDecoder.getDefaultCodecs = BlockDecoder.defaultCodecs;\n\nBlockDecoder.prototype._decodeHeader = function () {\n  var tap = this._tap;\n  if (tap.buf.length < MAGIC_BYTES.length) {\n    // Wait until more data arrives.\n    return false;\n  }\n\n  if (!MAGIC_BYTES.equals(tap.buf.slice(0, MAGIC_BYTES.length))) {\n    this.emit('error', new Error('invalid magic bytes'));\n    return false;\n  }\n\n  var header = HEADER_TYPE._read(tap);\n  if (!tap.isValid()) {\n    return false;\n  }\n\n  this._codec = (header.meta['avro.codec'] || 'null').toString();\n  var codecs = this._codecs || BlockDecoder.getDefaultCodecs();\n  this._decompress = codecs[this._codec];\n  if (!this._decompress) {\n    this.emit('error', new Error(f('unknown codec: %s', this._codec)));\n    return;\n  }\n\n  try {\n    var schema = JSON.parse(header.meta['avro.schema'].toString());\n    if (this._parseHook) {\n      schema = this._parseHook(schema);\n    }\n    this._wType = types.Type.forSchema(schema);\n  } catch (err) {\n    this.emit('error', err);\n    return;\n  }\n\n  this._readValue = createReader(this._noDecode, this._wType, this._rType);\n  this._syncMarker = header.sync;\n  this.emit('metadata', this._wType, this._codec, header);\n  return true;\n};\n\nBlockDecoder.prototype._write = function (chunk, encoding, cb) {\n  var tap = this._tap;\n  tap.buf = Buffer.concat([tap.buf, chunk]);\n  tap.pos = 0;\n\n  if (!this._decodeHeader()) {\n    process.nextTick(cb);\n    return;\n  }\n\n  // We got the header, switch to block decoding mode. Also, call it directly\n  // in case we already have all the data (in which case `_write` wouldn't get\n  // called anymore).\n  this._write = this._writeChunk;\n  this._write(utils.newBuffer(0), encoding, cb);\n};\n\nBlockDecoder.prototype._writeChunk = function (chunk, encoding, cb) {\n  var tap = this._tap;\n  tap.buf = Buffer.concat([tap.buf.slice(tap.pos), chunk]);\n  tap.pos = 0;\n\n  var nBlocks = 1;\n  var block;\n  while ((block = tryReadBlock(tap))) {\n    if (!this._syncMarker.equals(block.sync)) {\n      this.emit('error', new Error('invalid sync marker'));\n      return;\n    }\n    nBlocks++;\n    this._decompress(\n      block.data,\n      this._createBlockCallback(block.count, chunkCb)\n    );\n  }\n  chunkCb();\n\n  function chunkCb() {\n    if (!--nBlocks) {\n      cb();\n    }\n  }\n};\n\nBlockDecoder.prototype._createBlockCallback = function (count, cb) {\n  var self = this;\n  var index = this._index++;\n\n  return function (cause, data) {\n    if (cause) {\n      var err = new Error(f('%s codec decompression error', self._codec));\n      err.cause = cause;\n      self.emit('error', err);\n      cb();\n    } else {\n      self._queue.push(new BlockData(index, data, cb, count));\n      if (self._needPush) {\n        self._read();\n      }\n    }\n  };\n};\n\nBlockDecoder.prototype._read = function () {\n  this._needPush = false;\n\n  var tap = this._blockTap;\n  if (!this._remaining) {\n    var data = this._queue.pop();\n    if (!data || !data.count) {\n      if (this._finished) {\n        this.push(null);\n      } else {\n        this._needPush = true;\n      }\n      if (data) {\n        data.cb();\n      }\n      return; // Wait for more data.\n    }\n    data.cb();\n    this._remaining = data.count;\n    tap.buf = data.buf;\n    tap.pos = 0;\n  }\n\n  this._remaining--;\n  this.push(this._readValue(tap)); // The read is guaranteed valid.\n};\n\n\n/** Duplex stream for encoding. */\nfunction RawEncoder(schema, opts) {\n  opts = opts || {};\n\n  stream.Transform.call(this, {\n    writableObjectMode: true,\n    allowHalfOpen: false\n  });\n\n  this._type = types.Type.forSchema(schema);\n  this._writeValue = function (tap, val) {\n    try {\n      this._type._write(tap, val);\n    } catch (err) {\n      this.emit('error', err);\n    }\n  };\n  this._tap = new Tap(utils.newBuffer(opts.batchSize || 65536));\n}\nutil.inherits(RawEncoder, stream.Transform);\n\nRawEncoder.prototype._transform = function (val, encoding, cb) {\n  var tap = this._tap;\n  var buf = tap.buf;\n  var pos = tap.pos;\n\n  this._writeValue(tap, val);\n  if (!tap.isValid()) {\n    if (pos) {\n      // Emit any valid data.\n      this.push(copyBuffer(tap.buf, 0, pos));\n    }\n    var len = tap.pos - pos;\n    if (len > buf.length) {\n      // Not enough space for last written object, need to resize.\n      tap.buf = utils.newBuffer(2 * len);\n    }\n    tap.pos = 0;\n    this._writeValue(tap, val); // Rewrite last failed write.\n  }\n\n  cb();\n};\n\nRawEncoder.prototype._flush = function (cb) {\n  var tap = this._tap;\n  var pos = tap.pos;\n  if (pos) {\n    // This should only ever be false if nothing is written to the stream.\n    this.push(tap.buf.slice(0, pos));\n  }\n  cb();\n};\n\n\n/**\n * Duplex stream to write object container files.\n *\n * @param schema\n * @param opts {Object}\n *\n *  + `blockSize`, uncompressed.\n *  + `codec`\n *  + `codecs`\n *  + `metadata``\n *  + `noCheck`\n *  + `omitHeader`, useful to append to an existing block file.\n */\nfunction BlockEncoder(schema, opts) {\n  opts = opts || {};\n\n  stream.Duplex.call(this, {\n    allowHalfOpen: true, // To support async compressors.\n    writableObjectMode: true\n  });\n\n  var type;\n  if (types.Type.isType(schema)) {\n    type = schema;\n    schema = undefined;\n  } else {\n    // Keep full schema to be able to write it to the header later.\n    type = types.Type.forSchema(schema);\n  }\n\n  this._schema = schema;\n  this._type = type;\n  this._writeValue = function (tap, val) {\n    try {\n      this._type._write(tap, val);\n    } catch (err) {\n      this.emit('error', err);\n    }\n  };\n  this._blockSize = opts.blockSize || 65536;\n  this._tap = new Tap(utils.newBuffer(this._blockSize));\n  this._codecs = opts.codecs;\n  this._codec = opts.codec || 'null';\n  this._blockCount = 0;\n  this._syncMarker = opts.syncMarker || new utils.Lcg().nextBuffer(16);\n  this._queue = new utils.OrderedQueue();\n  this._pending = 0;\n  this._finished = false;\n  this._needHeader = false;\n  this._needPush = false;\n\n  this._metadata = opts.metadata || {};\n  if (!MAP_BYTES_TYPE.isValid(this._metadata)) {\n    throw new Error('invalid metadata');\n  }\n\n  var codec = this._codec;\n  this._compress = (this._codecs || BlockEncoder.getDefaultCodecs())[codec];\n  if (!this._compress) {\n    throw new Error(f('unsupported codec: %s', codec));\n  }\n\n  if (opts.omitHeader !== undefined) { // Legacy option.\n    opts.writeHeader = opts.omitHeader ? 'never' : 'auto';\n  }\n  switch (opts.writeHeader) {\n    case false:\n    case 'never':\n      break;\n    case undefined: // Backwards-compatibility (eager default would be better).\n    case 'auto':\n      this._needHeader = true;\n      break;\n    default:\n      this._writeHeader();\n  }\n\n  this.on('finish', function () {\n    this._finished = true;\n    if (this._blockCount) {\n      this._flushChunk();\n    } else if (this._finished && this._needPush) {\n      // We don't need to check `_isPending` since `_blockCount` is always\n      // positive after the first flush.\n      this.push(null);\n    }\n  });\n}\nutil.inherits(BlockEncoder, stream.Duplex);\n\nBlockEncoder.defaultCodecs = function () {\n  return {\n    'null': function (buf, cb) { cb(null, buf); },\n    'deflate': zlib.deflateRaw\n  };\n};\n\nBlockEncoder.getDefaultCodecs = BlockEncoder.defaultCodecs;\n\nBlockEncoder.prototype._writeHeader = function () {\n  var schema = JSON.stringify(\n    this._schema ? this._schema : this._type.getSchema({exportAttrs: true})\n  );\n  var meta = utils.copyOwnProperties(\n    this._metadata,\n    {'avro.schema': utils.bufferFrom(schema), 'avro.codec': utils.bufferFrom(this._codec)},\n    true // Overwrite.\n  );\n  var Header = HEADER_TYPE.getRecordConstructor();\n  var header = new Header(MAGIC_BYTES, meta, this._syncMarker);\n  this.push(header.toBuffer());\n};\n\nBlockEncoder.prototype._write = function (val, encoding, cb) {\n  if (this._needHeader) {\n    this._writeHeader();\n    this._needHeader = false;\n  }\n\n  var tap = this._tap;\n  var pos = tap.pos;\n  var flushing = false;\n\n  this._writeValue(tap, val);\n  if (!tap.isValid()) {\n    if (pos) {\n      this._flushChunk(pos, cb);\n      flushing = true;\n    }\n    var len = tap.pos - pos;\n    if (len > this._blockSize) {\n      // Not enough space for last written object, need to resize.\n      this._blockSize = len * 2;\n    }\n    tap.buf = utils.newBuffer(this._blockSize);\n    tap.pos = 0;\n    this._writeValue(tap, val); // Rewrite last failed write.\n  }\n  this._blockCount++;\n\n  if (!flushing) {\n    cb();\n  }\n};\n\nBlockEncoder.prototype._flushChunk = function (pos, cb) {\n  var tap = this._tap;\n  pos = pos || tap.pos;\n  this._compress(tap.buf.slice(0, pos), this._createBlockCallback(cb));\n  this._blockCount = 0;\n};\n\nBlockEncoder.prototype._read = function () {\n  var self = this;\n  var data = this._queue.pop();\n  if (!data) {\n    if (this._finished && !this._pending) {\n      process.nextTick(function () { self.push(null); });\n    } else {\n      this._needPush = true;\n    }\n    return;\n  }\n\n  this.push(LONG_TYPE.toBuffer(data.count, true));\n  this.push(LONG_TYPE.toBuffer(data.buf.length, true));\n  this.push(data.buf);\n  this.push(this._syncMarker);\n\n  if (!this._finished) {\n    data.cb();\n  }\n};\n\nBlockEncoder.prototype._createBlockCallback = function (cb) {\n  var self = this;\n  var index = this._index++;\n  var count = this._blockCount;\n  this._pending++;\n\n  return function (cause, data) {\n    if (cause) {\n      var err = new Error(f('%s codec compression error', self._codec));\n      err.cause = cause;\n      self.emit('error', err);\n      return;\n    }\n    self._pending--;\n    self._queue.push(new BlockData(index, data, cb, count));\n    if (self._needPush) {\n      self._needPush = false;\n      self._read();\n    }\n  };\n};\n\n\n// Helpers.\n\n/**\n * An indexed block.\n *\n * This can be used to preserve block order since compression and decompression\n * can cause some some blocks to be returned out of order.\n */\nfunction BlockData(index, buf, cb, count) {\n  this.index = index;\n  this.buf = buf;\n  this.cb = cb;\n  this.count = count | 0;\n}\n\n/** Maybe get a block. */\nfunction tryReadBlock(tap) {\n  var pos = tap.pos;\n  var block = BLOCK_TYPE._read(tap);\n  if (!tap.isValid()) {\n    tap.pos = pos;\n    return null;\n  }\n  return block;\n}\n\n/** Create bytes consumer, either reading or skipping records. */\nfunction createReader(noDecode, writerType, readerType) {\n  if (noDecode) {\n    return (function (skipper) {\n      return function (tap) {\n        var pos = tap.pos;\n        skipper(tap);\n        return tap.buf.slice(pos, tap.pos);\n      };\n    })(writerType._skip);\n  } else if (readerType) {\n    var resolver = readerType.createResolver(writerType);\n    return function (tap) { return resolver._read(tap); };\n  } else {\n    return function (tap) { return writerType._read(tap); };\n  }\n}\n\n/** Copy a buffer. This avoids creating a slice of the original buffer. */\nfunction copyBuffer(buf, pos, len) {\n  var copy = utils.newBuffer(len);\n  buf.copy(copy, 0, pos, pos + len);\n  return copy;\n}\n\n\nmodule.exports = {\n  BLOCK_TYPE: BLOCK_TYPE, // For tests.\n  HEADER_TYPE: HEADER_TYPE, // Idem.\n  MAGIC_BYTES: MAGIC_BYTES, // Idem.\n  streams: {\n    BlockDecoder: BlockDecoder,\n    BlockEncoder: BlockEncoder,\n    RawDecoder: RawDecoder,\n    RawEncoder: RawEncoder\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}