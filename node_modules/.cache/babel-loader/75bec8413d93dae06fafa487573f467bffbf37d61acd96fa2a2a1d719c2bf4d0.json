{"ast":null,"code":"/**\n * PKCS1 padding and signature scheme\n */\n\nvar BigInteger = require('../libs/jsbn');\nvar crypt = require('crypto');\nvar constants = require('constants');\nvar SIGN_INFO_HEAD = {\n  md2: Buffer.from('3020300c06082a864886f70d020205000410', 'hex'),\n  md5: Buffer.from('3020300c06082a864886f70d020505000410', 'hex'),\n  sha1: Buffer.from('3021300906052b0e03021a05000414', 'hex'),\n  sha224: Buffer.from('302d300d06096086480165030402040500041c', 'hex'),\n  sha256: Buffer.from('3031300d060960864801650304020105000420', 'hex'),\n  sha384: Buffer.from('3041300d060960864801650304020205000430', 'hex'),\n  sha512: Buffer.from('3051300d060960864801650304020305000440', 'hex'),\n  ripemd160: Buffer.from('3021300906052b2403020105000414', 'hex'),\n  rmd160: Buffer.from('3021300906052b2403020105000414', 'hex')\n};\nvar SIGN_ALG_TO_HASH_ALIASES = {\n  'ripemd160': 'rmd160'\n};\nvar DEFAULT_HASH_FUNCTION = 'sha256';\nmodule.exports = {\n  isEncryption: true,\n  isSignature: true\n};\nmodule.exports.makeScheme = function (key, options) {\n  function Scheme(key, options) {\n    this.key = key;\n    this.options = options;\n  }\n  Scheme.prototype.maxMessageLength = function () {\n    if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {\n      return this.key.encryptedDataLength;\n    }\n    return this.key.encryptedDataLength - 11;\n  };\n\n  /**\n   * Pad input Buffer to encryptedDataLength bytes, and return Buffer.from\n   * alg: PKCS#1\n   * @param buffer\n   * @returns {Buffer}\n   */\n  Scheme.prototype.encPad = function (buffer, options) {\n    options = options || {};\n    var filled;\n    if (buffer.length > this.key.maxMessageLength) {\n      throw new Error(\"Message too long for RSA (n=\" + this.key.encryptedDataLength + \", l=\" + buffer.length + \")\");\n    }\n    if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {\n      //RSA_NO_PADDING treated like JAVA left pad with zero character\n      filled = Buffer.alloc(this.key.maxMessageLength - buffer.length);\n      filled.fill(0);\n      return Buffer.concat([filled, buffer]);\n    }\n\n    /* Type 1: zeros padding for private key encrypt */\n    if (options.type === 1) {\n      filled = Buffer.alloc(this.key.encryptedDataLength - buffer.length - 1);\n      filled.fill(0xff, 0, filled.length - 1);\n      filled[0] = 1;\n      filled[filled.length - 1] = 0;\n      return Buffer.concat([filled, buffer]);\n    } else {\n      /* random padding for public key encrypt */\n      filled = Buffer.alloc(this.key.encryptedDataLength - buffer.length);\n      filled[0] = 0;\n      filled[1] = 2;\n      var rand = crypt.randomBytes(filled.length - 3);\n      for (var i = 0; i < rand.length; i++) {\n        var r = rand[i];\n        while (r === 0) {\n          // non-zero only\n          r = crypt.randomBytes(1)[0];\n        }\n        filled[i + 2] = r;\n      }\n      filled[filled.length - 1] = 0;\n      return Buffer.concat([filled, buffer]);\n    }\n  };\n\n  /**\n   * Unpad input Buffer and, if valid, return the Buffer object\n   * alg: PKCS#1 (type 2, random)\n   * @param buffer\n   * @returns {Buffer}\n   */\n  Scheme.prototype.encUnPad = function (buffer, options) {\n    options = options || {};\n    var i = 0;\n    if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {\n      //RSA_NO_PADDING treated like JAVA left pad with zero character\n      var unPad;\n      if (typeof buffer.lastIndexOf == \"function\") {\n        //patch for old node version\n        unPad = buffer.slice(buffer.lastIndexOf('\\0') + 1, buffer.length);\n      } else {\n        unPad = buffer.slice(String.prototype.lastIndexOf.call(buffer, '\\0') + 1, buffer.length);\n      }\n      return unPad;\n    }\n    if (buffer.length < 4) {\n      return null;\n    }\n\n    /* Type 1: zeros padding for private key decrypt */\n    if (options.type === 1) {\n      if (buffer[0] !== 0 || buffer[1] !== 1) {\n        return null;\n      }\n      i = 3;\n      while (buffer[i] !== 0) {\n        if (buffer[i] != 0xFF || ++i >= buffer.length) {\n          return null;\n        }\n      }\n    } else {\n      /* random padding for public key decrypt */\n      if (buffer[0] !== 0 || buffer[1] !== 2) {\n        return null;\n      }\n      i = 3;\n      while (buffer[i] !== 0) {\n        if (++i >= buffer.length) {\n          return null;\n        }\n      }\n    }\n    return buffer.slice(i + 1, buffer.length);\n  };\n  Scheme.prototype.sign = function (buffer) {\n    var hashAlgorithm = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;\n    if (this.options.environment === 'browser') {\n      hashAlgorithm = SIGN_ALG_TO_HASH_ALIASES[hashAlgorithm] || hashAlgorithm;\n      var hasher = crypt.createHash(hashAlgorithm);\n      hasher.update(buffer);\n      var hash = this.pkcs1pad(hasher.digest(), hashAlgorithm);\n      var res = this.key.$doPrivate(new BigInteger(hash)).toBuffer(this.key.encryptedDataLength);\n      return res;\n    } else {\n      var signer = crypt.createSign('RSA-' + hashAlgorithm.toUpperCase());\n      signer.update(buffer);\n      return signer.sign(this.options.rsaUtils.exportKey('private'));\n    }\n  };\n  Scheme.prototype.verify = function (buffer, signature, signature_encoding) {\n    if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {\n      //RSA_NO_PADDING has no verify data\n      return false;\n    }\n    var hashAlgorithm = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;\n    if (this.options.environment === 'browser') {\n      hashAlgorithm = SIGN_ALG_TO_HASH_ALIASES[hashAlgorithm] || hashAlgorithm;\n      if (signature_encoding) {\n        signature = Buffer.from(signature, signature_encoding);\n      }\n      var hasher = crypt.createHash(hashAlgorithm);\n      hasher.update(buffer);\n      var hash = this.pkcs1pad(hasher.digest(), hashAlgorithm);\n      var m = this.key.$doPublic(new BigInteger(signature));\n      return m.toBuffer().toString('hex') == hash.toString('hex');\n    } else {\n      var verifier = crypt.createVerify('RSA-' + hashAlgorithm.toUpperCase());\n      verifier.update(buffer);\n      return verifier.verify(this.options.rsaUtils.exportKey('public'), signature, signature_encoding);\n    }\n  };\n\n  /**\n   * PKCS#1 zero pad input buffer to max data length\n   * @param hashBuf\n   * @param hashAlgorithm\n   * @returns {*}\n   */\n  Scheme.prototype.pkcs0pad = function (buffer) {\n    var filled = Buffer.alloc(this.key.maxMessageLength - buffer.length);\n    filled.fill(0);\n    return Buffer.concat([filled, buffer]);\n  };\n  Scheme.prototype.pkcs0unpad = function (buffer) {\n    var unPad;\n    if (typeof buffer.lastIndexOf == \"function\") {\n      //patch for old node version\n      unPad = buffer.slice(buffer.lastIndexOf('\\0') + 1, buffer.length);\n    } else {\n      unPad = buffer.slice(String.prototype.lastIndexOf.call(buffer, '\\0') + 1, buffer.length);\n    }\n    return unPad;\n  };\n\n  /**\n   * PKCS#1 pad input buffer to max data length\n   * @param hashBuf\n   * @param hashAlgorithm\n   * @returns {*}\n   */\n  Scheme.prototype.pkcs1pad = function (hashBuf, hashAlgorithm) {\n    var digest = SIGN_INFO_HEAD[hashAlgorithm];\n    if (!digest) {\n      throw Error('Unsupported hash algorithm');\n    }\n    var data = Buffer.concat([digest, hashBuf]);\n    if (data.length + 10 > this.key.encryptedDataLength) {\n      throw Error('Key is too short for signing algorithm (' + hashAlgorithm + ')');\n    }\n    var filled = Buffer.alloc(this.key.encryptedDataLength - data.length - 1);\n    filled.fill(0xff, 0, filled.length - 1);\n    filled[0] = 1;\n    filled[filled.length - 1] = 0;\n    var res = Buffer.concat([filled, data]);\n    return res;\n  };\n  return new Scheme(key, options);\n};","map":{"version":3,"names":["BigInteger","require","crypt","constants","SIGN_INFO_HEAD","md2","Buffer","from","md5","sha1","sha224","sha256","sha384","sha512","ripemd160","rmd160","SIGN_ALG_TO_HASH_ALIASES","DEFAULT_HASH_FUNCTION","module","exports","isEncryption","isSignature","makeScheme","key","options","Scheme","prototype","maxMessageLength","encryptionSchemeOptions","padding","RSA_NO_PADDING","encryptedDataLength","encPad","buffer","filled","length","Error","alloc","fill","concat","type","rand","randomBytes","i","r","encUnPad","unPad","lastIndexOf","slice","String","call","sign","hashAlgorithm","signingSchemeOptions","hash","environment","hasher","createHash","update","pkcs1pad","digest","res","$doPrivate","toBuffer","signer","createSign","toUpperCase","rsaUtils","exportKey","verify","signature","signature_encoding","m","$doPublic","toString","verifier","createVerify","pkcs0pad","pkcs0unpad","hashBuf","data"],"sources":["E:/Amanda-project/vue2-project/project-vue2/node_modules/node-rsa/src/schemes/pkcs1.js"],"sourcesContent":["/**\n * PKCS1 padding and signature scheme\n */\n\nvar BigInteger = require('../libs/jsbn');\nvar crypt = require('crypto');\nvar constants = require('constants');\nvar SIGN_INFO_HEAD = {\n    md2: Buffer.from('3020300c06082a864886f70d020205000410', 'hex'),\n    md5: Buffer.from('3020300c06082a864886f70d020505000410', 'hex'),\n    sha1: Buffer.from('3021300906052b0e03021a05000414', 'hex'),\n    sha224: Buffer.from('302d300d06096086480165030402040500041c', 'hex'),\n    sha256: Buffer.from('3031300d060960864801650304020105000420', 'hex'),\n    sha384: Buffer.from('3041300d060960864801650304020205000430', 'hex'),\n    sha512: Buffer.from('3051300d060960864801650304020305000440', 'hex'),\n    ripemd160: Buffer.from('3021300906052b2403020105000414', 'hex'),\n    rmd160: Buffer.from('3021300906052b2403020105000414', 'hex')\n};\n\nvar SIGN_ALG_TO_HASH_ALIASES = {\n    'ripemd160': 'rmd160'\n};\n\nvar DEFAULT_HASH_FUNCTION = 'sha256';\n\nmodule.exports = {\n    isEncryption: true,\n    isSignature: true\n};\n\nmodule.exports.makeScheme = function (key, options) {\n    function Scheme(key, options) {\n        this.key = key;\n        this.options = options;\n    }\n\n    Scheme.prototype.maxMessageLength = function () {\n        if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {\n            return this.key.encryptedDataLength;\n        }\n        return this.key.encryptedDataLength - 11;\n    };\n\n    /**\n     * Pad input Buffer to encryptedDataLength bytes, and return Buffer.from\n     * alg: PKCS#1\n     * @param buffer\n     * @returns {Buffer}\n     */\n    Scheme.prototype.encPad = function (buffer, options) {\n        options = options || {};\n        var filled;\n        if (buffer.length > this.key.maxMessageLength) {\n            throw new Error(\"Message too long for RSA (n=\" + this.key.encryptedDataLength + \", l=\" + buffer.length + \")\");\n        }\n        if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {\n            //RSA_NO_PADDING treated like JAVA left pad with zero character\n            filled = Buffer.alloc(this.key.maxMessageLength - buffer.length);\n            filled.fill(0);\n            return Buffer.concat([filled, buffer]);\n        }\n\n        /* Type 1: zeros padding for private key encrypt */\n        if (options.type === 1) {\n            filled = Buffer.alloc(this.key.encryptedDataLength - buffer.length - 1);\n            filled.fill(0xff, 0, filled.length - 1);\n            filled[0] = 1;\n            filled[filled.length - 1] = 0;\n\n            return Buffer.concat([filled, buffer]);\n        } else {\n            /* random padding for public key encrypt */\n            filled = Buffer.alloc(this.key.encryptedDataLength - buffer.length);\n            filled[0] = 0;\n            filled[1] = 2;\n            var rand = crypt.randomBytes(filled.length - 3);\n            for (var i = 0; i < rand.length; i++) {\n                var r = rand[i];\n                while (r === 0) { // non-zero only\n                    r = crypt.randomBytes(1)[0];\n                }\n                filled[i + 2] = r;\n            }\n            filled[filled.length - 1] = 0;\n            return Buffer.concat([filled, buffer]);\n        }\n    };\n\n    /**\n     * Unpad input Buffer and, if valid, return the Buffer object\n     * alg: PKCS#1 (type 2, random)\n     * @param buffer\n     * @returns {Buffer}\n     */\n    Scheme.prototype.encUnPad = function (buffer, options) {\n        options = options || {};\n        var i = 0;\n\n        if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {\n            //RSA_NO_PADDING treated like JAVA left pad with zero character\n            var unPad;\n            if (typeof buffer.lastIndexOf == \"function\") { //patch for old node version\n                unPad = buffer.slice(buffer.lastIndexOf('\\0') + 1, buffer.length);\n            } else {\n                unPad = buffer.slice(String.prototype.lastIndexOf.call(buffer, '\\0') + 1, buffer.length);\n            }\n            return unPad;\n        }\n\n        if (buffer.length < 4) {\n            return null;\n        }\n\n        /* Type 1: zeros padding for private key decrypt */\n        if (options.type === 1) {\n            if (buffer[0] !== 0 || buffer[1] !== 1) {\n                return null;\n            }\n            i = 3;\n            while (buffer[i] !== 0) {\n                if (buffer[i] != 0xFF || ++i >= buffer.length) {\n                    return null;\n                }\n            }\n        } else {\n            /* random padding for public key decrypt */\n            if (buffer[0] !== 0 || buffer[1] !== 2) {\n                return null;\n            }\n            i = 3;\n            while (buffer[i] !== 0) {\n                if (++i >= buffer.length) {\n                    return null;\n                }\n            }\n        }\n        return buffer.slice(i + 1, buffer.length);\n    };\n\n    Scheme.prototype.sign = function (buffer) {\n        var hashAlgorithm = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;\n        if (this.options.environment === 'browser') {\n            hashAlgorithm = SIGN_ALG_TO_HASH_ALIASES[hashAlgorithm] || hashAlgorithm;\n\n            var hasher = crypt.createHash(hashAlgorithm);\n            hasher.update(buffer);\n            var hash = this.pkcs1pad(hasher.digest(), hashAlgorithm);\n            var res = this.key.$doPrivate(new BigInteger(hash)).toBuffer(this.key.encryptedDataLength);\n\n            return res;\n        } else {\n            var signer = crypt.createSign('RSA-' + hashAlgorithm.toUpperCase());\n            signer.update(buffer);\n            return signer.sign(this.options.rsaUtils.exportKey('private'));\n        }\n    };\n\n    Scheme.prototype.verify = function (buffer, signature, signature_encoding) {\n        if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {\n            //RSA_NO_PADDING has no verify data\n            return false;\n        }\n        var hashAlgorithm = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;\n        if (this.options.environment === 'browser') {\n            hashAlgorithm = SIGN_ALG_TO_HASH_ALIASES[hashAlgorithm] || hashAlgorithm;\n\n            if (signature_encoding) {\n                signature = Buffer.from(signature, signature_encoding);\n            }\n\n            var hasher = crypt.createHash(hashAlgorithm);\n            hasher.update(buffer);\n            var hash = this.pkcs1pad(hasher.digest(), hashAlgorithm);\n            var m = this.key.$doPublic(new BigInteger(signature));\n\n            return m.toBuffer().toString('hex') == hash.toString('hex');\n        } else {\n            var verifier = crypt.createVerify('RSA-' + hashAlgorithm.toUpperCase());\n            verifier.update(buffer);\n            return verifier.verify(this.options.rsaUtils.exportKey('public'), signature, signature_encoding);\n        }\n    };\n\n    /**\n     * PKCS#1 zero pad input buffer to max data length\n     * @param hashBuf\n     * @param hashAlgorithm\n     * @returns {*}\n     */\n    Scheme.prototype.pkcs0pad = function (buffer) {\n        var filled = Buffer.alloc(this.key.maxMessageLength - buffer.length);\n        filled.fill(0);\n        return Buffer.concat([filled, buffer]);\n    };\n\n    Scheme.prototype.pkcs0unpad = function (buffer) {\n        var unPad;\n        if (typeof buffer.lastIndexOf == \"function\") { //patch for old node version\n            unPad = buffer.slice(buffer.lastIndexOf('\\0') + 1, buffer.length);\n        } else {\n            unPad = buffer.slice(String.prototype.lastIndexOf.call(buffer, '\\0') + 1, buffer.length);\n        }\n\n        return unPad;\n    };\n\n    /**\n     * PKCS#1 pad input buffer to max data length\n     * @param hashBuf\n     * @param hashAlgorithm\n     * @returns {*}\n     */\n    Scheme.prototype.pkcs1pad = function (hashBuf, hashAlgorithm) {\n        var digest = SIGN_INFO_HEAD[hashAlgorithm];\n        if (!digest) {\n            throw Error('Unsupported hash algorithm');\n        }\n\n        var data = Buffer.concat([digest, hashBuf]);\n\n        if (data.length + 10 > this.key.encryptedDataLength) {\n            throw Error('Key is too short for signing algorithm (' + hashAlgorithm + ')');\n        }\n\n        var filled = Buffer.alloc(this.key.encryptedDataLength - data.length - 1);\n        filled.fill(0xff, 0, filled.length - 1);\n        filled[0] = 1;\n        filled[filled.length - 1] = 0;\n\n        var res = Buffer.concat([filled, data]);\n\n        return res;\n    };\n\n    return new Scheme(key, options);\n};\n\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}