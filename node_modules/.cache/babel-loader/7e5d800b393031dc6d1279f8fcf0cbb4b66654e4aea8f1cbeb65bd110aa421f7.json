{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Account = void 0;\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst depd_1 = __importDefault(require(\"depd\"));\nconst transaction_1 = require(\"./transaction\");\nconst providers_1 = require(\"./providers\");\nconst borsh_1 = require(\"borsh\");\nconst key_pair_1 = require(\"./utils/key_pair\");\nconst errors_1 = require(\"./utils/errors\");\nconst rpc_errors_1 = require(\"./utils/rpc_errors\");\nconst constants_1 = require(\"./constants\");\nconst exponential_backoff_1 = __importDefault(require(\"./utils/exponential-backoff\"));\n// Default number of retries with different nonce before giving up on a transaction.\nconst TX_NONCE_RETRY_NUMBER = 12;\n// Default wait until next retry in millis.\nconst TX_NONCE_RETRY_WAIT = 500;\n// Exponential back off for waiting to retry.\nconst TX_NONCE_RETRY_WAIT_BACKOFF = 1.5;\nfunction parseJsonFromRawResponse(response) {\n  return JSON.parse(Buffer.from(response).toString());\n}\nfunction bytesJsonStringify(input) {\n  return Buffer.from(JSON.stringify(input));\n}\n/**\n * This class provides common account related RPC calls including signing transactions with a {@link KeyPair}.\n *\n * @example {@link https://docs.near.org/docs/develop/front-end/naj-quick-reference#account}\n * @hint Use {@link WalletConnection} in the browser to redirect to {@link https://docs.near.org/docs/tools/near-wallet | NEAR Wallet} for Account/key management using the {@link BrowserLocalStorageKeyStore}.\n * @see {@link https://nomicon.io/DataStructures/Account.html | Account Spec}\n */\nclass Account {\n  constructor(connection, accountId) {\n    /** @hidden */\n    this.accessKeyByPublicKeyCache = {};\n    this.connection = connection;\n    this.accountId = accountId;\n  }\n  /** @hidden */\n  get ready() {\n    const deprecate = depd_1.default('Account.ready()');\n    deprecate('not needed anymore, always ready');\n    return Promise.resolve();\n  }\n  async fetchState() {\n    const deprecate = depd_1.default('Account.fetchState()');\n    deprecate('use `Account.state()` instead');\n  }\n  /**\n   * Returns basic NEAR account information via the `view_account` RPC query method\n   * @see {@link https://docs.near.org/docs/develop/front-end/rpc#view-account}\n   */\n  async state() {\n    return this.connection.provider.query({\n      request_type: 'view_account',\n      account_id: this.accountId,\n      finality: 'optimistic'\n    });\n  }\n  /** @hidden */\n  printLogsAndFailures(contractId, results) {\n    if (!process.env[\"NEAR_NO_LOGS\"]) {\n      for (const result of results) {\n        console.log(`Receipt${result.receiptIds.length > 1 ? 's' : ''}: ${result.receiptIds.join(', ')}`);\n        this.printLogs(contractId, result.logs, '\\t');\n        if (result.failure) {\n          console.warn(`\\tFailure [${contractId}]: ${result.failure}`);\n        }\n      }\n    }\n  }\n  /** @hidden */\n  printLogs(contractId, logs, prefix = '') {\n    if (!process.env[\"NEAR_NO_LOGS\"]) {\n      for (const log of logs) {\n        console.log(`${prefix}Log [${contractId}]: ${log}`);\n      }\n    }\n  }\n  /**\n   * Create a signed transaction which can be broadcast to the network\n   * @param receiverId NEAR account receiving the transaction\n   * @param actions list of actions to perform as part of the transaction\n   * @see {@link JsonRpcProvider.sendTransaction}\n   */\n  async signTransaction(receiverId, actions) {\n    const accessKeyInfo = await this.findAccessKey(receiverId, actions);\n    if (!accessKeyInfo) {\n      throw new providers_1.TypedError(`Can not sign transactions for account ${this.accountId} on network ${this.connection.networkId}, no matching key pair found in ${this.connection.signer}.`, 'KeyNotFound');\n    }\n    const {\n      accessKey\n    } = accessKeyInfo;\n    const block = await this.connection.provider.block({\n      finality: 'final'\n    });\n    const blockHash = block.header.hash;\n    const nonce = ++accessKey.nonce;\n    return await transaction_1.signTransaction(receiverId, nonce, actions, borsh_1.baseDecode(blockHash), this.connection.signer, this.accountId, this.connection.networkId);\n  }\n  signAndSendTransaction(...args) {\n    if (typeof args[0] === 'string') {\n      return this.signAndSendTransactionV1(args[0], args[1]);\n    } else {\n      return this.signAndSendTransactionV2(args[0]);\n    }\n  }\n  signAndSendTransactionV1(receiverId, actions) {\n    const deprecate = depd_1.default('Account.signAndSendTransaction(receiverId, actions');\n    deprecate('use `Account.signAndSendTransaction(SignAndSendTransactionOptions)` instead');\n    return this.signAndSendTransactionV2({\n      receiverId,\n      actions\n    });\n  }\n  async signAndSendTransactionV2({\n    receiverId,\n    actions,\n    returnError\n  }) {\n    let txHash, signedTx;\n    // TODO: TX_NONCE (different constants for different uses of exponentialBackoff?)\n    const result = await exponential_backoff_1.default(TX_NONCE_RETRY_WAIT, TX_NONCE_RETRY_NUMBER, TX_NONCE_RETRY_WAIT_BACKOFF, async () => {\n      [txHash, signedTx] = await this.signTransaction(receiverId, actions);\n      const publicKey = signedTx.transaction.publicKey;\n      try {\n        return await this.connection.provider.sendTransaction(signedTx);\n      } catch (error) {\n        if (error.type === 'InvalidNonce') {\n          errors_1.logWarning(`Retrying transaction ${receiverId}:${borsh_1.baseEncode(txHash)} with new nonce.`);\n          delete this.accessKeyByPublicKeyCache[publicKey.toString()];\n          return null;\n        }\n        if (error.type === 'Expired') {\n          errors_1.logWarning(`Retrying transaction ${receiverId}:${borsh_1.baseEncode(txHash)} due to expired block hash`);\n          return null;\n        }\n        error.context = new providers_1.ErrorContext(borsh_1.baseEncode(txHash));\n        throw error;\n      }\n    });\n    if (!result) {\n      // TODO: This should have different code actually, as means \"transaction not submitted for sure\"\n      throw new providers_1.TypedError('nonce retries exceeded for transaction. This usually means there are too many parallel requests with the same access key.', 'RetriesExceeded');\n    }\n    const flatLogs = [result.transaction_outcome, ...result.receipts_outcome].reduce((acc, it) => {\n      if (it.outcome.logs.length || typeof it.outcome.status === 'object' && typeof it.outcome.status.Failure === 'object') {\n        return acc.concat({\n          'receiptIds': it.outcome.receipt_ids,\n          'logs': it.outcome.logs,\n          'failure': typeof it.outcome.status.Failure != 'undefined' ? rpc_errors_1.parseRpcError(it.outcome.status.Failure) : null\n        });\n      } else return acc;\n    }, []);\n    this.printLogsAndFailures(signedTx.transaction.receiverId, flatLogs);\n    if (!returnError && typeof result.status === 'object' && typeof result.status.Failure === 'object') {\n      // if error data has error_message and error_type properties, we consider that node returned an error in the old format\n      if (result.status.Failure.error_message && result.status.Failure.error_type) {\n        throw new providers_1.TypedError(`Transaction ${result.transaction_outcome.id} failed. ${result.status.Failure.error_message}`, result.status.Failure.error_type);\n      } else {\n        throw rpc_errors_1.parseResultError(result);\n      }\n    }\n    // TODO: if Tx is Unknown or Started.\n    return result;\n  }\n  /**\n   * Finds the {@link AccessKeyView} associated with the accounts {@link PublicKey} stored in the {@link KeyStore}.\n   *\n   * @todo Find matching access key based on transaction (i.e. receiverId and actions)\n   *\n   * @param receiverId currently unused (see todo)\n   * @param actions currently unused (see todo)\n   * @returns `{ publicKey PublicKey; accessKey: AccessKeyView }`\n   */\n  async findAccessKey(receiverId, actions) {\n    // TODO: Find matching access key based on transaction (i.e. receiverId and actions)\n    const publicKey = await this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);\n    if (!publicKey) {\n      return null;\n    }\n    const cachedAccessKey = this.accessKeyByPublicKeyCache[publicKey.toString()];\n    if (cachedAccessKey !== undefined) {\n      return {\n        publicKey,\n        accessKey: cachedAccessKey\n      };\n    }\n    try {\n      const accessKey = await this.connection.provider.query({\n        request_type: 'view_access_key',\n        account_id: this.accountId,\n        public_key: publicKey.toString(),\n        finality: 'optimistic'\n      });\n      // this function can be called multiple times and retrieve the same access key\n      // this checks to see if the access key was already retrieved and cached while\n      // the above network call was in flight. To keep nonce values in line, we return\n      // the cached access key.\n      if (this.accessKeyByPublicKeyCache[publicKey.toString()]) {\n        return {\n          publicKey,\n          accessKey: this.accessKeyByPublicKeyCache[publicKey.toString()]\n        };\n      }\n      this.accessKeyByPublicKeyCache[publicKey.toString()] = accessKey;\n      return {\n        publicKey,\n        accessKey\n      };\n    } catch (e) {\n      if (e.type == 'AccessKeyDoesNotExist') {\n        return null;\n      }\n      throw e;\n    }\n  }\n  /**\n   * Create a new account and deploy a contract to it\n   *\n   * @param contractId NEAR account where the contract is deployed\n   * @param publicKey The public key to add to the created contract account\n   * @param data The compiled contract code\n   * @param amount of NEAR to transfer to the created contract account. Transfer enough to pay for storage https://docs.near.org/docs/concepts/storage-staking\n   */\n  async createAndDeployContract(contractId, publicKey, data, amount) {\n    const accessKey = transaction_1.fullAccessKey();\n    await this.signAndSendTransaction({\n      receiverId: contractId,\n      actions: [transaction_1.createAccount(), transaction_1.transfer(amount), transaction_1.addKey(key_pair_1.PublicKey.from(publicKey), accessKey), transaction_1.deployContract(data)]\n    });\n    const contractAccount = new Account(this.connection, contractId);\n    return contractAccount;\n  }\n  /**\n   * @param receiverId NEAR account receiving Ⓝ\n   * @param amount Amount to send in yoctoⓃ\n   */\n  async sendMoney(receiverId, amount) {\n    return this.signAndSendTransaction({\n      receiverId,\n      actions: [transaction_1.transfer(amount)]\n    });\n  }\n  /**\n   * @param newAccountId NEAR account name to be created\n   * @param publicKey A public key created from the masterAccount\n   */\n  async createAccount(newAccountId, publicKey, amount) {\n    const accessKey = transaction_1.fullAccessKey();\n    return this.signAndSendTransaction({\n      receiverId: newAccountId,\n      actions: [transaction_1.createAccount(), transaction_1.transfer(amount), transaction_1.addKey(key_pair_1.PublicKey.from(publicKey), accessKey)]\n    });\n  }\n  /**\n   * @param beneficiaryId The NEAR account that will receive the remaining Ⓝ balance from the account being deleted\n   */\n  async deleteAccount(beneficiaryId) {\n    return this.signAndSendTransaction({\n      receiverId: this.accountId,\n      actions: [transaction_1.deleteAccount(beneficiaryId)]\n    });\n  }\n  /**\n   * @param data The compiled contract code\n   */\n  async deployContract(data) {\n    return this.signAndSendTransaction({\n      receiverId: this.accountId,\n      actions: [transaction_1.deployContract(data)]\n    });\n  }\n  async functionCall(...args) {\n    if (typeof args[0] === 'string') {\n      return this.functionCallV1(args[0], args[1], args[2], args[3], args[4]);\n    } else {\n      return this.functionCallV2(args[0]);\n    }\n  }\n  functionCallV1(contractId, methodName, args, gas, amount) {\n    const deprecate = depd_1.default('Account.functionCall(contractId, methodName, args, gas, amount)');\n    deprecate('use `Account.functionCall(FunctionCallOptions)` instead');\n    args = args || {};\n    this.validateArgs(args);\n    return this.signAndSendTransaction({\n      receiverId: contractId,\n      actions: [transaction_1.functionCall(methodName, args, gas || constants_1.DEFAULT_FUNCTION_CALL_GAS, amount)]\n    });\n  }\n  functionCallV2({\n    contractId,\n    methodName,\n    args = {},\n    gas = constants_1.DEFAULT_FUNCTION_CALL_GAS,\n    attachedDeposit,\n    walletMeta,\n    walletCallbackUrl,\n    stringify\n  }) {\n    this.validateArgs(args);\n    const stringifyArg = stringify === undefined ? transaction_1.stringifyJsonOrBytes : stringify;\n    return this.signAndSendTransaction({\n      receiverId: contractId,\n      actions: [transaction_1.functionCall(methodName, args, gas, attachedDeposit, stringifyArg)],\n      walletMeta,\n      walletCallbackUrl\n    });\n  }\n  /**\n   * @see {@link https://docs.near.org/docs/concepts/account#access-keys}\n   * @todo expand this API to support more options.\n   * @param publicKey A public key to be associated with the contract\n   * @param contractId NEAR account where the contract is deployed\n   * @param methodNames The method names on the contract that should be allowed to be called. Pass null for no method names and '' or [] for any method names.\n   * @param amount Payment in yoctoⓃ that is sent to the contract during this function call\n   */\n  async addKey(publicKey, contractId, methodNames, amount) {\n    if (!methodNames) {\n      methodNames = [];\n    }\n    if (!Array.isArray(methodNames)) {\n      methodNames = [methodNames];\n    }\n    let accessKey;\n    if (!contractId) {\n      accessKey = transaction_1.fullAccessKey();\n    } else {\n      accessKey = transaction_1.functionCallAccessKey(contractId, methodNames, amount);\n    }\n    return this.signAndSendTransaction({\n      receiverId: this.accountId,\n      actions: [transaction_1.addKey(key_pair_1.PublicKey.from(publicKey), accessKey)]\n    });\n  }\n  /**\n   * @param publicKey The public key to be deleted\n   * @returns {Promise<FinalExecutionOutcome>}\n   */\n  async deleteKey(publicKey) {\n    return this.signAndSendTransaction({\n      receiverId: this.accountId,\n      actions: [transaction_1.deleteKey(key_pair_1.PublicKey.from(publicKey))]\n    });\n  }\n  /**\n   * @see {@link https://docs.near.org/docs/validator/staking-overview}\n   *\n   * @param publicKey The public key for the account that's staking\n   * @param amount The account to stake in yoctoⓃ\n   */\n  async stake(publicKey, amount) {\n    return this.signAndSendTransaction({\n      receiverId: this.accountId,\n      actions: [transaction_1.stake(amount, key_pair_1.PublicKey.from(publicKey))]\n    });\n  }\n  /** @hidden */\n  validateArgs(args) {\n    const isUint8Array = args.byteLength !== undefined && args.byteLength === args.length;\n    if (isUint8Array) {\n      return;\n    }\n    if (Array.isArray(args) || typeof args !== 'object') {\n      throw new errors_1.PositionalArgsError();\n    }\n  }\n  /**\n   * Invoke a contract view function using the RPC API.\n   * @see {@link https://docs.near.org/docs/develop/front-end/rpc#call-a-contract-function}\n   *\n   * @param contractId NEAR account where the contract is deployed\n   * @param methodName The view-only method (no state mutations) name on the contract as it is written in the contract code\n   * @param args Any arguments to the view contract method, wrapped in JSON\n   * @param options.parse Parse the result of the call. Receives a Buffer (bytes array) and converts it to any object. By default result will be treated as json.\n   * @param options.stringify Convert input arguments into a bytes array. By default the input is treated as a JSON.\n   * @returns {Promise<any>}\n   */\n  async viewFunction(contractId, methodName, args = {}, {\n    parse = parseJsonFromRawResponse,\n    stringify = bytesJsonStringify\n  } = {}) {\n    this.validateArgs(args);\n    const serializedArgs = stringify(args).toString('base64');\n    const result = await this.connection.provider.query({\n      request_type: 'call_function',\n      account_id: contractId,\n      method_name: methodName,\n      args_base64: serializedArgs,\n      finality: 'optimistic'\n    });\n    if (result.logs) {\n      this.printLogs(contractId, result.logs);\n    }\n    return result.result && result.result.length > 0 && parse(Buffer.from(result.result));\n  }\n  /**\n   * Returns the state (key value pairs) of this account's contract based on the key prefix.\n   * Pass an empty string for prefix if you would like to return the entire state.\n   * @see {@link https://docs.near.org/docs/develop/front-end/rpc#view-contract-state}\n   *\n   * @param prefix allows to filter which keys should be returned. Empty prefix means all keys. String prefix is utf-8 encoded.\n   * @param blockQuery specifies which block to query state at. By default returns last \"optimistic\" block (i.e. not necessarily finalized).\n   */\n  async viewState(prefix, blockQuery = {\n    finality: 'optimistic'\n  }) {\n    const {\n      values\n    } = await this.connection.provider.query({\n      request_type: 'view_state',\n      ...blockQuery,\n      account_id: this.accountId,\n      prefix_base64: Buffer.from(prefix).toString('base64')\n    });\n    return values.map(({\n      key,\n      value\n    }) => ({\n      key: Buffer.from(key, 'base64'),\n      value: Buffer.from(value, 'base64')\n    }));\n  }\n  /**\n   * Get all access keys for the account\n   * @see {@link https://docs.near.org/docs/develop/front-end/rpc#view-access-key-list}\n   */\n  async getAccessKeys() {\n    const response = await this.connection.provider.query({\n      request_type: 'view_access_key_list',\n      account_id: this.accountId,\n      finality: 'optimistic'\n    });\n    // A breaking API change introduced extra information into the\n    // response, so it now returns an object with a `keys` field instead\n    // of an array: https://github.com/nearprotocol/nearcore/pull/1789\n    if (Array.isArray(response)) {\n      return response;\n    }\n    return response.keys;\n  }\n  /**\n   * Returns a list of authorized apps\n   * @todo update the response value to return all the different keys, not just app keys.\n   */\n  async getAccountDetails() {\n    // TODO: update the response value to return all the different keys, not just app keys.\n    // Also if we need this function, or getAccessKeys is good enough.\n    const accessKeys = await this.getAccessKeys();\n    const authorizedApps = accessKeys.filter(item => item.access_key.permission !== 'FullAccess').map(item => {\n      const perm = item.access_key.permission;\n      return {\n        contractId: perm.FunctionCall.receiver_id,\n        amount: perm.FunctionCall.allowance,\n        publicKey: item.public_key\n      };\n    });\n    return {\n      authorizedApps\n    };\n  }\n  /**\n   * Returns calculated account balance\n   */\n  async getAccountBalance() {\n    const protocolConfig = await this.connection.provider.experimental_protocolConfig({\n      finality: 'final'\n    });\n    const state = await this.state();\n    const costPerByte = new bn_js_1.default(protocolConfig.runtime_config.storage_amount_per_byte);\n    const stateStaked = new bn_js_1.default(state.storage_usage).mul(costPerByte);\n    const staked = new bn_js_1.default(state.locked);\n    const totalBalance = new bn_js_1.default(state.amount).add(staked);\n    const availableBalance = totalBalance.sub(bn_js_1.default.max(staked, stateStaked));\n    return {\n      total: totalBalance.toString(),\n      stateStaked: stateStaked.toString(),\n      staked: staked.toString(),\n      available: availableBalance.toString()\n    };\n  }\n}\nexports.Account = Account;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","Account","bn_js_1","require","depd_1","transaction_1","providers_1","borsh_1","key_pair_1","errors_1","rpc_errors_1","constants_1","exponential_backoff_1","TX_NONCE_RETRY_NUMBER","TX_NONCE_RETRY_WAIT","TX_NONCE_RETRY_WAIT_BACKOFF","parseJsonFromRawResponse","response","JSON","parse","Buffer","from","toString","bytesJsonStringify","input","stringify","constructor","connection","accountId","accessKeyByPublicKeyCache","ready","deprecate","default","Promise","resolve","fetchState","state","provider","query","request_type","account_id","finality","printLogsAndFailures","contractId","results","process","env","result","console","log","receiptIds","length","join","printLogs","logs","failure","warn","prefix","signTransaction","receiverId","actions","accessKeyInfo","findAccessKey","TypedError","networkId","signer","accessKey","block","blockHash","header","hash","nonce","baseDecode","signAndSendTransaction","args","signAndSendTransactionV1","signAndSendTransactionV2","returnError","txHash","signedTx","publicKey","transaction","sendTransaction","error","type","logWarning","baseEncode","context","ErrorContext","flatLogs","transaction_outcome","receipts_outcome","reduce","acc","it","outcome","status","Failure","concat","receipt_ids","parseRpcError","error_message","error_type","id","parseResultError","getPublicKey","cachedAccessKey","undefined","public_key","e","createAndDeployContract","data","amount","fullAccessKey","createAccount","transfer","addKey","PublicKey","deployContract","contractAccount","sendMoney","newAccountId","deleteAccount","beneficiaryId","functionCall","functionCallV1","functionCallV2","methodName","gas","validateArgs","DEFAULT_FUNCTION_CALL_GAS","attachedDeposit","walletMeta","walletCallbackUrl","stringifyArg","stringifyJsonOrBytes","methodNames","Array","isArray","functionCallAccessKey","deleteKey","stake","isUint8Array","byteLength","PositionalArgsError","viewFunction","serializedArgs","method_name","args_base64","viewState","blockQuery","values","prefix_base64","map","key","getAccessKeys","keys","getAccountDetails","accessKeys","authorizedApps","filter","item","access_key","permission","perm","FunctionCall","receiver_id","allowance","getAccountBalance","protocolConfig","experimental_protocolConfig","costPerByte","runtime_config","storage_amount_per_byte","stateStaked","storage_usage","mul","staked","locked","totalBalance","add","availableBalance","sub","max","total","available"],"sources":["E:/Amanda-project/vue2-project/project-vue2/node_modules/near-api-js/lib/account.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Account = void 0;\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst depd_1 = __importDefault(require(\"depd\"));\nconst transaction_1 = require(\"./transaction\");\nconst providers_1 = require(\"./providers\");\nconst borsh_1 = require(\"borsh\");\nconst key_pair_1 = require(\"./utils/key_pair\");\nconst errors_1 = require(\"./utils/errors\");\nconst rpc_errors_1 = require(\"./utils/rpc_errors\");\nconst constants_1 = require(\"./constants\");\nconst exponential_backoff_1 = __importDefault(require(\"./utils/exponential-backoff\"));\n// Default number of retries with different nonce before giving up on a transaction.\nconst TX_NONCE_RETRY_NUMBER = 12;\n// Default wait until next retry in millis.\nconst TX_NONCE_RETRY_WAIT = 500;\n// Exponential back off for waiting to retry.\nconst TX_NONCE_RETRY_WAIT_BACKOFF = 1.5;\nfunction parseJsonFromRawResponse(response) {\n    return JSON.parse(Buffer.from(response).toString());\n}\nfunction bytesJsonStringify(input) {\n    return Buffer.from(JSON.stringify(input));\n}\n/**\n * This class provides common account related RPC calls including signing transactions with a {@link KeyPair}.\n *\n * @example {@link https://docs.near.org/docs/develop/front-end/naj-quick-reference#account}\n * @hint Use {@link WalletConnection} in the browser to redirect to {@link https://docs.near.org/docs/tools/near-wallet | NEAR Wallet} for Account/key management using the {@link BrowserLocalStorageKeyStore}.\n * @see {@link https://nomicon.io/DataStructures/Account.html | Account Spec}\n */\nclass Account {\n    constructor(connection, accountId) {\n        /** @hidden */\n        this.accessKeyByPublicKeyCache = {};\n        this.connection = connection;\n        this.accountId = accountId;\n    }\n    /** @hidden */\n    get ready() {\n        const deprecate = depd_1.default('Account.ready()');\n        deprecate('not needed anymore, always ready');\n        return Promise.resolve();\n    }\n    async fetchState() {\n        const deprecate = depd_1.default('Account.fetchState()');\n        deprecate('use `Account.state()` instead');\n    }\n    /**\n     * Returns basic NEAR account information via the `view_account` RPC query method\n     * @see {@link https://docs.near.org/docs/develop/front-end/rpc#view-account}\n     */\n    async state() {\n        return this.connection.provider.query({\n            request_type: 'view_account',\n            account_id: this.accountId,\n            finality: 'optimistic'\n        });\n    }\n    /** @hidden */\n    printLogsAndFailures(contractId, results) {\n        if (!process.env[\"NEAR_NO_LOGS\"]) {\n            for (const result of results) {\n                console.log(`Receipt${result.receiptIds.length > 1 ? 's' : ''}: ${result.receiptIds.join(', ')}`);\n                this.printLogs(contractId, result.logs, '\\t');\n                if (result.failure) {\n                    console.warn(`\\tFailure [${contractId}]: ${result.failure}`);\n                }\n            }\n        }\n    }\n    /** @hidden */\n    printLogs(contractId, logs, prefix = '') {\n        if (!process.env[\"NEAR_NO_LOGS\"]) {\n            for (const log of logs) {\n                console.log(`${prefix}Log [${contractId}]: ${log}`);\n            }\n        }\n    }\n    /**\n     * Create a signed transaction which can be broadcast to the network\n     * @param receiverId NEAR account receiving the transaction\n     * @param actions list of actions to perform as part of the transaction\n     * @see {@link JsonRpcProvider.sendTransaction}\n     */\n    async signTransaction(receiverId, actions) {\n        const accessKeyInfo = await this.findAccessKey(receiverId, actions);\n        if (!accessKeyInfo) {\n            throw new providers_1.TypedError(`Can not sign transactions for account ${this.accountId} on network ${this.connection.networkId}, no matching key pair found in ${this.connection.signer}.`, 'KeyNotFound');\n        }\n        const { accessKey } = accessKeyInfo;\n        const block = await this.connection.provider.block({ finality: 'final' });\n        const blockHash = block.header.hash;\n        const nonce = ++accessKey.nonce;\n        return await transaction_1.signTransaction(receiverId, nonce, actions, borsh_1.baseDecode(blockHash), this.connection.signer, this.accountId, this.connection.networkId);\n    }\n    signAndSendTransaction(...args) {\n        if (typeof args[0] === 'string') {\n            return this.signAndSendTransactionV1(args[0], args[1]);\n        }\n        else {\n            return this.signAndSendTransactionV2(args[0]);\n        }\n    }\n    signAndSendTransactionV1(receiverId, actions) {\n        const deprecate = depd_1.default('Account.signAndSendTransaction(receiverId, actions');\n        deprecate('use `Account.signAndSendTransaction(SignAndSendTransactionOptions)` instead');\n        return this.signAndSendTransactionV2({ receiverId, actions });\n    }\n    async signAndSendTransactionV2({ receiverId, actions, returnError }) {\n        let txHash, signedTx;\n        // TODO: TX_NONCE (different constants for different uses of exponentialBackoff?)\n        const result = await exponential_backoff_1.default(TX_NONCE_RETRY_WAIT, TX_NONCE_RETRY_NUMBER, TX_NONCE_RETRY_WAIT_BACKOFF, async () => {\n            [txHash, signedTx] = await this.signTransaction(receiverId, actions);\n            const publicKey = signedTx.transaction.publicKey;\n            try {\n                return await this.connection.provider.sendTransaction(signedTx);\n            }\n            catch (error) {\n                if (error.type === 'InvalidNonce') {\n                    errors_1.logWarning(`Retrying transaction ${receiverId}:${borsh_1.baseEncode(txHash)} with new nonce.`);\n                    delete this.accessKeyByPublicKeyCache[publicKey.toString()];\n                    return null;\n                }\n                if (error.type === 'Expired') {\n                    errors_1.logWarning(`Retrying transaction ${receiverId}:${borsh_1.baseEncode(txHash)} due to expired block hash`);\n                    return null;\n                }\n                error.context = new providers_1.ErrorContext(borsh_1.baseEncode(txHash));\n                throw error;\n            }\n        });\n        if (!result) {\n            // TODO: This should have different code actually, as means \"transaction not submitted for sure\"\n            throw new providers_1.TypedError('nonce retries exceeded for transaction. This usually means there are too many parallel requests with the same access key.', 'RetriesExceeded');\n        }\n        const flatLogs = [result.transaction_outcome, ...result.receipts_outcome].reduce((acc, it) => {\n            if (it.outcome.logs.length ||\n                (typeof it.outcome.status === 'object' && typeof it.outcome.status.Failure === 'object')) {\n                return acc.concat({\n                    'receiptIds': it.outcome.receipt_ids,\n                    'logs': it.outcome.logs,\n                    'failure': typeof it.outcome.status.Failure != 'undefined' ? rpc_errors_1.parseRpcError(it.outcome.status.Failure) : null\n                });\n            }\n            else\n                return acc;\n        }, []);\n        this.printLogsAndFailures(signedTx.transaction.receiverId, flatLogs);\n        if (!returnError && typeof result.status === 'object' && typeof result.status.Failure === 'object') {\n            // if error data has error_message and error_type properties, we consider that node returned an error in the old format\n            if (result.status.Failure.error_message && result.status.Failure.error_type) {\n                throw new providers_1.TypedError(`Transaction ${result.transaction_outcome.id} failed. ${result.status.Failure.error_message}`, result.status.Failure.error_type);\n            }\n            else {\n                throw rpc_errors_1.parseResultError(result);\n            }\n        }\n        // TODO: if Tx is Unknown or Started.\n        return result;\n    }\n    /**\n     * Finds the {@link AccessKeyView} associated with the accounts {@link PublicKey} stored in the {@link KeyStore}.\n     *\n     * @todo Find matching access key based on transaction (i.e. receiverId and actions)\n     *\n     * @param receiverId currently unused (see todo)\n     * @param actions currently unused (see todo)\n     * @returns `{ publicKey PublicKey; accessKey: AccessKeyView }`\n     */\n    async findAccessKey(receiverId, actions) {\n        // TODO: Find matching access key based on transaction (i.e. receiverId and actions)\n        const publicKey = await this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);\n        if (!publicKey) {\n            return null;\n        }\n        const cachedAccessKey = this.accessKeyByPublicKeyCache[publicKey.toString()];\n        if (cachedAccessKey !== undefined) {\n            return { publicKey, accessKey: cachedAccessKey };\n        }\n        try {\n            const accessKey = await this.connection.provider.query({\n                request_type: 'view_access_key',\n                account_id: this.accountId,\n                public_key: publicKey.toString(),\n                finality: 'optimistic'\n            });\n            // this function can be called multiple times and retrieve the same access key\n            // this checks to see if the access key was already retrieved and cached while\n            // the above network call was in flight. To keep nonce values in line, we return\n            // the cached access key.\n            if (this.accessKeyByPublicKeyCache[publicKey.toString()]) {\n                return { publicKey, accessKey: this.accessKeyByPublicKeyCache[publicKey.toString()] };\n            }\n            this.accessKeyByPublicKeyCache[publicKey.toString()] = accessKey;\n            return { publicKey, accessKey };\n        }\n        catch (e) {\n            if (e.type == 'AccessKeyDoesNotExist') {\n                return null;\n            }\n            throw e;\n        }\n    }\n    /**\n     * Create a new account and deploy a contract to it\n     *\n     * @param contractId NEAR account where the contract is deployed\n     * @param publicKey The public key to add to the created contract account\n     * @param data The compiled contract code\n     * @param amount of NEAR to transfer to the created contract account. Transfer enough to pay for storage https://docs.near.org/docs/concepts/storage-staking\n     */\n    async createAndDeployContract(contractId, publicKey, data, amount) {\n        const accessKey = transaction_1.fullAccessKey();\n        await this.signAndSendTransaction({\n            receiverId: contractId,\n            actions: [transaction_1.createAccount(), transaction_1.transfer(amount), transaction_1.addKey(key_pair_1.PublicKey.from(publicKey), accessKey), transaction_1.deployContract(data)]\n        });\n        const contractAccount = new Account(this.connection, contractId);\n        return contractAccount;\n    }\n    /**\n     * @param receiverId NEAR account receiving Ⓝ\n     * @param amount Amount to send in yoctoⓃ\n     */\n    async sendMoney(receiverId, amount) {\n        return this.signAndSendTransaction({\n            receiverId,\n            actions: [transaction_1.transfer(amount)]\n        });\n    }\n    /**\n     * @param newAccountId NEAR account name to be created\n     * @param publicKey A public key created from the masterAccount\n     */\n    async createAccount(newAccountId, publicKey, amount) {\n        const accessKey = transaction_1.fullAccessKey();\n        return this.signAndSendTransaction({\n            receiverId: newAccountId,\n            actions: [transaction_1.createAccount(), transaction_1.transfer(amount), transaction_1.addKey(key_pair_1.PublicKey.from(publicKey), accessKey)]\n        });\n    }\n    /**\n     * @param beneficiaryId The NEAR account that will receive the remaining Ⓝ balance from the account being deleted\n     */\n    async deleteAccount(beneficiaryId) {\n        return this.signAndSendTransaction({\n            receiverId: this.accountId,\n            actions: [transaction_1.deleteAccount(beneficiaryId)]\n        });\n    }\n    /**\n     * @param data The compiled contract code\n     */\n    async deployContract(data) {\n        return this.signAndSendTransaction({\n            receiverId: this.accountId,\n            actions: [transaction_1.deployContract(data)]\n        });\n    }\n    async functionCall(...args) {\n        if (typeof args[0] === 'string') {\n            return this.functionCallV1(args[0], args[1], args[2], args[3], args[4]);\n        }\n        else {\n            return this.functionCallV2(args[0]);\n        }\n    }\n    functionCallV1(contractId, methodName, args, gas, amount) {\n        const deprecate = depd_1.default('Account.functionCall(contractId, methodName, args, gas, amount)');\n        deprecate('use `Account.functionCall(FunctionCallOptions)` instead');\n        args = args || {};\n        this.validateArgs(args);\n        return this.signAndSendTransaction({\n            receiverId: contractId,\n            actions: [transaction_1.functionCall(methodName, args, gas || constants_1.DEFAULT_FUNCTION_CALL_GAS, amount)]\n        });\n    }\n    functionCallV2({ contractId, methodName, args = {}, gas = constants_1.DEFAULT_FUNCTION_CALL_GAS, attachedDeposit, walletMeta, walletCallbackUrl, stringify }) {\n        this.validateArgs(args);\n        const stringifyArg = stringify === undefined ? transaction_1.stringifyJsonOrBytes : stringify;\n        return this.signAndSendTransaction({\n            receiverId: contractId,\n            actions: [transaction_1.functionCall(methodName, args, gas, attachedDeposit, stringifyArg)],\n            walletMeta,\n            walletCallbackUrl\n        });\n    }\n    /**\n     * @see {@link https://docs.near.org/docs/concepts/account#access-keys}\n     * @todo expand this API to support more options.\n     * @param publicKey A public key to be associated with the contract\n     * @param contractId NEAR account where the contract is deployed\n     * @param methodNames The method names on the contract that should be allowed to be called. Pass null for no method names and '' or [] for any method names.\n     * @param amount Payment in yoctoⓃ that is sent to the contract during this function call\n     */\n    async addKey(publicKey, contractId, methodNames, amount) {\n        if (!methodNames) {\n            methodNames = [];\n        }\n        if (!Array.isArray(methodNames)) {\n            methodNames = [methodNames];\n        }\n        let accessKey;\n        if (!contractId) {\n            accessKey = transaction_1.fullAccessKey();\n        }\n        else {\n            accessKey = transaction_1.functionCallAccessKey(contractId, methodNames, amount);\n        }\n        return this.signAndSendTransaction({\n            receiverId: this.accountId,\n            actions: [transaction_1.addKey(key_pair_1.PublicKey.from(publicKey), accessKey)]\n        });\n    }\n    /**\n     * @param publicKey The public key to be deleted\n     * @returns {Promise<FinalExecutionOutcome>}\n     */\n    async deleteKey(publicKey) {\n        return this.signAndSendTransaction({\n            receiverId: this.accountId,\n            actions: [transaction_1.deleteKey(key_pair_1.PublicKey.from(publicKey))]\n        });\n    }\n    /**\n     * @see {@link https://docs.near.org/docs/validator/staking-overview}\n     *\n     * @param publicKey The public key for the account that's staking\n     * @param amount The account to stake in yoctoⓃ\n     */\n    async stake(publicKey, amount) {\n        return this.signAndSendTransaction({\n            receiverId: this.accountId,\n            actions: [transaction_1.stake(amount, key_pair_1.PublicKey.from(publicKey))]\n        });\n    }\n    /** @hidden */\n    validateArgs(args) {\n        const isUint8Array = args.byteLength !== undefined && args.byteLength === args.length;\n        if (isUint8Array) {\n            return;\n        }\n        if (Array.isArray(args) || typeof args !== 'object') {\n            throw new errors_1.PositionalArgsError();\n        }\n    }\n    /**\n     * Invoke a contract view function using the RPC API.\n     * @see {@link https://docs.near.org/docs/develop/front-end/rpc#call-a-contract-function}\n     *\n     * @param contractId NEAR account where the contract is deployed\n     * @param methodName The view-only method (no state mutations) name on the contract as it is written in the contract code\n     * @param args Any arguments to the view contract method, wrapped in JSON\n     * @param options.parse Parse the result of the call. Receives a Buffer (bytes array) and converts it to any object. By default result will be treated as json.\n     * @param options.stringify Convert input arguments into a bytes array. By default the input is treated as a JSON.\n     * @returns {Promise<any>}\n     */\n    async viewFunction(contractId, methodName, args = {}, { parse = parseJsonFromRawResponse, stringify = bytesJsonStringify } = {}) {\n        this.validateArgs(args);\n        const serializedArgs = stringify(args).toString('base64');\n        const result = await this.connection.provider.query({\n            request_type: 'call_function',\n            account_id: contractId,\n            method_name: methodName,\n            args_base64: serializedArgs,\n            finality: 'optimistic'\n        });\n        if (result.logs) {\n            this.printLogs(contractId, result.logs);\n        }\n        return result.result && result.result.length > 0 && parse(Buffer.from(result.result));\n    }\n    /**\n     * Returns the state (key value pairs) of this account's contract based on the key prefix.\n     * Pass an empty string for prefix if you would like to return the entire state.\n     * @see {@link https://docs.near.org/docs/develop/front-end/rpc#view-contract-state}\n     *\n     * @param prefix allows to filter which keys should be returned. Empty prefix means all keys. String prefix is utf-8 encoded.\n     * @param blockQuery specifies which block to query state at. By default returns last \"optimistic\" block (i.e. not necessarily finalized).\n     */\n    async viewState(prefix, blockQuery = { finality: 'optimistic' }) {\n        const { values } = await this.connection.provider.query({\n            request_type: 'view_state',\n            ...blockQuery,\n            account_id: this.accountId,\n            prefix_base64: Buffer.from(prefix).toString('base64')\n        });\n        return values.map(({ key, value }) => ({\n            key: Buffer.from(key, 'base64'),\n            value: Buffer.from(value, 'base64')\n        }));\n    }\n    /**\n     * Get all access keys for the account\n     * @see {@link https://docs.near.org/docs/develop/front-end/rpc#view-access-key-list}\n     */\n    async getAccessKeys() {\n        const response = await this.connection.provider.query({\n            request_type: 'view_access_key_list',\n            account_id: this.accountId,\n            finality: 'optimistic'\n        });\n        // A breaking API change introduced extra information into the\n        // response, so it now returns an object with a `keys` field instead\n        // of an array: https://github.com/nearprotocol/nearcore/pull/1789\n        if (Array.isArray(response)) {\n            return response;\n        }\n        return response.keys;\n    }\n    /**\n     * Returns a list of authorized apps\n     * @todo update the response value to return all the different keys, not just app keys.\n     */\n    async getAccountDetails() {\n        // TODO: update the response value to return all the different keys, not just app keys.\n        // Also if we need this function, or getAccessKeys is good enough.\n        const accessKeys = await this.getAccessKeys();\n        const authorizedApps = accessKeys\n            .filter(item => item.access_key.permission !== 'FullAccess')\n            .map(item => {\n            const perm = item.access_key.permission;\n            return {\n                contractId: perm.FunctionCall.receiver_id,\n                amount: perm.FunctionCall.allowance,\n                publicKey: item.public_key,\n            };\n        });\n        return { authorizedApps };\n    }\n    /**\n     * Returns calculated account balance\n     */\n    async getAccountBalance() {\n        const protocolConfig = await this.connection.provider.experimental_protocolConfig({ finality: 'final' });\n        const state = await this.state();\n        const costPerByte = new bn_js_1.default(protocolConfig.runtime_config.storage_amount_per_byte);\n        const stateStaked = new bn_js_1.default(state.storage_usage).mul(costPerByte);\n        const staked = new bn_js_1.default(state.locked);\n        const totalBalance = new bn_js_1.default(state.amount).add(staked);\n        const availableBalance = totalBalance.sub(bn_js_1.default.max(staked, stateStaked));\n        return {\n            total: totalBalance.toString(),\n            stateStaked: stateStaked.toString(),\n            staked: staked.toString(),\n            available: availableBalance.toString()\n        };\n    }\n}\nexports.Account = Account;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}