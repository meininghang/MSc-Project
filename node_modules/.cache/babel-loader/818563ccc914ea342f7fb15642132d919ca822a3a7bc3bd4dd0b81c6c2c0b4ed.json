{"ast":null,"code":"/* jshint node: true */\n\n// TODO: Add minimal templating.\n// TODO: Add option to prefix nested type declarations with the outer types'\n// names.\n\n'use strict';\n\n/** IDL to protocol (services) and schema (types) parsing logic. */\nrequire(\"core-js/modules/es.array.push.js\");\nvar files = require('./files'),\n  utils = require('./utils'),\n  path = require('path'),\n  util = require('util');\nvar f = util.format;\n\n// Default type references defined by Avro.\nvar TYPE_REFS = {\n  date: {\n    type: 'int',\n    logicalType: 'date'\n  },\n  decimal: {\n    type: 'bytes',\n    logicalType: 'decimal'\n  },\n  time_ms: {\n    type: 'long',\n    logicalType: 'time-millis'\n  },\n  timestamp_ms: {\n    type: 'long',\n    logicalType: 'timestamp-millis'\n  }\n};\n\n/** Assemble an IDL file into a decoded protocol. */\nfunction assembleProtocol(fpath, opts, cb) {\n  if (!cb && typeof opts == 'function') {\n    cb = opts;\n    opts = undefined;\n  }\n  opts = opts || {};\n  if (!opts.importHook) {\n    opts.importHook = files.createImportHook();\n  }\n\n  // Types found in imports. We store them separately to be able to insert them\n  // in the correct order in the final attributes.\n  var importedTypes = [];\n  var protocol, imports;\n  opts.importHook(fpath, 'idl', function (err, str) {\n    if (err) {\n      cb(err);\n      return;\n    }\n    if (str === undefined) {\n      // Skipped import (likely already imported).\n      cb(null, {});\n      return;\n    }\n    try {\n      var reader = new Reader(str, opts);\n      var obj = reader._readProtocol(str, opts);\n    } catch (err) {\n      err.path = fpath; // To help debug which file caused the error.\n      cb(err);\n      return;\n    }\n    protocol = obj.protocol;\n    imports = obj.imports;\n    fetchImports();\n  });\n  function fetchImports() {\n    var info = imports.shift();\n    if (!info) {\n      // We are done with this file. We prepend all imported types to this\n      // file's and we can return the final result.\n      if (importedTypes.length) {\n        protocol.types = protocol.types ? importedTypes.concat(protocol.types) : importedTypes;\n      }\n      cb(null, protocol);\n    } else {\n      var importPath = path.join(path.dirname(fpath), info.name);\n      if (info.kind === 'idl') {\n        assembleProtocol(importPath, opts, mergeImportedSchema);\n      } else {\n        // We are importing a protocol or schema file.\n        opts.importHook(importPath, info.kind, function (err, str) {\n          if (err) {\n            cb(err);\n            return;\n          }\n          switch (info.kind) {\n            case 'protocol':\n            case 'schema':\n              if (str === undefined) {\n                // Flag used to signal an already imported file by the default\n                // import hooks. Implementors who wish to disallow duplicate\n                // imports should provide a custom hook which throws an error\n                // when a duplicate import is detected.\n                mergeImportedSchema(null, {});\n                return;\n              }\n              try {\n                var obj = JSON.parse(str);\n              } catch (err) {\n                err.path = importPath;\n                cb(err);\n                return;\n              }\n              var schema = info.kind === 'schema' ? {\n                types: [obj]\n              } : obj;\n              mergeImportedSchema(null, schema);\n              break;\n            default:\n              cb(new Error(f('invalid import kind: %s', info.kind)));\n          }\n        });\n      }\n    }\n  }\n  function mergeImportedSchema(err, importedSchema) {\n    if (err) {\n      cb(err);\n      return;\n    }\n    // Merge  first the types (where we don't need to check for duplicates\n    // since instantiating the service will take care of it), then the messages\n    // (where we need to, as duplicates will overwrite each other).\n    (importedSchema.types || []).forEach(function (typeSchema) {\n      // Ensure the imported protocol's namespace is inherited correctly (it\n      // might be different from the current one).\n      if (typeSchema.namespace === undefined) {\n        var namespace = importedSchema.namespace;\n        if (!namespace) {\n          var match = /^(.*)\\.[^.]+$/.exec(importedSchema.protocol);\n          if (match) {\n            namespace = match[1];\n          }\n        }\n        typeSchema.namespace = namespace || '';\n      }\n      importedTypes.push(typeSchema);\n    });\n    try {\n      Object.keys(importedSchema.messages || {}).forEach(function (name) {\n        if (!protocol.messages) {\n          protocol.messages = {};\n        }\n        if (protocol.messages[name]) {\n          throw new Error(f('duplicate message: %s', name));\n        }\n        protocol.messages[name] = importedSchema.messages[name];\n      });\n    } catch (err) {\n      cb(err);\n      return;\n    }\n    fetchImports(); // Continue importing any remaining imports.\n  }\n}\n\n// Parsing functions.\n\n/**\n * Convenience function to parse multiple inputs into protocols and schemas.\n *\n * It should cover most basic use-cases but has a few limitations:\n *\n * + It doesn't allow passing options to the parsing step.\n * + The protocol/type inference logic can be deceived.\n *\n * The parsing logic is as follows:\n *\n * + If `str` contains `path.sep` (on windows `\\`, otherwise `/`) and is a path\n *   to an existing file, it will first be read as JSON, then as an IDL\n *   specification if JSON parsing failed. If either succeeds, the result is\n *   returned, otherwise the next steps are run using the file's content\n *   instead of the input path.\n * + If `str` is a valid JSON string, it is parsed then returned.\n * + If `str` is a valid IDL protocol specification, it is parsed and returned\n *   if no imports are present (and an error is thrown if there are any\n *   imports).\n * + If `str` is a valid IDL type specification, it is parsed and returned.\n * + If neither of the above cases apply, `str` is returned.\n */\nfunction read(str) {\n  var schema;\n  if (typeof str == 'string' && ~str.indexOf(path.sep) && files.existsSync(str)) {\n    // Try interpreting `str` as path to a file contain a JSON schema or an IDL\n    // protocol. Note that we add the second check to skip primitive references\n    // (e.g. `\"int\"`, the most common use-case for `avro.parse`).\n    var contents = files.readFileSync(str, {\n      encoding: 'utf8'\n    });\n    try {\n      return JSON.parse(contents);\n    } catch (err) {\n      var opts = {\n        importHook: files.createSyncImportHook()\n      };\n      assembleProtocol(str, opts, function (err, protocolSchema) {\n        schema = err ? contents : protocolSchema;\n      });\n    }\n  } else {\n    schema = str;\n  }\n  if (typeof schema != 'string' || schema === 'null') {\n    // This last predicate is to allow `read('null')` to work similarly to\n    // `read('int')` and other primitives (null needs to be handled separately\n    // since it is also a valid JSON identifier).\n    return schema;\n  }\n  try {\n    return JSON.parse(schema);\n  } catch (err) {\n    try {\n      return Reader.readProtocol(schema);\n    } catch (err) {\n      try {\n        return Reader.readSchema(schema);\n      } catch (err) {\n        return schema;\n      }\n    }\n  }\n}\nfunction Reader(str, opts) {\n  opts = opts || {};\n  this._tk = new Tokenizer(str);\n  this._ackVoidMessages = !!opts.ackVoidMessages;\n  this._implicitTags = !opts.delimitedCollections;\n  this._typeRefs = opts.typeRefs || TYPE_REFS;\n}\nReader.readProtocol = function (str, opts) {\n  var reader = new Reader(str, opts);\n  var protocol = reader._readProtocol();\n  if (protocol.imports.length) {\n    // Imports can only be resolved when the IDL file is provided via its\n    // path, we fail rather than silently ignore imports.\n    throw new Error('unresolvable import');\n  }\n  return protocol.protocol;\n};\nReader.readSchema = function (str, opts) {\n  var reader = new Reader(str, opts);\n  var javadoc = reader._readJavadoc();\n  var schema = reader._readType(javadoc === undefined ? {} : {\n    doc: javadoc\n  });\n  reader._tk.next({\n    id: '(eof)'\n  }); // Check that we have read everything.\n  return schema;\n};\nReader.prototype._readProtocol = function () {\n  var tk = this._tk;\n  var imports = [];\n  var types = [];\n  var messages = {};\n  var pos;\n\n  // Outer declarations (outside of the protocol block).\n  this._readImports(imports);\n  var protocolSchema = {};\n  var protocolJavadoc = this._readJavadoc();\n  if (protocolJavadoc !== undefined) {\n    protocolSchema.doc = protocolJavadoc;\n  }\n  this._readAnnotations(protocolSchema);\n  tk.next({\n    val: 'protocol'\n  });\n  if (!tk.next({\n    val: '{',\n    silent: true\n  })) {\n    // Named protocol.\n    protocolSchema.protocol = tk.next({\n      id: 'name'\n    }).val;\n    tk.next({\n      val: '{'\n    });\n  }\n\n  // Inner declarations.\n  while (!tk.next({\n    val: '}',\n    silent: true\n  })) {\n    if (!this._readImports(imports)) {\n      var javadoc = this._readJavadoc();\n      var typeSchema = this._readType();\n      var numImports = this._readImports(imports, true);\n      var message = undefined;\n      // We mark our position and try to parse a message from here.\n      pos = tk.pos;\n      if (!numImports && (message = this._readMessage(typeSchema))) {\n        // Note that if any imports were found, we cannot be parsing a message.\n        if (javadoc !== undefined && message.schema.doc === undefined) {\n          message.schema.doc = javadoc;\n        }\n        var oneWay = false;\n        if (message.schema.response === 'void' || message.schema.response.type === 'void') {\n          oneWay = !this._ackVoidMessages && !message.schema.errors;\n          if (message.schema.response === 'void') {\n            message.schema.response = 'null';\n          } else {\n            message.schema.response.type = 'null';\n          }\n        }\n        if (oneWay) {\n          message.schema['one-way'] = true;\n        }\n        if (messages[message.name]) {\n          // We have to do this check here otherwise the duplicate will be\n          // overwritten (and service instantiation won't be able to catch it).\n          throw new Error(f('duplicate message: %s', message.name));\n        }\n        messages[message.name] = message.schema;\n      } else {\n        // This was a standalone type definition.\n        if (javadoc) {\n          if (typeof typeSchema == 'string') {\n            typeSchema = {\n              doc: javadoc,\n              type: typeSchema\n            };\n          } else if (typeSchema.doc === undefined) {\n            typeSchema.doc = javadoc;\n          }\n        }\n        types.push(typeSchema);\n        // We backtrack until just before the type's type name and swallow an\n        // eventual semi-colon (to make type declarations more consistent).\n        tk.pos = pos;\n        tk.next({\n          val: ';',\n          silent: true\n        });\n      }\n      javadoc = undefined;\n    }\n  }\n  tk.next({\n    id: '(eof)'\n  });\n  if (types.length) {\n    protocolSchema.types = types;\n  }\n  if (Object.keys(messages).length) {\n    protocolSchema.messages = messages;\n  }\n  return {\n    protocol: protocolSchema,\n    imports: imports\n  };\n};\nReader.prototype._readAnnotations = function (schema) {\n  var tk = this._tk;\n  while (tk.next({\n    val: '@',\n    silent: true\n  })) {\n    // Annotations are allowed to have names which aren't valid Avro names,\n    // we must advance until we hit the first left parenthesis.\n    var parts = [];\n    while (!tk.next({\n      val: '(',\n      silent: true\n    })) {\n      parts.push(tk.next().val);\n    }\n    schema[parts.join('')] = tk.next({\n      id: 'json'\n    }).val;\n    tk.next({\n      val: ')'\n    });\n  }\n};\nReader.prototype._readMessage = function (responseSchema) {\n  var tk = this._tk;\n  var schema = {\n    request: [],\n    response: responseSchema\n  };\n  this._readAnnotations(schema);\n  var name = tk.next().val;\n  if (tk.next().val !== '(') {\n    // This isn't a message.\n    return;\n  }\n  if (!tk.next({\n    val: ')',\n    silent: true\n  })) {\n    do {\n      schema.request.push(this._readField());\n    } while (!tk.next({\n      val: ')',\n      silent: true\n    }) && tk.next({\n      val: ','\n    }));\n  }\n  var token = tk.next();\n  switch (token.val) {\n    case 'throws':\n      // It doesn't seem like the IDL is explicit about which syntax to used\n      // for multiple errors. We will assume a comma-separated list.\n      schema.errors = [];\n      do {\n        schema.errors.push(this._readType());\n      } while (!tk.next({\n        val: ';',\n        silent: true\n      }) && tk.next({\n        val: ','\n      }));\n      break;\n    case 'oneway':\n      schema['one-way'] = true;\n      tk.next({\n        val: ';'\n      });\n      break;\n    case ';':\n      break;\n    default:\n      throw tk.error('invalid message suffix', token);\n  }\n  return {\n    name: name,\n    schema: schema\n  };\n};\nReader.prototype._readJavadoc = function () {\n  var token = this._tk.next({\n    id: 'javadoc',\n    emitJavadoc: true,\n    silent: true\n  });\n  if (token) {\n    return token.val;\n  }\n};\nReader.prototype._readField = function () {\n  var tk = this._tk;\n  var javadoc = this._readJavadoc();\n  var schema = {\n    type: this._readType()\n  };\n  if (javadoc !== undefined && schema.doc === undefined) {\n    schema.doc = javadoc;\n  }\n  this._readAnnotations(schema);\n  schema.name = tk.next({\n    id: 'name'\n  }).val;\n  if (tk.next({\n    val: '=',\n    silent: true\n  })) {\n    schema['default'] = tk.next({\n      id: 'json'\n    }).val;\n  }\n  return schema;\n};\nReader.prototype._readType = function (schema) {\n  schema = schema || {};\n  this._readAnnotations(schema);\n  schema.type = this._tk.next({\n    id: 'name'\n  }).val;\n  switch (schema.type) {\n    case 'record':\n    case 'error':\n      return this._readRecord(schema);\n    case 'fixed':\n      return this._readFixed(schema);\n    case 'enum':\n      return this._readEnum(schema);\n    case 'map':\n      return this._readMap(schema);\n    case 'array':\n      return this._readArray(schema);\n    case 'union':\n      if (Object.keys(schema).length > 1) {\n        throw new Error('union annotations are not supported');\n      }\n      return this._readUnion();\n    default:\n      // Reference.\n      var ref = this._typeRefs[schema.type];\n      if (ref) {\n        delete schema.type; // Always overwrite the type.\n        utils.copyOwnProperties(ref, schema);\n      }\n      return Object.keys(schema).length > 1 ? schema : schema.type;\n  }\n};\nReader.prototype._readFixed = function (schema) {\n  var tk = this._tk;\n  if (!tk.next({\n    val: '(',\n    silent: true\n  })) {\n    schema.name = tk.next({\n      id: 'name'\n    }).val;\n    tk.next({\n      val: '('\n    });\n  }\n  schema.size = parseInt(tk.next({\n    id: 'number'\n  }).val);\n  tk.next({\n    val: ')'\n  });\n  return schema;\n};\nReader.prototype._readMap = function (schema) {\n  var tk = this._tk;\n  // Brackets are unwieldy when declaring inline types. We allow for them to be\n  // omitted (but we keep the consistency that if the entry bracket is present,\n  // the exit one must be as well). Note that this is non-standard.\n  var silent = this._implicitTags;\n  var implicitTags = tk.next({\n    val: '<',\n    silent: silent\n  }) === undefined;\n  schema.values = this._readType();\n  tk.next({\n    val: '>',\n    silent: implicitTags\n  });\n  return schema;\n};\nReader.prototype._readArray = function (schema) {\n  var tk = this._tk;\n  var silent = this._implicitTags;\n  var implicitTags = tk.next({\n    val: '<',\n    silent: silent\n  }) === undefined;\n  schema.items = this._readType();\n  tk.next({\n    val: '>',\n    silent: implicitTags\n  });\n  return schema;\n};\nReader.prototype._readEnum = function (schema) {\n  var tk = this._tk;\n  if (!tk.next({\n    val: '{',\n    silent: true\n  })) {\n    schema.name = tk.next({\n      id: 'name'\n    }).val;\n    tk.next({\n      val: '{'\n    });\n  }\n  schema.symbols = [];\n  do {\n    schema.symbols.push(tk.next().val);\n  } while (!tk.next({\n    val: '}',\n    silent: true\n  }) && tk.next({\n    val: ','\n  }));\n  return schema;\n};\nReader.prototype._readUnion = function () {\n  var tk = this._tk;\n  var arr = [];\n  tk.next({\n    val: '{'\n  });\n  do {\n    arr.push(this._readType());\n  } while (!tk.next({\n    val: '}',\n    silent: true\n  }) && tk.next({\n    val: ','\n  }));\n  return arr;\n};\nReader.prototype._readRecord = function (schema) {\n  var tk = this._tk;\n  if (!tk.next({\n    val: '{',\n    silent: true\n  })) {\n    schema.name = tk.next({\n      id: 'name'\n    }).val;\n    tk.next({\n      val: '{'\n    });\n  }\n  schema.fields = [];\n  while (!tk.next({\n    val: '}',\n    silent: true\n  })) {\n    schema.fields.push(this._readField());\n    tk.next({\n      val: ';'\n    });\n  }\n  return schema;\n};\nReader.prototype._readImports = function (imports, maybeMessage) {\n  var tk = this._tk;\n  var numImports = 0;\n  var pos = tk.pos;\n  while (tk.next({\n    val: 'import',\n    silent: true\n  })) {\n    if (!numImports && maybeMessage && tk.next({\n      val: '(',\n      silent: true\n    })) {\n      // This will happen if a message is named import.\n      tk.pos = pos;\n      return;\n    }\n    var kind = tk.next({\n      id: 'name'\n    }).val;\n    var fname = JSON.parse(tk.next({\n      id: 'string'\n    }).val);\n    tk.next({\n      val: ';'\n    });\n    imports.push({\n      kind: kind,\n      name: fname\n    });\n    numImports++;\n  }\n  return numImports;\n};\n\n// Helpers.\n\n/**\n * Simple class to split an input string into tokens.\n *\n * There are different types of tokens, characterized by their `id`:\n *\n * + `number` numbers.\n * + `name` references.\n * + `string` double-quoted.\n * + `operator`, anything else, always single character.\n * + `javadoc`, only emitted when `next` is called with `emitJavadoc` set.\n * + `json`, only emitted when `next` is called with `'json'` as `id` (the\n *   tokenizer doesn't have enough context to predict these).\n */\nfunction Tokenizer(str) {\n  this._str = str;\n  this.pos = 0;\n}\nTokenizer.prototype.next = function (opts) {\n  var token = {\n    pos: this.pos,\n    id: undefined,\n    val: undefined\n  };\n  var javadoc = this._skip(opts && opts.emitJavadoc);\n  if (javadoc) {\n    token.id = 'javadoc';\n    token.val = javadoc;\n  } else {\n    var pos = this.pos;\n    var str = this._str;\n    var c = str.charAt(pos);\n    if (!c) {\n      token.id = '(eof)';\n    } else {\n      if (opts && opts.id === 'json') {\n        token.id = 'json';\n        this.pos = this._endOfJson();\n      } else if (c === '\"') {\n        token.id = 'string';\n        this.pos = this._endOfString();\n      } else if (/[0-9]/.test(c)) {\n        token.id = 'number';\n        this.pos = this._endOf(/[0-9]/);\n      } else if (/[`A-Za-z_.]/.test(c)) {\n        token.id = 'name';\n        this.pos = this._endOf(/[`A-Za-z0-9_.]/);\n      } else {\n        token.id = 'operator';\n        this.pos = pos + 1;\n      }\n      token.val = str.slice(pos, this.pos);\n      if (token.id === 'json') {\n        // Let's be nice and give a more helpful error message when this occurs\n        // (JSON parsing errors wouldn't let us find the location otherwise).\n        try {\n          token.val = JSON.parse(token.val);\n        } catch (err) {\n          throw this.error('invalid JSON', token);\n        }\n      } else if (token.id === 'name') {\n        // Unescape names (our parser doesn't need them).\n        token.val = token.val.replace(/`/g, '');\n      }\n    }\n  }\n  var err;\n  if (opts && opts.id && opts.id !== token.id) {\n    err = this.error(f('expected ID %s', opts.id), token);\n  } else if (opts && opts.val && opts.val !== token.val) {\n    err = this.error(f('expected value %s', opts.val), token);\n  }\n  if (!err) {\n    return token;\n  } else if (opts && opts.silent) {\n    this.pos = token.pos; // Backtrack to start of token.\n    return undefined;\n  } else {\n    throw err;\n  }\n};\nTokenizer.prototype.error = function (reason, context) {\n  // Context must be either a token or a position.\n  var isToken = typeof context != 'number';\n  var pos = isToken ? context.pos : context;\n  var str = this._str;\n  var lineNum = 1;\n  var lineStart = 0;\n  var i;\n  for (i = 0; i < pos; i++) {\n    if (str.charAt(i) === '\\n') {\n      lineNum++;\n      lineStart = i;\n    }\n  }\n  var msg = isToken ? f('invalid token %j: %s', context, reason) : reason;\n  var err = new Error(msg);\n  err.token = isToken ? context : undefined;\n  err.lineNum = lineNum;\n  err.colNum = pos - lineStart;\n  return err;\n};\n\n/** Skip whitespace and comments. */\nTokenizer.prototype._skip = function (emitJavadoc) {\n  var str = this._str;\n  var isJavadoc = false;\n  var pos, c;\n  while ((c = str.charAt(this.pos)) && /\\s/.test(c)) {\n    this.pos++;\n  }\n  pos = this.pos;\n  if (c === '/') {\n    switch (str.charAt(this.pos + 1)) {\n      case '/':\n        this.pos += 2;\n        while ((c = str.charAt(this.pos)) && c !== '\\n') {\n          this.pos++;\n        }\n        return this._skip(emitJavadoc);\n      case '*':\n        this.pos += 2;\n        if (str.charAt(this.pos) === '*') {\n          isJavadoc = true;\n        }\n        while (c = str.charAt(this.pos++)) {\n          if (c === '*' && str.charAt(this.pos) === '/') {\n            this.pos++;\n            if (isJavadoc && emitJavadoc) {\n              return extractJavadoc(str.slice(pos + 3, this.pos - 2));\n            }\n            return this._skip(emitJavadoc);\n          }\n        }\n        throw this.error('unterminated comment', pos);\n    }\n  }\n};\n\n/** Generic end of method. */\nTokenizer.prototype._endOf = function (pat) {\n  var pos = this.pos;\n  var str = this._str;\n  while (pat.test(str.charAt(pos))) {\n    pos++;\n  }\n  return pos;\n};\n\n/** Find end of a string. */\nTokenizer.prototype._endOfString = function () {\n  var pos = this.pos + 1; // Skip first double quote.\n  var str = this._str;\n  var c;\n  while (c = str.charAt(pos)) {\n    if (c === '\"') {\n      // The spec doesn't explicitly say so, but IDLs likely only\n      // allow double quotes for strings (C- and Java-style).\n      return pos + 1;\n    }\n    if (c === '\\\\') {\n      pos += 2;\n    } else {\n      pos++;\n    }\n  }\n  throw this.error('unterminated string', pos - 1);\n};\n\n/** Find end of JSON object, throwing an error if the end is reached first. */\nTokenizer.prototype._endOfJson = function () {\n  var pos = utils.jsonEnd(this._str, this.pos);\n  if (pos < 0) {\n    throw this.error('invalid JSON', pos);\n  }\n  return pos;\n};\n\n/**\n * Extract Javadoc contents from the comment.\n *\n * The parsing done is very simple and simply removes the line prefixes and\n * leading / trailing empty lines. It's better to be conservative with\n * formatting rather than risk losing information.\n */\nfunction extractJavadoc(str) {\n  var lines = str.replace(/^[ \\t]+|[ \\t]+$/g, '') // Trim whitespace.\n  .split('\\n').map(function (line, i) {\n    return i ? line.replace(/^\\s*\\*\\s?/, '') : line;\n  });\n  while (!lines[0]) {\n    lines.shift();\n  }\n  while (!lines[lines.length - 1]) {\n    lines.pop();\n  }\n  return lines.join('\\n');\n}\nmodule.exports = {\n  Tokenizer: Tokenizer,\n  assembleProtocol: assembleProtocol,\n  read: read,\n  readProtocol: Reader.readProtocol,\n  readSchema: Reader.readSchema\n};","map":{"version":3,"names":["require","files","utils","path","util","f","format","TYPE_REFS","date","type","logicalType","decimal","time_ms","timestamp_ms","assembleProtocol","fpath","opts","cb","undefined","importHook","createImportHook","importedTypes","protocol","imports","err","str","reader","Reader","obj","_readProtocol","fetchImports","info","shift","length","types","concat","importPath","join","dirname","name","kind","mergeImportedSchema","JSON","parse","schema","Error","importedSchema","forEach","typeSchema","namespace","match","exec","push","Object","keys","messages","read","indexOf","sep","existsSync","contents","readFileSync","encoding","createSyncImportHook","protocolSchema","readProtocol","readSchema","_tk","Tokenizer","_ackVoidMessages","ackVoidMessages","_implicitTags","delimitedCollections","_typeRefs","typeRefs","javadoc","_readJavadoc","_readType","doc","next","id","prototype","tk","pos","_readImports","protocolJavadoc","_readAnnotations","val","silent","numImports","message","_readMessage","oneWay","response","errors","parts","responseSchema","request","_readField","token","error","emitJavadoc","_readRecord","_readFixed","_readEnum","_readMap","_readArray","_readUnion","ref","copyOwnProperties","size","parseInt","implicitTags","values","items","symbols","arr","fields","maybeMessage","fname","_str","_skip","c","charAt","_endOfJson","_endOfString","test","_endOf","slice","replace","reason","context","isToken","lineNum","lineStart","i","msg","colNum","isJavadoc","extractJavadoc","pat","jsonEnd","lines","split","map","line","pop","module","exports"],"sources":["E:/Amanda-project/vue2-project/project-vue2/node_modules/avsc/lib/specs.js"],"sourcesContent":["/* jshint node: true */\n\n// TODO: Add minimal templating.\n// TODO: Add option to prefix nested type declarations with the outer types'\n// names.\n\n'use strict';\n\n/** IDL to protocol (services) and schema (types) parsing logic. */\n\nvar files = require('./files'),\n    utils = require('./utils'),\n    path = require('path'),\n    util = require('util');\n\n\nvar f = util.format;\n\n\n// Default type references defined by Avro.\nvar TYPE_REFS = {\n  date: {type: 'int', logicalType: 'date'},\n  decimal: {type: 'bytes', logicalType: 'decimal'},\n  time_ms: {type: 'long', logicalType: 'time-millis'},\n  timestamp_ms: {type: 'long', logicalType: 'timestamp-millis'}\n};\n\n\n/** Assemble an IDL file into a decoded protocol. */\nfunction assembleProtocol(fpath, opts, cb) {\n  if (!cb && typeof opts == 'function') {\n    cb = opts;\n    opts = undefined;\n  }\n  opts = opts || {};\n  if (!opts.importHook) {\n    opts.importHook = files.createImportHook();\n  }\n\n  // Types found in imports. We store them separately to be able to insert them\n  // in the correct order in the final attributes.\n  var importedTypes = [];\n  var protocol, imports;\n  opts.importHook(fpath, 'idl', function (err, str) {\n    if (err) {\n      cb(err);\n      return;\n    }\n    if (str === undefined) {\n      // Skipped import (likely already imported).\n      cb(null, {});\n      return;\n    }\n    try {\n      var reader = new Reader(str, opts);\n      var obj = reader._readProtocol(str, opts);\n    } catch (err) {\n      err.path = fpath; // To help debug which file caused the error.\n      cb(err);\n      return;\n    }\n    protocol = obj.protocol;\n    imports = obj.imports;\n    fetchImports();\n  });\n\n  function fetchImports() {\n    var info = imports.shift();\n    if (!info) {\n      // We are done with this file. We prepend all imported types to this\n      // file's and we can return the final result.\n      if (importedTypes.length) {\n        protocol.types = protocol.types ?\n          importedTypes.concat(protocol.types) :\n          importedTypes;\n      }\n      cb(null, protocol);\n    } else {\n      var importPath = path.join(path.dirname(fpath), info.name);\n      if (info.kind === 'idl') {\n        assembleProtocol(importPath, opts, mergeImportedSchema);\n      } else {\n        // We are importing a protocol or schema file.\n        opts.importHook(importPath, info.kind, function (err, str) {\n          if (err) {\n            cb(err);\n            return;\n          }\n          switch (info.kind) {\n            case 'protocol':\n            case 'schema':\n              if (str === undefined) {\n                // Flag used to signal an already imported file by the default\n                // import hooks. Implementors who wish to disallow duplicate\n                // imports should provide a custom hook which throws an error\n                // when a duplicate import is detected.\n                mergeImportedSchema(null, {});\n                return;\n              }\n              try {\n                var obj = JSON.parse(str);\n              } catch (err) {\n                err.path = importPath;\n                cb(err);\n                return;\n              }\n              var schema = info.kind === 'schema' ? {types: [obj]} : obj;\n              mergeImportedSchema(null, schema);\n              break;\n            default:\n              cb(new Error(f('invalid import kind: %s', info.kind)));\n          }\n        });\n      }\n    }\n  }\n\n  function mergeImportedSchema(err, importedSchema) {\n    if (err) {\n      cb(err);\n      return;\n    }\n    // Merge  first the types (where we don't need to check for duplicates\n    // since instantiating the service will take care of it), then the messages\n    // (where we need to, as duplicates will overwrite each other).\n    (importedSchema.types || []).forEach(function (typeSchema) {\n      // Ensure the imported protocol's namespace is inherited correctly (it\n      // might be different from the current one).\n      if (typeSchema.namespace === undefined) {\n        var namespace = importedSchema.namespace;\n        if (!namespace) {\n          var match = /^(.*)\\.[^.]+$/.exec(importedSchema.protocol);\n          if (match) {\n            namespace = match[1];\n          }\n        }\n        typeSchema.namespace = namespace || '';\n      }\n      importedTypes.push(typeSchema);\n    });\n    try {\n      Object.keys(importedSchema.messages || {}).forEach(function (name) {\n        if (!protocol.messages) {\n          protocol.messages = {};\n        }\n        if (protocol.messages[name]) {\n          throw new Error(f('duplicate message: %s', name));\n        }\n        protocol.messages[name] = importedSchema.messages[name];\n      });\n    } catch (err) {\n      cb(err);\n      return;\n    }\n    fetchImports(); // Continue importing any remaining imports.\n  }\n}\n\n// Parsing functions.\n\n/**\n * Convenience function to parse multiple inputs into protocols and schemas.\n *\n * It should cover most basic use-cases but has a few limitations:\n *\n * + It doesn't allow passing options to the parsing step.\n * + The protocol/type inference logic can be deceived.\n *\n * The parsing logic is as follows:\n *\n * + If `str` contains `path.sep` (on windows `\\`, otherwise `/`) and is a path\n *   to an existing file, it will first be read as JSON, then as an IDL\n *   specification if JSON parsing failed. If either succeeds, the result is\n *   returned, otherwise the next steps are run using the file's content\n *   instead of the input path.\n * + If `str` is a valid JSON string, it is parsed then returned.\n * + If `str` is a valid IDL protocol specification, it is parsed and returned\n *   if no imports are present (and an error is thrown if there are any\n *   imports).\n * + If `str` is a valid IDL type specification, it is parsed and returned.\n * + If neither of the above cases apply, `str` is returned.\n */\nfunction read(str) {\n  var schema;\n  if (typeof str == 'string' && ~str.indexOf(path.sep) && files.existsSync(str)) {\n    // Try interpreting `str` as path to a file contain a JSON schema or an IDL\n    // protocol. Note that we add the second check to skip primitive references\n    // (e.g. `\"int\"`, the most common use-case for `avro.parse`).\n    var contents = files.readFileSync(str, {encoding: 'utf8'});\n    try {\n      return JSON.parse(contents);\n    } catch (err) {\n      var opts = {importHook: files.createSyncImportHook()};\n      assembleProtocol(str, opts, function (err, protocolSchema) {\n        schema = err ? contents : protocolSchema;\n      });\n    }\n  } else {\n    schema = str;\n  }\n  if (typeof schema != 'string' || schema === 'null') {\n    // This last predicate is to allow `read('null')` to work similarly to\n    // `read('int')` and other primitives (null needs to be handled separately\n    // since it is also a valid JSON identifier).\n    return schema;\n  }\n  try {\n    return JSON.parse(schema);\n  } catch (err) {\n    try {\n      return Reader.readProtocol(schema);\n    } catch (err) {\n      try {\n        return Reader.readSchema(schema);\n      } catch (err) {\n        return schema;\n      }\n    }\n  }\n}\n\nfunction Reader(str, opts) {\n  opts = opts || {};\n\n  this._tk = new Tokenizer(str);\n  this._ackVoidMessages = !!opts.ackVoidMessages;\n  this._implicitTags = !opts.delimitedCollections;\n  this._typeRefs = opts.typeRefs || TYPE_REFS;\n}\n\nReader.readProtocol = function (str, opts) {\n  var reader = new Reader(str, opts);\n  var protocol = reader._readProtocol();\n  if (protocol.imports.length) {\n    // Imports can only be resolved when the IDL file is provided via its\n    // path, we fail rather than silently ignore imports.\n    throw new Error('unresolvable import');\n  }\n  return protocol.protocol;\n};\n\nReader.readSchema = function (str, opts) {\n  var reader = new Reader(str, opts);\n  var javadoc = reader._readJavadoc();\n  var schema = reader._readType(javadoc === undefined ? {} : {doc: javadoc});\n  reader._tk.next({id: '(eof)'}); // Check that we have read everything.\n  return schema;\n};\n\nReader.prototype._readProtocol = function () {\n  var tk = this._tk;\n  var imports = [];\n  var types = [];\n  var messages = {};\n  var pos;\n\n  // Outer declarations (outside of the protocol block).\n  this._readImports(imports);\n  var protocolSchema = {};\n  var protocolJavadoc = this._readJavadoc();\n  if (protocolJavadoc !== undefined) {\n    protocolSchema.doc = protocolJavadoc;\n  }\n  this._readAnnotations(protocolSchema);\n  tk.next({val: 'protocol'});\n  if (!tk.next({val: '{', silent: true})) {\n    // Named protocol.\n    protocolSchema.protocol = tk.next({id: 'name'}).val;\n    tk.next({val: '{'});\n  }\n\n  // Inner declarations.\n  while (!tk.next({val: '}', silent: true})) {\n    if (!this._readImports(imports)) {\n      var javadoc = this._readJavadoc();\n      var typeSchema = this._readType();\n      var numImports = this._readImports(imports, true);\n      var message = undefined;\n      // We mark our position and try to parse a message from here.\n      pos = tk.pos;\n      if (!numImports && (message = this._readMessage(typeSchema))) {\n        // Note that if any imports were found, we cannot be parsing a message.\n        if (javadoc !== undefined && message.schema.doc === undefined) {\n          message.schema.doc = javadoc;\n        }\n        var oneWay = false;\n        if (\n          message.schema.response === 'void' ||\n          message.schema.response.type === 'void'\n        ) {\n          oneWay = !this._ackVoidMessages && !message.schema.errors;\n          if (message.schema.response === 'void') {\n            message.schema.response = 'null';\n          } else {\n            message.schema.response.type = 'null';\n          }\n        }\n        if (oneWay) {\n          message.schema['one-way'] = true;\n        }\n        if (messages[message.name]) {\n          // We have to do this check here otherwise the duplicate will be\n          // overwritten (and service instantiation won't be able to catch it).\n          throw new Error(f('duplicate message: %s', message.name));\n        }\n        messages[message.name] = message.schema;\n      } else {\n        // This was a standalone type definition.\n        if (javadoc) {\n          if (typeof typeSchema == 'string') {\n            typeSchema = {doc: javadoc, type: typeSchema};\n          } else if (typeSchema.doc === undefined) {\n            typeSchema.doc = javadoc;\n          }\n        }\n        types.push(typeSchema);\n        // We backtrack until just before the type's type name and swallow an\n        // eventual semi-colon (to make type declarations more consistent).\n        tk.pos = pos;\n        tk.next({val: ';', silent: true});\n      }\n      javadoc = undefined;\n    }\n  }\n  tk.next({id: '(eof)'});\n  if (types.length) {\n    protocolSchema.types = types;\n  }\n  if (Object.keys(messages).length) {\n    protocolSchema.messages = messages;\n  }\n  return {protocol: protocolSchema, imports: imports};\n};\n\nReader.prototype._readAnnotations = function (schema) {\n  var tk = this._tk;\n  while (tk.next({val: '@', silent: true})) {\n    // Annotations are allowed to have names which aren't valid Avro names,\n    // we must advance until we hit the first left parenthesis.\n    var parts = [];\n    while (!tk.next({val: '(', silent: true})) {\n      parts.push(tk.next().val);\n    }\n    schema[parts.join('')] = tk.next({id: 'json'}).val;\n    tk.next({val: ')'});\n  }\n};\n\nReader.prototype._readMessage = function (responseSchema) {\n  var tk = this._tk;\n  var schema = {request: [], response: responseSchema};\n  this._readAnnotations(schema);\n  var name = tk.next().val;\n  if (tk.next().val !== '(') {\n    // This isn't a message.\n    return;\n  }\n  if (!tk.next({val: ')', silent: true})) {\n    do {\n      schema.request.push(this._readField());\n    } while (!tk.next({val: ')', silent: true}) && tk.next({val: ','}));\n  }\n  var token = tk.next();\n  switch (token.val) {\n    case 'throws':\n      // It doesn't seem like the IDL is explicit about which syntax to used\n      // for multiple errors. We will assume a comma-separated list.\n      schema.errors = [];\n      do {\n        schema.errors.push(this._readType());\n      } while (!tk.next({val: ';', silent: true}) && tk.next({val: ','}));\n      break;\n    case 'oneway':\n      schema['one-way'] = true;\n      tk.next({val: ';'});\n      break;\n    case ';':\n      break;\n    default:\n      throw tk.error('invalid message suffix', token);\n  }\n  return {name: name, schema: schema};\n};\n\nReader.prototype._readJavadoc = function () {\n  var token = this._tk.next({id: 'javadoc', emitJavadoc: true, silent: true});\n  if (token) {\n    return token.val;\n  }\n};\n\nReader.prototype._readField = function () {\n  var tk = this._tk;\n  var javadoc = this._readJavadoc();\n  var schema = {type: this._readType()};\n  if (javadoc !== undefined && schema.doc === undefined) {\n    schema.doc = javadoc;\n  }\n  this._readAnnotations(schema);\n  schema.name = tk.next({id: 'name'}).val;\n  if (tk.next({val: '=', silent: true})) {\n    schema['default'] = tk.next({id: 'json'}).val;\n  }\n  return schema;\n};\n\nReader.prototype._readType = function (schema) {\n  schema = schema || {};\n  this._readAnnotations(schema);\n  schema.type = this._tk.next({id: 'name'}).val;\n  switch (schema.type) {\n    case 'record':\n    case 'error':\n      return this._readRecord(schema);\n    case 'fixed':\n      return this._readFixed(schema);\n    case 'enum':\n      return this._readEnum(schema);\n    case 'map':\n      return this._readMap(schema);\n    case 'array':\n      return this._readArray(schema);\n    case 'union':\n      if (Object.keys(schema).length > 1) {\n        throw new Error('union annotations are not supported');\n      }\n      return this._readUnion();\n    default:\n      // Reference.\n      var ref = this._typeRefs[schema.type];\n      if (ref) {\n        delete schema.type; // Always overwrite the type.\n        utils.copyOwnProperties(ref, schema);\n      }\n      return Object.keys(schema).length > 1 ? schema : schema.type;\n  }\n};\n\nReader.prototype._readFixed = function (schema) {\n  var tk = this._tk;\n  if (!tk.next({val: '(', silent: true})) {\n    schema.name = tk.next({id: 'name'}).val;\n    tk.next({val: '('});\n  }\n  schema.size = parseInt(tk.next({id: 'number'}).val);\n  tk.next({val: ')'});\n  return schema;\n};\n\nReader.prototype._readMap = function (schema) {\n  var tk = this._tk;\n  // Brackets are unwieldy when declaring inline types. We allow for them to be\n  // omitted (but we keep the consistency that if the entry bracket is present,\n  // the exit one must be as well). Note that this is non-standard.\n  var silent = this._implicitTags;\n  var implicitTags = tk.next({val: '<', silent: silent}) === undefined;\n  schema.values = this._readType();\n  tk.next({val: '>', silent: implicitTags});\n  return schema;\n};\n\nReader.prototype._readArray = function (schema) {\n  var tk = this._tk;\n  var silent = this._implicitTags;\n  var implicitTags = tk.next({val: '<', silent: silent}) === undefined;\n  schema.items = this._readType();\n  tk.next({val: '>', silent: implicitTags});\n  return schema;\n};\n\nReader.prototype._readEnum = function (schema) {\n  var tk = this._tk;\n  if (!tk.next({val: '{', silent: true})) {\n    schema.name = tk.next({id: 'name'}).val;\n    tk.next({val: '{'});\n  }\n  schema.symbols = [];\n  do {\n    schema.symbols.push(tk.next().val);\n  } while (!tk.next({val: '}', silent: true}) && tk.next({val: ','}));\n  return schema;\n};\n\nReader.prototype._readUnion = function () {\n  var tk = this._tk;\n  var arr = [];\n  tk.next({val: '{'});\n  do {\n    arr.push(this._readType());\n  } while (!tk.next({val: '}', silent: true}) && tk.next({val: ','}));\n  return arr;\n};\n\nReader.prototype._readRecord = function (schema) {\n  var tk = this._tk;\n  if (!tk.next({val: '{', silent: true})) {\n    schema.name = tk.next({id: 'name'}).val;\n    tk.next({val: '{'});\n  }\n  schema.fields = [];\n  while (!tk.next({val: '}', silent: true})) {\n    schema.fields.push(this._readField());\n    tk.next({val: ';'});\n  }\n  return schema;\n};\n\nReader.prototype._readImports = function (imports, maybeMessage) {\n  var tk = this._tk;\n  var numImports = 0;\n  var pos = tk.pos;\n  while (tk.next({val: 'import', silent: true})) {\n    if (!numImports && maybeMessage && tk.next({val: '(', silent: true})) {\n      // This will happen if a message is named import.\n      tk.pos = pos;\n      return;\n    }\n    var kind = tk.next({id: 'name'}).val;\n    var fname = JSON.parse(tk.next({id: 'string'}).val);\n    tk.next({val: ';'});\n    imports.push({kind: kind, name: fname});\n    numImports++;\n  }\n  return numImports;\n};\n\n// Helpers.\n\n/**\n * Simple class to split an input string into tokens.\n *\n * There are different types of tokens, characterized by their `id`:\n *\n * + `number` numbers.\n * + `name` references.\n * + `string` double-quoted.\n * + `operator`, anything else, always single character.\n * + `javadoc`, only emitted when `next` is called with `emitJavadoc` set.\n * + `json`, only emitted when `next` is called with `'json'` as `id` (the\n *   tokenizer doesn't have enough context to predict these).\n */\nfunction Tokenizer(str) {\n  this._str = str;\n  this.pos = 0;\n}\n\nTokenizer.prototype.next = function (opts) {\n  var token = {pos: this.pos, id: undefined, val: undefined};\n  var javadoc = this._skip(opts && opts.emitJavadoc);\n  if (javadoc) {\n    token.id = 'javadoc';\n    token.val = javadoc;\n  } else {\n    var pos = this.pos;\n    var str = this._str;\n    var c = str.charAt(pos);\n    if (!c) {\n      token.id = '(eof)';\n    } else {\n      if (opts && opts.id === 'json') {\n        token.id = 'json';\n        this.pos = this._endOfJson();\n      } else if (c === '\"') {\n        token.id = 'string';\n        this.pos = this._endOfString();\n      } else if (/[0-9]/.test(c)) {\n        token.id = 'number';\n        this.pos = this._endOf(/[0-9]/);\n      } else if (/[`A-Za-z_.]/.test(c)) {\n        token.id = 'name';\n        this.pos = this._endOf(/[`A-Za-z0-9_.]/);\n      } else {\n        token.id = 'operator';\n        this.pos = pos + 1;\n      }\n      token.val = str.slice(pos, this.pos);\n      if (token.id === 'json') {\n        // Let's be nice and give a more helpful error message when this occurs\n        // (JSON parsing errors wouldn't let us find the location otherwise).\n        try {\n          token.val = JSON.parse(token.val);\n        } catch (err) {\n          throw this.error('invalid JSON', token);\n        }\n      } else if (token.id === 'name') {\n        // Unescape names (our parser doesn't need them).\n        token.val = token.val.replace(/`/g, '');\n      }\n    }\n  }\n\n  var err;\n  if (opts && opts.id && opts.id !== token.id) {\n    err = this.error(f('expected ID %s', opts.id), token);\n  } else if (opts && opts.val && opts.val !== token.val) {\n    err = this.error(f('expected value %s', opts.val), token);\n  }\n  if (!err) {\n    return token;\n  } else if (opts && opts.silent) {\n    this.pos = token.pos; // Backtrack to start of token.\n    return undefined;\n  } else {\n    throw err;\n  }\n};\n\nTokenizer.prototype.error = function (reason, context) {\n  // Context must be either a token or a position.\n  var isToken = typeof context != 'number';\n  var pos = isToken ? context.pos : context;\n  var str = this._str;\n  var lineNum = 1;\n  var lineStart = 0;\n  var i;\n  for (i = 0; i < pos; i++) {\n    if (str.charAt(i) === '\\n') {\n      lineNum++;\n      lineStart = i;\n    }\n  }\n  var msg = isToken ? f('invalid token %j: %s', context, reason) : reason;\n  var err = new Error(msg);\n  err.token = isToken ? context : undefined;\n  err.lineNum = lineNum;\n  err.colNum = pos - lineStart;\n  return err;\n};\n\n/** Skip whitespace and comments. */\nTokenizer.prototype._skip = function (emitJavadoc) {\n  var str = this._str;\n  var isJavadoc = false;\n  var pos, c;\n\n  while ((c = str.charAt(this.pos)) && /\\s/.test(c)) {\n    this.pos++;\n  }\n  pos = this.pos;\n  if (c === '/') {\n    switch (str.charAt(this.pos + 1)) {\n    case '/':\n      this.pos += 2;\n      while ((c = str.charAt(this.pos)) && c !== '\\n') {\n        this.pos++;\n      }\n      return this._skip(emitJavadoc);\n    case '*':\n      this.pos += 2;\n      if (str.charAt(this.pos) === '*') {\n        isJavadoc = true;\n      }\n      while ((c = str.charAt(this.pos++))) {\n        if (c === '*' && str.charAt(this.pos) === '/') {\n          this.pos++;\n          if (isJavadoc && emitJavadoc) {\n            return extractJavadoc(str.slice(pos + 3, this.pos - 2));\n          }\n          return this._skip(emitJavadoc);\n        }\n      }\n      throw this.error('unterminated comment', pos);\n    }\n  }\n};\n\n/** Generic end of method. */\nTokenizer.prototype._endOf = function (pat) {\n  var pos = this.pos;\n  var str = this._str;\n  while (pat.test(str.charAt(pos))) {\n    pos++;\n  }\n  return pos;\n};\n\n/** Find end of a string. */\nTokenizer.prototype._endOfString = function () {\n  var pos = this.pos + 1; // Skip first double quote.\n  var str = this._str;\n  var c;\n  while ((c = str.charAt(pos))) {\n    if (c === '\"') {\n      // The spec doesn't explicitly say so, but IDLs likely only\n      // allow double quotes for strings (C- and Java-style).\n      return pos + 1;\n    }\n    if (c === '\\\\') {\n      pos += 2;\n    } else {\n      pos++;\n    }\n  }\n  throw this.error('unterminated string', pos - 1);\n};\n\n/** Find end of JSON object, throwing an error if the end is reached first. */\nTokenizer.prototype._endOfJson = function () {\n  var pos = utils.jsonEnd(this._str, this.pos);\n  if (pos < 0) {\n    throw this.error('invalid JSON', pos);\n  }\n  return pos;\n};\n\n/**\n * Extract Javadoc contents from the comment.\n *\n * The parsing done is very simple and simply removes the line prefixes and\n * leading / trailing empty lines. It's better to be conservative with\n * formatting rather than risk losing information.\n */\nfunction extractJavadoc(str) {\n  var lines = str\n    .replace(/^[ \\t]+|[ \\t]+$/g, '') // Trim whitespace.\n    .split('\\n').map(function (line, i) {\n      return i ? line.replace(/^\\s*\\*\\s?/, '') : line;\n    });\n  while (!lines[0]) {\n    lines.shift();\n  }\n  while (!lines[lines.length - 1]) {\n    lines.pop();\n  }\n  return lines.join('\\n');\n}\n\n\nmodule.exports = {\n  Tokenizer: Tokenizer,\n  assembleProtocol: assembleProtocol,\n  read: read,\n  readProtocol: Reader.readProtocol,\n  readSchema: Reader.readSchema\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}