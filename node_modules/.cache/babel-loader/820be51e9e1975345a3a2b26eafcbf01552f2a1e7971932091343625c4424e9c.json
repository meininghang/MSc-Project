{"ast":null,"code":"/* jshint node: true */\n\n// TODO: Add broadcast option to client `_emitMessage`, accessible for one-way\n// messages.\n// TODO: Add `server.mount` method to allow combining servers. The API is as\n// follows: a mounted server's (i.e. the method's argument) handlers have lower\n// precedence than the original server (i.e. `this`); the mounted server's\n// middlewares are only invoked for its handlers.\n// TODO: Change `objectMode` client and server channel option to `encoding`\n// (accepting `'netty'`, `'standard'`, and `null` or `undefined`). Perhaps also\n// expose encoders (API TBD).\n\n'use strict';\n\n/** This module implements Avro's IPC/RPC logic. */\nrequire(\"core-js/modules/es.array.push.js\");\nvar types = require('./types'),\n  utils = require('./utils'),\n  events = require('events'),\n  stream = require('stream'),\n  util = require('util');\n\n// A few convenience imports.\nvar Tap = utils.Tap;\nvar Type = types.Type;\nvar debug = util.debuglog('avsc:services');\nvar f = util.format;\n\n// Various useful types. We instantiate options once, to share the registry.\nvar OPTS = {\n  namespace: 'org.apache.avro.ipc'\n};\nvar BOOLEAN_TYPE = Type.forSchema('boolean', OPTS);\nvar MAP_BYTES_TYPE = Type.forSchema({\n  type: 'map',\n  values: 'bytes'\n}, OPTS);\nvar STRING_TYPE = Type.forSchema('string', OPTS);\nvar HANDSHAKE_REQUEST_TYPE = Type.forSchema({\n  name: 'HandshakeRequest',\n  type: 'record',\n  fields: [{\n    name: 'clientHash',\n    type: {\n      name: 'MD5',\n      type: 'fixed',\n      size: 16\n    }\n  }, {\n    name: 'clientProtocol',\n    type: ['null', 'string'],\n    'default': null\n  }, {\n    name: 'serverHash',\n    type: 'MD5'\n  }, {\n    name: 'meta',\n    type: ['null', MAP_BYTES_TYPE],\n    'default': null\n  }]\n}, OPTS);\nvar HANDSHAKE_RESPONSE_TYPE = Type.forSchema({\n  name: 'HandshakeResponse',\n  type: 'record',\n  fields: [{\n    name: 'match',\n    type: {\n      name: 'HandshakeMatch',\n      type: 'enum',\n      symbols: ['BOTH', 'CLIENT', 'NONE']\n    }\n  }, {\n    name: 'serverProtocol',\n    type: ['null', 'string'],\n    'default': null\n  }, {\n    name: 'serverHash',\n    type: ['null', 'MD5'],\n    'default': null\n  }, {\n    name: 'meta',\n    type: ['null', MAP_BYTES_TYPE],\n    'default': null\n  }]\n}, OPTS);\n\n// Prefix used to differentiate between messages when sharing a stream. This\n// length should be smaller than 16. The remainder is used for disambiguating\n// between concurrent messages (the current value, 16, therefore supports ~64k\n// concurrent messages).\nvar PREFIX_LENGTH = 16;\n\n// Internal message, used to check protocol compatibility.\nvar PING_MESSAGE = new Message('',\n// Empty name (invalid for other \"normal\" messages).\nType.forSchema({\n  name: 'PingRequest',\n  type: 'record',\n  fields: []\n}, OPTS), Type.forSchema(['string'], OPTS), Type.forSchema('null', OPTS));\n\n/** An Avro message, containing its request, response, etc. */\nfunction Message(name, reqType, errType, resType, oneWay, doc) {\n  this.name = name;\n  if (!Type.isType(reqType, 'record')) {\n    throw new Error('invalid request type');\n  }\n  this.requestType = reqType;\n  if (!Type.isType(errType, 'union') || !Type.isType(errType.getTypes()[0], 'string')) {\n    throw new Error('invalid error type');\n  }\n  this.errorType = errType;\n  if (oneWay) {\n    if (!Type.isType(resType, 'null') || errType.getTypes().length > 1) {\n      throw new Error('inapplicable one-way parameter');\n    }\n  }\n  this.responseType = resType;\n  this.oneWay = !!oneWay;\n  this.doc = doc !== undefined ? '' + doc : undefined;\n  Object.freeze(this);\n}\nMessage.forSchema = function (name, schema, opts) {\n  opts = opts || {};\n  if (!types.isValidName(name)) {\n    throw new Error(f('invalid message name: %s', name));\n  }\n  // We use a record with a placeholder name here (the user might have set\n  // `noAnonymousTypes`, so we can't use an anonymous one). We remove it from\n  // the registry afterwards to avoid exposing it outside.\n  if (!Array.isArray(schema.request)) {\n    throw new Error(f('invalid message request: %s', name));\n  }\n  var recordName = f('%s.%sRequest', OPTS.namespace, utils.capitalize(name));\n  var reqType = Type.forSchema({\n    name: recordName,\n    type: 'record',\n    namespace: opts.namespace || '',\n    // Don't leak request namespace.\n    fields: schema.request\n  }, opts);\n  delete opts.registry[recordName];\n  if (!schema.response) {\n    throw new Error(f('invalid message response: %s', name));\n  }\n  var resType = Type.forSchema(schema.response, opts);\n  if (schema.errors !== undefined && !Array.isArray(schema.errors)) {\n    throw new Error(f('invalid message errors: %s', name));\n  }\n  var errType = Type.forSchema(['string'].concat(schema.errors || []), opts);\n  var oneWay = !!schema['one-way'];\n  return new Message(name, reqType, errType, resType, oneWay, schema.doc);\n};\nMessage.prototype.schema = Type.prototype.getSchema;\nMessage.prototype._attrs = function (opts) {\n  var reqSchema = this.requestType._attrs(opts);\n  var schema = {\n    request: reqSchema.fields,\n    response: this.responseType._attrs(opts)\n  };\n  var msgDoc = this.doc;\n  if (msgDoc !== undefined) {\n    schema.doc = msgDoc;\n  }\n  var errSchema = this.errorType._attrs(opts);\n  if (errSchema.length > 1) {\n    schema.errors = errSchema.slice(1);\n  }\n  if (this.oneWay) {\n    schema['one-way'] = true;\n  }\n  return schema;\n};\n\n// Deprecated.\n\nutils.addDeprecatedGetters(Message, ['name', 'errorType', 'requestType', 'responseType']);\nMessage.prototype.isOneWay = util.deprecate(function () {\n  return this.oneWay;\n}, 'use `.oneWay` directly instead of `.isOneWay()`');\n\n/**\n * An Avro RPC service.\n *\n * This constructor shouldn't be called directly, but via the\n * `Service.forProtocol` method. This function performs little logic to better\n * support efficient copy.\n */\nfunction Service(name, messages, types, ptcl, server) {\n  if (typeof name != 'string') {\n    // Let's be helpful in case this class is instantiated directly.\n    return Service.forProtocol(name, messages);\n  }\n  this.name = name;\n  this._messagesByName = messages || {};\n  this.messages = Object.freeze(utils.objectValues(this._messagesByName));\n  this._typesByName = types || {};\n  this.types = Object.freeze(utils.objectValues(this._typesByName));\n  this.protocol = ptcl;\n  // We cache a string rather than a buffer to not retain an entire slab.\n  this._hashStr = utils.getHash(JSON.stringify(ptcl)).toString('binary');\n  this.doc = ptcl.doc ? '' + ptcl.doc : undefined;\n\n  // We add a server to each protocol for backwards-compatibility (to allow the\n  // use of `protocol.on`). This covers all cases except the use of the\n  // `strictErrors` option, which requires moving to the new API.\n  this._server = server || this.createServer({\n    silent: true\n  });\n  Object.freeze(this);\n}\nService.Client = Client;\nService.Server = Server;\nService.compatible = function (clientSvc, serverSvc) {\n  try {\n    createReaders(clientSvc, serverSvc);\n  } catch (err) {\n    return false;\n  }\n  return true;\n};\nService.forProtocol = function (ptcl, opts) {\n  opts = opts || {};\n  var name = ptcl.protocol;\n  if (!name) {\n    throw new Error('missing protocol name');\n  }\n  if (ptcl.namespace !== undefined) {\n    opts.namespace = ptcl.namespace;\n  } else {\n    var match = /^(.*)\\.[^.]+$/.exec(name);\n    if (match) {\n      opts.namespace = match[1];\n    }\n  }\n  name = types.qualify(name, opts.namespace);\n  if (ptcl.types) {\n    ptcl.types.forEach(function (obj) {\n      Type.forSchema(obj, opts);\n    });\n  }\n  var msgs;\n  if (ptcl.messages) {\n    msgs = {};\n    Object.keys(ptcl.messages).forEach(function (key) {\n      msgs[key] = Message.forSchema(key, ptcl.messages[key], opts);\n    });\n  }\n  return new Service(name, msgs, opts.registry, ptcl);\n};\nService.isService = function (any) {\n  // Not fool-proof but likely sufficient.\n  return !!any && any.hasOwnProperty('_hashStr');\n};\nService.prototype.createClient = function (opts) {\n  var client = new Client(this, opts);\n  process.nextTick(function () {\n    // We delay this processing such that we can attach handlers to the client\n    // before any channels get created.\n    if (opts && opts.server) {\n      // Convenience in-memory client. This can be useful to make requests\n      // relatively efficiently to an in-process server. Note that it is still\n      // is less efficient than direct method calls (because of the\n      // serialization, which does provide \"type-safety\" though).\n      var obj = {\n        objectMode: true\n      };\n      var pts = [new stream.PassThrough(obj), new stream.PassThrough(obj)];\n      opts.server.createChannel({\n        readable: pts[0],\n        writable: pts[1]\n      }, obj);\n      client.createChannel({\n        readable: pts[1],\n        writable: pts[0]\n      }, obj);\n    } else if (opts && opts.transport) {\n      // Convenience functionality for the common single channel use-case: we\n      // add a single channel using default options to the client.\n      client.createChannel(opts.transport);\n    }\n  });\n  return client;\n};\nService.prototype.createServer = function (opts) {\n  return new Server(this, opts);\n};\nObject.defineProperty(Service.prototype, 'hash', {\n  enumerable: true,\n  get: function () {\n    return utils.bufferFrom(this._hashStr, 'binary');\n  }\n});\nService.prototype.message = function (name) {\n  return this._messagesByName[name];\n};\nService.prototype.type = function (name) {\n  return this._typesByName[name];\n};\nService.prototype.inspect = function () {\n  return f('<Service %j>', this.name);\n};\n\n// Deprecated methods.\n\nutils.addDeprecatedGetters(Service, ['message', 'messages', 'name', 'type', 'types']);\nService.prototype.createEmitter = util.deprecate(function (transport, opts) {\n  opts = opts || {};\n  var client = this.createClient({\n    cache: opts.cache,\n    buffering: false,\n    strictTypes: opts.strictErrors,\n    timeout: opts.timeout\n  });\n  var channel = client.createChannel(transport, opts);\n  forwardErrors(client, channel);\n  return channel;\n}, 'use `.createClient()` instead of `.createEmitter()`');\nService.prototype.createListener = util.deprecate(function (transport, opts) {\n  if (opts && opts.strictErrors) {\n    throw new Error('use `.createServer()` to support strict errors');\n  }\n  return this._server.createChannel(transport, opts);\n}, 'use `.createServer().createChannel()` instead of `.createListener()`');\nService.prototype.emit = util.deprecate(function (name, req, channel, cb) {\n  if (!channel || !this.equals(channel.client._svc$)) {\n    throw new Error('invalid emitter');\n  }\n  var client = channel.client;\n  // In case the method is overridden.\n  Client.prototype.emitMessage.call(client, name, req, cb && cb.bind(this));\n  return channel.getPending();\n}, 'create a client via `.createClient()` to emit messages instead of `.emit()`');\nService.prototype.equals = util.deprecate(function (any) {\n  return Service.isService(any) && this.getFingerprint().equals(any.getFingerprint());\n}, 'equality testing is deprecated, compare the `.protocol`s instead');\nService.prototype.getFingerprint = util.deprecate(function (algorithm) {\n  return utils.getHash(JSON.stringify(this.protocol), algorithm);\n}, 'use `.hash` instead of `.getFingerprint()`');\nService.prototype.getSchema = util.deprecate(Type.prototype.getSchema, 'use `.protocol` instead of `.getSchema()`');\nService.prototype.on = util.deprecate(function (name, handler) {\n  var self = this; // This protocol.\n  this._server.onMessage(name, function (req, cb) {\n    return handler.call(self, req, this.channel, cb);\n  });\n  return this;\n}, 'use `.createServer().onMessage()` instead of `.on()`');\nService.prototype.subprotocol = util.deprecate(function () {\n  var parent = this._server;\n  var opts = {\n    strictTypes: parent._strict,\n    cache: parent._cache\n  };\n  var server = new Server(parent.service, opts);\n  server._handlers = Object.create(parent._handlers);\n  return new Service(this.name, this._messagesByName, this._typesByName, this.protocol, server);\n}, '`.subprotocol()` will be removed in 5.1');\nService.prototype._attrs = function (opts) {\n  var ptcl = {\n    protocol: this.name\n  };\n  var types = [];\n  this.types.forEach(function (t) {\n    if (t.getName() === undefined) {\n      // Don't include any unnamed types (e.g. primitives).\n      return;\n    }\n    var typeSchema = t._attrs(opts);\n    if (typeof typeSchema != 'string') {\n      // Some of the named types might already have been defined in a\n      // previous type, in this case we don't include its reference.\n      types.push(typeSchema);\n    }\n  });\n  if (types.length) {\n    ptcl.types = types;\n  }\n  var msgNames = Object.keys(this._messagesByName);\n  if (msgNames.length) {\n    ptcl.messages = {};\n    msgNames.forEach(function (name) {\n      ptcl.messages[name] = this._messagesByName[name]._attrs(opts);\n    }, this);\n  }\n  if (opts && opts.exportAttrs && this.doc !== undefined) {\n    ptcl.doc = this.doc;\n  }\n  return ptcl;\n};\n\n/** Function to retrieve a remote service's protocol. */\nfunction discoverProtocol(transport, opts, cb) {\n  if (cb === undefined && typeof opts == 'function') {\n    cb = opts;\n    opts = undefined;\n  }\n  var svc = new Service({\n    protocol: 'Empty'\n  }, OPTS);\n  var ptclStr;\n  svc.createClient({\n    timeout: opts && opts.timeout\n  }).createChannel(transport, {\n    scope: opts && opts.scope,\n    endWritable: typeof transport == 'function' // Stateless transports only.\n  }).once('handshake', function (hreq, hres) {\n    ptclStr = hres.serverProtocol;\n    this.destroy(true);\n  }).once('eot', function (pending, err) {\n    // Stateless transports will throw an interrupted error when the\n    // channel is destroyed, we ignore it here.\n    if (err && !/interrupted/.test(err)) {\n      cb(err); // Likely timeout.\n    } else {\n      cb(null, JSON.parse(ptclStr));\n    }\n  });\n}\n\n/** Load-balanced message sender. */\nfunction Client(svc, opts) {\n  opts = opts || {};\n  events.EventEmitter.call(this);\n\n  // We have to suffix all client properties to be safe, since the message\n  // names aren't prefixed with clients (unlike servers).\n  this._svc$ = svc;\n  this._channels$ = []; // Active channels.\n  this._fns$ = []; // Middleware functions.\n\n  this._buffering$ = !!opts.buffering;\n  this._cache$ = opts.cache || {}; // For backwards compatibility.\n  this._policy$ = opts.channelPolicy;\n  this._strict$ = !!opts.strictTypes;\n  this._timeout$ = utils.getOption(opts, 'timeout', 10000);\n  if (opts.remoteProtocols) {\n    insertRemoteProtocols(this._cache$, opts.remoteProtocols, svc, true);\n  }\n  this._svc$.messages.forEach(function (msg) {\n    this[msg.name] = this._createMessageHandler$(msg);\n  }, this);\n}\nutil.inherits(Client, events.EventEmitter);\nClient.prototype.activeChannels = function () {\n  return this._channels$.slice();\n};\nClient.prototype.createChannel = function (transport, opts) {\n  var objectMode = opts && opts.objectMode;\n  var channel;\n  if (typeof transport == 'function') {\n    var writableFactory;\n    if (objectMode) {\n      writableFactory = transport;\n    } else {\n      // We provide a default standard-compliant codec. This should support\n      // most use-cases (for example when speaking to the official Java and\n      // Python implementations over HTTP, or when this library is used for\n      // both the emitting and listening sides).\n      writableFactory = function (cb) {\n        var encoder = new FrameEncoder();\n        var writable = transport(function (err, readable) {\n          if (err) {\n            cb(err);\n            return;\n          }\n          // Since the decoder isn't exposed (so can't have an error handler\n          // attached, we forward any errors to the client). Since errors would\n          // only get thrown when the decoder flushes (if there is trailing\n          // data), at which point the source will have ended, there is no need\n          // to add re-piping logic (destination errors trigger an unpipe).\n          var decoder = new FrameDecoder().once('error', function (err) {\n            channel.destroy(err);\n          });\n          cb(null, readable.pipe(decoder));\n        });\n        if (writable) {\n          encoder.pipe(writable);\n          return encoder;\n        }\n      };\n    }\n    channel = new StatelessClientChannel(this, writableFactory, opts);\n  } else {\n    var readable, writable;\n    if (isStream(transport)) {\n      readable = writable = transport;\n    } else {\n      readable = transport.readable;\n      writable = transport.writable;\n    }\n    if (!objectMode) {\n      // To ease communication with Java servers, we provide a default codec\n      // compatible with Java servers' `NettyTransportCodec`'s implementation.\n      var decoder = new NettyDecoder();\n      readable = readable.pipe(decoder);\n      var encoder = new NettyEncoder();\n      encoder.pipe(writable);\n      writable = encoder;\n    }\n    channel = new StatefulClientChannel(this, readable, writable, opts);\n    if (!objectMode) {\n      // Since we never expose the automatically created encoder and decoder,\n      // we release them ourselves here when the channel ends. (Unlike for\n      // stateless channels, it is conceivable for the underlying stream to be\n      // reused afterwards).\n      channel.once('eot', function () {\n        readable.unpipe(decoder);\n        encoder.unpipe(writable);\n      });\n      // We also forward any (trailing data) error.\n      decoder.once('error', function (err) {\n        channel.destroy(err);\n      });\n    }\n  }\n  var channels = this._channels$;\n  channels.push(channel);\n  channel.once('_drain', function () {\n    // Remove the channel from the list of active ones.\n    channels.splice(channels.indexOf(this), 1);\n  });\n  // We restrict buffering to startup, otherwise we risk silently hiding errors\n  // (especially since channel timeouts don't apply yet).\n  this._buffering$ = false;\n  this.emit('channel', channel);\n  return channel;\n};\nClient.prototype.destroyChannels = function (opts) {\n  this._channels$.forEach(function (channel) {\n    channel.destroy(opts && opts.noWait);\n  });\n};\nClient.prototype.emitMessage = function (name, req, opts, cb) {\n  var msg = getExistingMessage(this._svc$, name);\n  var wreq = new WrappedRequest(msg, {}, req);\n  this._emitMessage$(wreq, opts, cb);\n};\nClient.prototype.remoteProtocols = function () {\n  return getRemoteProtocols(this._cache$, true);\n};\nObject.defineProperty(Client.prototype, 'service', {\n  enumerable: true,\n  get: function () {\n    return this._svc$;\n  }\n});\nClient.prototype.use = function /* fn ... */\n() {\n  var i, l, fn;\n  for (i = 0, l = arguments.length; i < l; i++) {\n    fn = arguments[i];\n    this._fns$.push(fn.length < 3 ? fn(this) : fn);\n  }\n  return this;\n};\nClient.prototype._emitMessage$ = function (wreq, opts, cb) {\n  // Common logic between `client.emitMessage` and the \"named\" message methods.\n  if (!cb && typeof opts === 'function') {\n    cb = opts;\n    opts = undefined;\n  }\n  var self = this;\n  var channels = this._channels$;\n  var numChannels = channels.length;\n  if (!numChannels) {\n    if (this._buffering$) {\n      debug('no active client channels, buffering call');\n      this.once('channel', function () {\n        this._emitMessage$(wreq, opts, cb);\n      });\n    } else {\n      var err = new Error('no active channels');\n      process.nextTick(function () {\n        if (cb) {\n          cb.call(new CallContext(wreq._msg), err);\n        } else {\n          self.emit('error', err);\n        }\n      });\n    }\n    return;\n  }\n  opts = opts || {};\n  if (opts.timeout === undefined) {\n    opts.timeout = this._timeout$;\n  }\n  var channel;\n  if (numChannels === 1) {\n    // Common case, optimized away.\n    channel = channels[0];\n  } else if (this._policy$) {\n    channel = this._policy$(this._channels$.slice());\n    if (!channel) {\n      debug('policy returned no channel, skipping call');\n      return;\n    }\n  } else {\n    // Random selection, cheap and likely good enough for most use-cases.\n    channel = channels[Math.floor(Math.random() * numChannels)];\n  }\n  channel._emit(wreq, opts, function (err, wres) {\n    var ctx = this; // Call context.\n    var errType = ctx.message.errorType;\n    if (err) {\n      // System error, likely the message wasn't sent (or an error occurred\n      // while decoding the response).\n      if (self._strict$) {\n        err = errType.clone(err.message, {\n          wrapUnions: true\n        });\n      }\n      done(err);\n      return;\n    }\n    if (!wres) {\n      // This is a one way message.\n      done();\n      return;\n    }\n    // Message transmission succeeded, we transmit the message data; massaging\n    // any error strings into actual `Error` objects in non-strict mode.\n    err = wres.error;\n    if (!self._strict$) {\n      // Try to coerce an eventual error into more idiomatic JavaScript types:\n      // `undefined` becomes `null` and a remote string \"system\" error is\n      // wrapped inside an actual `Error` object.\n      if (err === undefined) {\n        err = null;\n      } else {\n        if (Type.isType(errType, 'union:unwrapped')) {\n          if (typeof err == 'string') {\n            err = new Error(err);\n          }\n        } else if (err && err.string && typeof err.string == 'string') {\n          err = new Error(err.string);\n        }\n      }\n    }\n    done(err, wres.response);\n    function done(err, res) {\n      if (cb) {\n        cb.call(ctx, err, res);\n      } else if (err) {\n        self.emit('error', err);\n      }\n    }\n  });\n};\nClient.prototype._createMessageHandler$ = function (msg) {\n  // jshint -W054\n  var fields = msg.requestType.getFields();\n  var names = fields.map(function (f) {\n    return f.getName();\n  });\n  var body = 'return function ' + msg.name + '(';\n  if (names.length) {\n    body += names.join(', ') + ', ';\n  }\n  body += 'opts, cb) {\\n';\n  body += '  var req = {';\n  body += names.map(function (n) {\n    return n + ': ' + n;\n  }).join(', ');\n  body += '};\\n';\n  body += '  return this.emitMessage(\\'' + msg.name + '\\', req, opts, cb);\\n';\n  body += '};';\n  return new Function(body)();\n};\n\n/** Message receiver. */\nfunction Server(svc, opts) {\n  opts = opts || {};\n  events.EventEmitter.call(this);\n  this.service = svc;\n  this._handlers = {};\n  this._fns = []; // Middleware functions.\n  this._channels = {}; // Active channels.\n  this._nextChannelId = 1;\n  this._cache = opts.cache || {}; // Deprecated.\n  this._defaultHandler = opts.defaultHandler;\n  this._sysErrFormatter = opts.systemErrorFormatter;\n  this._silent = !!opts.silent;\n  this._strict = !!opts.strictTypes;\n  if (opts.remoteProtocols) {\n    insertRemoteProtocols(this._cache, opts.remoteProtocols, svc, false);\n  }\n  svc.messages.forEach(function (msg) {\n    var name = msg.name;\n    if (!opts.noCapitalize) {\n      name = utils.capitalize(name);\n    }\n    this['on' + name] = this._createMessageHandler(msg);\n  }, this);\n}\nutil.inherits(Server, events.EventEmitter);\nServer.prototype.activeChannels = function () {\n  return utils.objectValues(this._channels);\n};\nServer.prototype.createChannel = function (transport, opts) {\n  var objectMode = opts && opts.objectMode;\n  var channel;\n  if (typeof transport == 'function') {\n    var readableFactory;\n    if (objectMode) {\n      readableFactory = transport;\n    } else {\n      readableFactory = function (cb) {\n        var decoder = new FrameDecoder().once('error', function (err) {\n          channel.destroy(err);\n        });\n        return transport(function (err, writable) {\n          if (err) {\n            cb(err);\n            return;\n          }\n          var encoder = new FrameEncoder();\n          encoder.pipe(writable);\n          cb(null, encoder);\n        }).pipe(decoder);\n      };\n    }\n    channel = new StatelessServerChannel(this, readableFactory, opts);\n  } else {\n    var readable, writable;\n    if (isStream(transport)) {\n      readable = writable = transport;\n    } else {\n      readable = transport.readable;\n      writable = transport.writable;\n    }\n    if (!objectMode) {\n      var decoder = new NettyDecoder();\n      readable = readable.pipe(decoder);\n      var encoder = new NettyEncoder();\n      encoder.pipe(writable);\n      writable = encoder;\n    }\n    channel = new StatefulServerChannel(this, readable, writable, opts);\n    if (!objectMode) {\n      // Similar to client channels, since we never expose the encoder and\n      // decoder, we must release them ourselves here.\n      channel.once('eot', function () {\n        readable.unpipe(decoder);\n        encoder.unpipe(writable);\n      });\n      decoder.once('error', function (err) {\n        channel.destroy(err);\n      });\n    }\n  }\n  if (!this.listeners('error').length) {\n    this.on('error', this._onError);\n  }\n  var channelId = this._nextChannelId++;\n  var channels = this._channels;\n  channels[channelId] = channel.once('eot', function () {\n    delete channels[channelId];\n  });\n  this.emit('channel', channel);\n  return channel;\n};\nServer.prototype.onMessage = function (name, handler) {\n  getExistingMessage(this.service, name); // Check message existence.\n  this._handlers[name] = handler;\n  return this;\n};\nServer.prototype.remoteProtocols = function () {\n  return getRemoteProtocols(this._cache, false);\n};\nServer.prototype.use = function /* fn ... */\n() {\n  var i, l, fn;\n  for (i = 0, l = arguments.length; i < l; i++) {\n    fn = arguments[i];\n    this._fns.push(fn.length < 3 ? fn(this) : fn);\n  }\n  return this;\n};\nServer.prototype._createMessageHandler = function (msg) {\n  // jshint -W054\n  var name = msg.name;\n  var fields = msg.requestType.fields;\n  var numArgs = fields.length;\n  var args = fields.length ? ', ' + fields.map(function (f) {\n    return 'req.' + f.name;\n  }).join(', ') : '';\n  // We are careful to not lose the initial handler's number of arguments (or\n  // more specifically whether it would have access to the callback or not).\n  // This is useful to implement \"smart promisification\" logic downstream.\n  var body = 'return function (handler) {\\n';\n  body += '  if (handler.length > ' + numArgs + ') {\\n';\n  body += '    return this.onMessage(\\'' + name + '\\', function (req, cb) {\\n';\n  body += '      return handler.call(this' + args + ', cb);\\n';\n  body += '    });\\n';\n  body += '  } else {\\n';\n  body += '    return this.onMessage(\\'' + name + '\\', function (req) {\\n';\n  body += '      return handler.call(this' + args + ');\\n';\n  body += '    });\\n';\n  body += '  }\\n';\n  body += '};\\n';\n  return new Function(body)();\n};\nServer.prototype._onError = function (err) {\n  /* istanbul ignore if */\n  if (!this._silent && err.rpcCode !== 'UNKNOWN_PROTOCOL') {\n    console.error();\n    if (err.rpcCode) {\n      console.error(err.rpcCode);\n      console.error(err.cause);\n    } else {\n      console.error('INTERNAL_SERVER_ERROR');\n      console.error(err);\n    }\n  }\n};\n\n/** Base message emitter class. See below for the two available variants. */\nfunction ClientChannel(client, opts) {\n  opts = opts || {};\n  events.EventEmitter.call(this);\n  this.client = client;\n  this.timeout = utils.getOption(opts, 'timeout', client._timeout$);\n  this._endWritable = !!utils.getOption(opts, 'endWritable', true);\n  this._prefix = normalizedPrefix(opts.scope);\n  var cache = client._cache$;\n  var clientSvc = client._svc$;\n  var hash = opts.serverHash;\n  if (!hash) {\n    hash = clientSvc.hash;\n  }\n  var adapter = cache[hash];\n  if (!adapter) {\n    // This might happen even if the server hash option was set if the cache\n    // doesn't contain the corresponding adapter. In this case we fall back to\n    // the client's protocol (as mandated by the spec).\n    hash = clientSvc.hash;\n    adapter = cache[hash] = new Adapter(clientSvc, clientSvc, hash);\n  }\n  this._adapter = adapter;\n  this._registry = new Registry(this, PREFIX_LENGTH);\n  this.pending = 0;\n  this.destroyed = false;\n  this.draining = false;\n  this.once('_eot', function (pending, err) {\n    // Since this listener is only run once, we will only forward an error if\n    // it is present during the initial `destroy` call, which is OK.\n    debug('client channel EOT');\n    this.destroyed = true;\n    this.emit('eot', pending, err);\n  });\n}\nutil.inherits(ClientChannel, events.EventEmitter);\nClientChannel.prototype.destroy = function (noWait) {\n  debug('destroying client channel');\n  if (!this.draining) {\n    this.draining = true;\n    this.emit('_drain');\n  }\n  var registry = this._registry;\n  var pending = this.pending;\n  if (noWait) {\n    registry.clear();\n  }\n  if (noWait || !pending) {\n    if (isError(noWait)) {\n      debug('fatal client channel error: %s', noWait);\n      this.emit('_eot', pending, noWait);\n    } else {\n      this.emit('_eot', pending);\n    }\n  } else {\n    debug('client channel entering drain mode (%s pending)', pending);\n  }\n};\nClientChannel.prototype.ping = function (timeout, cb) {\n  if (!cb && typeof timeout == 'function') {\n    cb = timeout;\n    timeout = undefined;\n  }\n  var self = this;\n  var wreq = new WrappedRequest(PING_MESSAGE);\n  this._emit(wreq, {\n    timeout: timeout\n  }, function (err) {\n    if (cb) {\n      cb.call(self, err);\n    } else if (err) {\n      self.destroy(err);\n    }\n  });\n};\nClientChannel.prototype._createHandshakeRequest = function (adapter, noSvc) {\n  var svc = this.client._svc$;\n  return {\n    clientHash: svc.hash,\n    clientProtocol: noSvc ? null : JSON.stringify(svc.protocol),\n    serverHash: adapter._hash\n  };\n};\nClientChannel.prototype._emit = function (wreq, opts, cb) {\n  var msg = wreq._msg;\n  var wres = msg.oneWay ? undefined : new WrappedResponse(msg, {});\n  var ctx = new CallContext(msg, this);\n  var self = this;\n  this.pending++;\n  process.nextTick(function () {\n    if (!msg.name) {\n      // Ping request, bypass middleware.\n      onTransition(wreq, wres, onCompletion);\n    } else {\n      self.emit('outgoingCall', ctx, opts);\n      var fns = self.client._fns$;\n      debug('starting client middleware chain (%s middleware)', fns.length);\n      chainMiddleware({\n        fns: fns,\n        ctx: ctx,\n        wreq: wreq,\n        wres: wres,\n        onTransition: onTransition,\n        onCompletion: onCompletion,\n        onError: onError\n      });\n    }\n  });\n  function onTransition(wreq, wres, prev) {\n    // Serialize the message.\n    var err, reqBuf;\n    if (self.destroyed) {\n      err = new Error('channel destroyed');\n    } else {\n      try {\n        reqBuf = wreq.toBuffer();\n      } catch (cause) {\n        err = serializationError(f('invalid %j request', msg.name), wreq, [{\n          name: 'headers',\n          type: MAP_BYTES_TYPE\n        }, {\n          name: 'request',\n          type: msg.requestType\n        }]);\n      }\n    }\n    if (err) {\n      prev(err);\n      return;\n    }\n\n    // Generate the response callback.\n    var timeout = opts && opts.timeout !== undefined ? opts.timeout : self.timeout;\n    var id = self._registry.add(timeout, function (err, resBuf, adapter) {\n      if (!err && !msg.oneWay) {\n        try {\n          adapter._decodeResponse(resBuf, wres, msg);\n        } catch (cause) {\n          err = cause;\n        }\n      }\n      prev(err);\n    });\n    id |= self._prefix;\n    debug('sending message %s', id);\n    self._send(id, reqBuf, !!msg && msg.oneWay);\n  }\n  function onCompletion(err) {\n    self.pending--;\n    cb.call(ctx, err, wres);\n    if (self.draining && !self.destroyed && !self.pending) {\n      self.destroy();\n    }\n  }\n  function onError(err) {\n    // This will happen if a middleware callback is called multiple times. We\n    // forward the error to the client rather than emit it on the channel since\n    // middleware are a client-level abstraction, so better handled there.\n    self.client.emit('error', err, self);\n  }\n};\nClientChannel.prototype._getAdapter = function (hres) {\n  var hash = hres.serverHash;\n  var cache = this.client._cache$;\n  var adapter = cache[hash];\n  if (adapter) {\n    return adapter;\n  }\n  var ptcl = JSON.parse(hres.serverProtocol);\n  var serverSvc = Service.forProtocol(ptcl);\n  adapter = new Adapter(this.client._svc$, serverSvc, hash, true);\n  return cache[hash] = adapter;\n};\nClientChannel.prototype._matchesPrefix = function (id) {\n  return matchesPrefix(id, this._prefix);\n};\nClientChannel.prototype._send = utils.abstractFunction;\n\n// Deprecated.\n\nutils.addDeprecatedGetters(ClientChannel, ['pending', 'timeout']);\nClientChannel.prototype.getCache = util.deprecate(function () {\n  return this.client._cache$;\n}, 'use `.remoteProtocols()` instead of `.getCache()`');\nClientChannel.prototype.getProtocol = util.deprecate(function () {\n  return this.client._svc$;\n}, 'use `.service` instead or `.getProtocol()`');\nClientChannel.prototype.isDestroyed = util.deprecate(function () {\n  return this.destroyed;\n}, 'use `.destroyed` instead of `.isDestroyed`');\n\n/**\n * Factory-based client channel.\n *\n * This channel doesn't keep a persistent connection to the server and requires\n * prepending a handshake to each message emitted. Usage examples include\n * talking to an HTTP server (where the factory returns an HTTP request).\n *\n * Since each message will use its own writable/readable stream pair, the\n * advantage of this channel is that it is able to keep track of which response\n * corresponds to each request without relying on transport ordering. In\n * particular, this means these channels are compatible with any server\n * implementation.\n */\nfunction StatelessClientChannel(client, writableFactory, opts) {\n  ClientChannel.call(this, client, opts);\n  this._writableFactory = writableFactory;\n  if (!opts || !opts.noPing) {\n    // Ping the server to check whether the remote protocol is compatible.\n    // If not, this will throw an error on the channel.\n    debug('emitting ping request');\n    this.ping();\n  }\n}\nutil.inherits(StatelessClientChannel, ClientChannel);\nStatelessClientChannel.prototype._send = function (id, reqBuf) {\n  var cb = this._registry.get(id);\n  var adapter = this._adapter;\n  var self = this;\n  process.nextTick(emit);\n  return true;\n  function emit(retry) {\n    if (self.destroyed) {\n      // The request's callback will already have been called.\n      return;\n    }\n    var hreq = self._createHandshakeRequest(adapter, !retry);\n    var writable = self._writableFactory.call(self, function (err, readable) {\n      if (err) {\n        cb(err);\n        return;\n      }\n      readable.on('data', function (obj) {\n        debug('received response %s', obj.id);\n        // We don't check that the prefix matches since the ID likely hasn't\n        // been propagated to the response (see default stateless codec).\n        var buf = Buffer.concat(obj.payload);\n        try {\n          var parts = readHead(HANDSHAKE_RESPONSE_TYPE, buf);\n          var hres = parts.head;\n          if (hres.serverHash) {\n            adapter = self._getAdapter(hres);\n          }\n        } catch (cause) {\n          cb(cause);\n          return;\n        }\n        var match = hres.match;\n        debug('handshake match: %s', match);\n        self.emit('handshake', hreq, hres);\n        if (match === 'NONE') {\n          // Try again, including the full protocol this time.\n          process.nextTick(function () {\n            emit(true);\n          });\n        } else {\n          // Change the default adapter.\n          self._adapter = adapter;\n          cb(null, parts.tail, adapter);\n        }\n      });\n    });\n    if (!writable) {\n      cb(new Error('invalid writable stream'));\n      return;\n    }\n    writable.write({\n      id: id,\n      payload: [HANDSHAKE_REQUEST_TYPE.toBuffer(hreq), reqBuf]\n    });\n    if (self._endWritable) {\n      writable.end();\n    }\n  }\n};\n\n/**\n * Multiplexing client channel.\n *\n * These channels reuse the same streams (both readable and writable) for all\n * messages. This avoids a lot of overhead (e.g. creating new connections,\n * re-issuing handshakes) but requires the underlying transport to support\n * forwarding message IDs.\n */\nfunction StatefulClientChannel(client, readable, writable, opts) {\n  ClientChannel.call(this, client, opts);\n  this._readable = readable;\n  this._writable = writable;\n  this._connected = !!(opts && opts.noPing);\n  this._readable.on('end', onEnd);\n  this._writable.on('finish', onFinish);\n  var self = this;\n  var timer = null;\n  this.once('eot', function () {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n    if (!self._connected) {\n      // Clear any buffered calls (they are guaranteed to error out when\n      // reaching the transition phase).\n      self.emit('_ready');\n    }\n    // Remove references to this channel to avoid potential memory leaks.\n    this._writable.removeListener('finish', onFinish);\n    if (this._endWritable) {\n      debug('ending transport');\n      this._writable.end();\n    }\n    this._readable.removeListener('data', onPing).removeListener('data', onMessage).removeListener('end', onEnd);\n  });\n  var hreq; // For handshake events.\n  if (this._connected) {\n    this._readable.on('data', onMessage);\n  } else {\n    this._readable.on('data', onPing);\n    process.nextTick(ping);\n    if (self.timeout) {\n      timer = setTimeout(function () {\n        self.destroy(new Error('timeout'));\n      }, self.timeout);\n    }\n  }\n  function ping(retry) {\n    if (self.destroyed) {\n      return;\n    }\n    hreq = self._createHandshakeRequest(self._adapter, !retry);\n    var payload = [HANDSHAKE_REQUEST_TYPE.toBuffer(hreq), utils.bufferFrom([0, 0]) // No header, no data (empty message name).\n    ];\n    // We can use a static ID here since we are guaranteed that this message is\n    // the only one on the channel (for this scope at least).\n    self._writable.write({\n      id: self._prefix,\n      payload: payload\n    });\n  }\n  function onPing(obj) {\n    if (!self._matchesPrefix(obj.id)) {\n      debug('discarding unscoped response %s (still connecting)', obj.id);\n      return;\n    }\n    var buf = Buffer.concat(obj.payload);\n    try {\n      var hres = readHead(HANDSHAKE_RESPONSE_TYPE, buf).head;\n      if (hres.serverHash) {\n        self._adapter = self._getAdapter(hres);\n      }\n    } catch (cause) {\n      // This isn't a recoverable error.\n      self.destroy(cause);\n      return;\n    }\n    var match = hres.match;\n    debug('handshake match: %s', match);\n    self.emit('handshake', hreq, hres);\n    if (match === 'NONE') {\n      process.nextTick(function () {\n        ping(true);\n      });\n    } else {\n      debug('successfully connected');\n      if (timer) {\n        clearTimeout(timer);\n        timer = null;\n      }\n      self._readable.removeListener('data', onPing).on('data', onMessage);\n      self._connected = true;\n      self.emit('_ready');\n      hreq = null; // Release reference.\n    }\n  }\n\n  // Callback used after a connection has been established.\n  function onMessage(obj) {\n    var id = obj.id;\n    if (!self._matchesPrefix(id)) {\n      debug('discarding unscoped message %s', id);\n      return;\n    }\n    var cb = self._registry.get(id);\n    if (cb) {\n      process.nextTick(function () {\n        debug('received message %s', id);\n        // Ensure that the initial callback gets called asynchronously, even\n        // for completely synchronous transports (otherwise the number of\n        // pending requests will sometimes be inconsistent between stateful and\n        // stateless transports).\n        cb(null, Buffer.concat(obj.payload), self._adapter);\n      });\n    }\n  }\n  function onEnd() {\n    self.destroy(true);\n  }\n  function onFinish() {\n    self.destroy();\n  }\n}\nutil.inherits(StatefulClientChannel, ClientChannel);\nStatefulClientChannel.prototype._emit = function () {\n  // Override this method to allow calling `_emit` even before the channel is\n  // connected. Note that we don't perform this logic in `_send` since we want\n  // to guarantee that `'handshake'` events are emitted before any\n  // `'outgoingCall'` events.\n  if (this._connected || this.draining) {\n    ClientChannel.prototype._emit.apply(this, arguments);\n  } else {\n    debug('queuing request');\n    var args = [];\n    var i, l;\n    for (i = 0, l = arguments.length; i < l; i++) {\n      args.push(arguments[i]);\n    }\n    this.once('_ready', function () {\n      this._emit.apply(this, args);\n    });\n  }\n};\nStatefulClientChannel.prototype._send = function (id, reqBuf, oneWay) {\n  if (oneWay) {\n    var self = this;\n    // Clear the callback, passing in an empty header.\n    process.nextTick(function () {\n      self._registry.get(id)(null, utils.bufferFrom([0, 0, 0]), self._adapter);\n    });\n  }\n  return this._writable.write({\n    id: id,\n    payload: [reqBuf]\n  });\n};\n\n/** The server-side emitter equivalent. */\nfunction ServerChannel(server, opts) {\n  opts = opts || {};\n  events.EventEmitter.call(this);\n  this.server = server;\n  this._endWritable = !!utils.getOption(opts, 'endWritable', true);\n  this._prefix = normalizedPrefix(opts.scope);\n  var cache = server._cache;\n  var svc = server.service;\n  var hash = svc.hash;\n  if (!cache[hash]) {\n    // Add the channel's protocol to the cache if it isn't already there. This\n    // will save a handshake the first time on channels with the same protocol.\n    cache[hash] = new Adapter(svc, svc, hash);\n  }\n  this._adapter = null;\n  this.destroyed = false;\n  this.draining = false;\n  this.pending = 0;\n  this.once('_eot', function (pending, err) {\n    debug('server channel EOT');\n    this.emit('eot', pending, err);\n  });\n}\nutil.inherits(ServerChannel, events.EventEmitter);\nServerChannel.prototype.destroy = function (noWait) {\n  if (!this.draining) {\n    this.draining = true;\n    this.emit('_drain');\n  }\n  if (noWait || !this.pending) {\n    this.destroyed = true;\n    if (isError(noWait)) {\n      debug('fatal server channel error: %s', noWait);\n      this.emit('_eot', this.pending, noWait);\n    } else {\n      this.emit('_eot', this.pending);\n    }\n  }\n};\nServerChannel.prototype._createHandshakeResponse = function (err, hreq) {\n  var svc = this.server.service;\n  var buf = svc.hash;\n  var serverMatch = hreq && hreq.serverHash.equals(buf);\n  return {\n    match: err ? 'NONE' : serverMatch ? 'BOTH' : 'CLIENT',\n    serverProtocol: serverMatch ? null : JSON.stringify(svc.protocol),\n    serverHash: serverMatch ? null : buf\n  };\n};\nServerChannel.prototype._getAdapter = function (hreq) {\n  var hash = hreq.clientHash;\n  var adapter = this.server._cache[hash];\n  if (adapter) {\n    return adapter;\n  }\n  if (!hreq.clientProtocol) {\n    throw toRpcError('UNKNOWN_PROTOCOL');\n  }\n  var ptcl = JSON.parse(hreq.clientProtocol);\n  var clientSvc = Service.forProtocol(ptcl);\n  adapter = new Adapter(clientSvc, this.server.service, hash, true);\n  return this.server._cache[hash] = adapter;\n};\nServerChannel.prototype._matchesPrefix = function (id) {\n  return matchesPrefix(id, this._prefix);\n};\nServerChannel.prototype._receive = function (reqBuf, adapter, cb) {\n  var self = this;\n  var wreq;\n  try {\n    wreq = adapter._decodeRequest(reqBuf);\n  } catch (cause) {\n    cb(self._encodeSystemError(toRpcError('INVALID_REQUEST', cause)));\n    return;\n  }\n  var msg = wreq._msg;\n  var wres = new WrappedResponse(msg, {});\n  if (!msg.name) {\n    // Ping message, we don't invoke middleware logic in this case.\n    wres.response = null;\n    cb(wres.toBuffer(), false);\n    return;\n  }\n  var ctx = new CallContext(msg, this);\n  self.emit('incomingCall', ctx);\n  var fns = this.server._fns;\n  debug('starting server middleware chain (%s middleware)', fns.length);\n  self.pending++;\n  chainMiddleware({\n    fns: fns,\n    ctx: ctx,\n    wreq: wreq,\n    wres: wres,\n    onTransition: onTransition,\n    onCompletion: onCompletion,\n    onError: onError\n  });\n  function onTransition(wreq, wres, prev) {\n    var handler = self.server._handlers[msg.name];\n    if (!handler) {\n      // The underlying service hasn't implemented a handler.\n      var defaultHandler = self.server._defaultHandler;\n      if (defaultHandler) {\n        // We call the default handler with arguments similar (slightly\n        // simpler, there are no phases here) to middleware such that it can\n        // easily access the message name (useful to implement proxies).\n        defaultHandler.call(ctx, wreq, wres, prev);\n      } else {\n        var cause = new Error(f('no handler for %s', msg.name));\n        prev(toRpcError('NOT_IMPLEMENTED', cause));\n      }\n    } else {\n      var pending = !msg.oneWay;\n      try {\n        if (pending) {\n          handler.call(ctx, wreq.request, function (err, res) {\n            pending = false;\n            wres.error = err;\n            wres.response = res;\n            prev();\n          });\n        } else {\n          handler.call(ctx, wreq.request);\n          prev();\n        }\n      } catch (err) {\n        // We catch synchronous failures (same as express) and return the\n        // failure. Note that the server process can still crash if an error\n        // is thrown after the handler returns but before the response is\n        // sent (again, same as express). We are careful to only trigger the\n        // response callback once, emitting the errors afterwards instead.\n        if (pending) {\n          pending = false;\n          prev(err);\n        } else {\n          onError(err);\n        }\n      }\n    }\n  }\n  function onCompletion(err) {\n    self.pending--;\n    var server = self.server;\n    var resBuf;\n    if (!err) {\n      var resErr = wres.error;\n      var isStrict = server._strict;\n      if (!isStrict) {\n        if (isError(resErr)) {\n          // If the error type is wrapped, we must wrap the error too.\n          wres.error = msg.errorType.clone(resErr.message, {\n            wrapUnions: true\n          });\n        } else if (resErr === null) {\n          // We also allow `null`'s as error in this mode, converting them to\n          // the Avro-compatible `undefined`.\n          resErr = wres.error = undefined;\n        }\n        if (resErr === undefined && wres.response === undefined && msg.responseType.isValid(null)) {\n          // Finally, for messages with `null` as acceptable response type, we\n          // allow `undefined`; converting them to `null`. This allows users to\n          // write a more natural `cb()` instead of `cb(null, null)`.\n          wres.response = null;\n        }\n      }\n      try {\n        resBuf = wres.toBuffer();\n      } catch (cause) {\n        // Note that we don't add an RPC code here such that the client\n        // receives the default `INTERNAL_SERVER_ERROR` one.\n        if (wres.error !== undefined) {\n          err = serializationError(f('invalid %j error', msg.name),\n          // Sic.\n          wres, [{\n            name: 'headers',\n            type: MAP_BYTES_TYPE\n          }, {\n            name: 'error',\n            type: msg.errorType\n          }]);\n        } else {\n          err = serializationError(f('invalid %j response', msg.name), wres, [{\n            name: 'headers',\n            type: MAP_BYTES_TYPE\n          }, {\n            name: 'response',\n            type: msg.responseType\n          }]);\n        }\n      }\n    }\n    if (!resBuf) {\n      // The headers are only available if the message isn't one-way.\n      resBuf = self._encodeSystemError(err, wres.headers);\n    } else if (resErr !== undefined) {\n      server.emit('error', toRpcError('APPLICATION_ERROR', resErr));\n    }\n    cb(resBuf, msg.oneWay);\n    if (self.draining && !self.pending) {\n      self.destroy();\n    }\n  }\n  function onError(err) {\n    // Similar to the client equivalent, we redirect this error to the server\n    // since middleware are defined at server-level.\n    self.server.emit('error', err, self);\n  }\n};\n\n// Deprecated.\n\nutils.addDeprecatedGetters(ServerChannel, ['pending']);\nServerChannel.prototype.getCache = util.deprecate(function () {\n  return this.server._cache;\n}, 'use `.remoteProtocols()` instead of `.getCache()`');\nServerChannel.prototype.getProtocol = util.deprecate(function () {\n  return this.server.service;\n}, 'use `.service` instead of `.getProtocol()`');\nServerChannel.prototype.isDestroyed = util.deprecate(function () {\n  return this.destroyed;\n}, 'use `.destroyed` instead of `.isDestroyed`');\n\n/**\n * Encode an error and optional header into a valid Avro response.\n *\n * @param err {Error} Error to encode.\n * @param header {Object} Optional response header.\n */\nServerChannel.prototype._encodeSystemError = function (err, header) {\n  var server = this.server;\n  server.emit('error', err, this);\n  var errStr;\n  if (server._sysErrFormatter) {\n    // Format the error into a string to send over the wire.\n    errStr = server._sysErrFormatter.call(this, err);\n  } else if (err.rpcCode) {\n    // By default, only forward the error's message when the RPC code is set\n    // (i.e. when this isn't an internal server error).\n    errStr = err.message;\n  }\n  var hdrBuf;\n  if (header) {\n    try {\n      // Propagate the header if possible.\n      hdrBuf = MAP_BYTES_TYPE.toBuffer(header);\n    } catch (cause) {\n      server.emit('error', cause, this);\n    }\n  }\n  return Buffer.concat([hdrBuf || utils.bufferFrom([0]), utils.bufferFrom([1, 0]),\n  // Error flag and first union index.\n  STRING_TYPE.toBuffer(errStr || 'internal server error')]);\n};\n\n/**\n * Server channel for stateless transport.\n *\n * This channel expect a handshake to precede each message.\n */\nfunction StatelessServerChannel(server, readableFactory, opts) {\n  ServerChannel.call(this, server, opts);\n  this._writable = undefined;\n  var self = this;\n  var readable;\n  process.nextTick(function () {\n    // Delay listening to allow handlers to be attached even if the factory is\n    // purely synchronous.\n    readable = readableFactory.call(self, function (err, writable) {\n      process.nextTick(function () {\n        // We delay once more here in case this call is synchronous, to allow\n        // the readable to always be populated first.\n        if (err) {\n          onFinish(err);\n          return;\n        }\n        self._writable = writable.on('finish', onFinish);\n        self.emit('_writable');\n      });\n    }).on('data', onRequest).on('end', onEnd);\n  });\n  function onRequest(obj) {\n    var id = obj.id;\n    var buf = Buffer.concat(obj.payload);\n    var err;\n    try {\n      var parts = readHead(HANDSHAKE_REQUEST_TYPE, buf);\n      var hreq = parts.head;\n      var adapter = self._getAdapter(hreq);\n    } catch (cause) {\n      err = toRpcError('INVALID_HANDSHAKE_REQUEST', cause);\n    }\n    var hres = self._createHandshakeResponse(err, hreq);\n    self.emit('handshake', hreq, hres);\n    if (err) {\n      done(self._encodeSystemError(err));\n    } else {\n      self._receive(parts.tail, adapter, done);\n    }\n    function done(resBuf) {\n      if (!self.destroyed) {\n        if (!self._writable) {\n          self.once('_writable', function () {\n            done(resBuf);\n          });\n          return;\n        }\n        self._writable.write({\n          id: id,\n          payload: [HANDSHAKE_RESPONSE_TYPE.toBuffer(hres), resBuf]\n        });\n      }\n      if (self._writable && self._endWritable) {\n        self._writable.end();\n      }\n    }\n  }\n  function onEnd() {\n    self.destroy();\n  }\n  function onFinish(err) {\n    readable.removeListener('data', onRequest).removeListener('end', onEnd);\n    self.destroy(err || true);\n  }\n}\nutil.inherits(StatelessServerChannel, ServerChannel);\n\n/**\n * Stateful transport listener.\n *\n * A handshake is done when the channel first receives a message, then all\n * messages are sent without.\n */\nfunction StatefulServerChannel(server, readable, writable, opts) {\n  ServerChannel.call(this, server, opts);\n  this._adapter = undefined;\n  this._writable = writable.on('finish', onFinish);\n  this._readable = readable.on('data', onHandshake).on('end', onEnd);\n  this.once('_drain', function () {\n    // Stop listening to incoming events.\n    this._readable.removeListener('data', onHandshake).removeListener('data', onRequest).removeListener('end', onEnd);\n  }).once('eot', function () {\n    // Clean up any references to the channel on the underlying streams.\n    this._writable.removeListener('finish', onFinish);\n    if (this._endWritable) {\n      this._writable.end();\n    }\n  });\n  var self = this;\n  function onHandshake(obj) {\n    var id = obj.id;\n    if (!self._matchesPrefix(id)) {\n      return;\n    }\n    var buf = Buffer.concat(obj.payload);\n    var err;\n    try {\n      var parts = readHead(HANDSHAKE_REQUEST_TYPE, buf);\n      var hreq = parts.head;\n      self._adapter = self._getAdapter(hreq);\n    } catch (cause) {\n      err = toRpcError('INVALID_HANDSHAKE_REQUEST', cause);\n    }\n    var hres = self._createHandshakeResponse(err, hreq);\n    self.emit('handshake', hreq, hres);\n    if (err) {\n      // Either the client's protocol was unknown or it isn't compatible.\n      done(self._encodeSystemError(err));\n    } else {\n      self._readable.removeListener('data', onHandshake).on('data', onRequest);\n      self._receive(parts.tail, self._adapter, done);\n    }\n    function done(resBuf) {\n      if (self.destroyed) {\n        return;\n      }\n      self._writable.write({\n        id: id,\n        payload: [HANDSHAKE_RESPONSE_TYPE.toBuffer(hres), resBuf]\n      });\n    }\n  }\n  function onRequest(obj) {\n    // These requests are not prefixed with handshakes.\n    var id = obj.id;\n    if (!self._matchesPrefix(id)) {\n      return;\n    }\n    var reqBuf = Buffer.concat(obj.payload);\n    self._receive(reqBuf, self._adapter, function (resBuf, oneWay) {\n      if (self.destroyed || oneWay) {\n        return;\n      }\n      self._writable.write({\n        id: id,\n        payload: [resBuf]\n      });\n    });\n  }\n  function onEnd() {\n    self.destroy();\n  }\n  function onFinish() {\n    self.destroy(true);\n  }\n}\nutil.inherits(StatefulServerChannel, ServerChannel);\n\n// Helpers.\n\n/** Enhanced request, used inside forward middleware functions. */\nfunction WrappedRequest(msg, hdrs, req) {\n  this._msg = msg;\n  this.headers = hdrs || {};\n  this.request = req || {};\n}\nWrappedRequest.prototype.toBuffer = function () {\n  var msg = this._msg;\n  return Buffer.concat([MAP_BYTES_TYPE.toBuffer(this.headers), STRING_TYPE.toBuffer(msg.name), msg.requestType.toBuffer(this.request)]);\n};\n\n/** Enhanced response, used inside forward middleware functions. */\nfunction WrappedResponse(msg, hdr, err, res) {\n  this._msg = msg;\n  this.headers = hdr;\n  this.error = err;\n  this.response = res;\n}\nWrappedResponse.prototype.toBuffer = function () {\n  var hdr = MAP_BYTES_TYPE.toBuffer(this.headers);\n  var hasError = this.error !== undefined;\n  return Buffer.concat([hdr, BOOLEAN_TYPE.toBuffer(hasError), hasError ? this._msg.errorType.toBuffer(this.error) : this._msg.responseType.toBuffer(this.response)]);\n};\n\n/**\n * Context for all middleware and handlers.\n *\n * It exposes a `locals` object which can be used to pass information between\n * each other during a given call.\n */\nfunction CallContext(msg, channel) {\n  this.channel = channel;\n  this.locals = {};\n  this.message = msg;\n  Object.freeze(this);\n}\n\n/**\n * Callback registry.\n *\n * Callbacks added must accept an error as first argument. This is used by\n * client channels to store pending calls. This class isn't exposed by the\n * public API.\n */\nfunction Registry(ctx, prefixLength) {\n  this._ctx = ctx; // Context for all callbacks.\n  this._mask = ~0 >>> (prefixLength | 0); // 16 bits by default.\n  this._id = 0; // Unique integer ID for each call.\n  this._n = 0; // Number of pending calls.\n  this._cbs = {};\n}\nRegistry.prototype.get = function (id) {\n  return this._cbs[id & this._mask];\n};\nRegistry.prototype.add = function (timeout, fn) {\n  this._id = this._id + 1 & this._mask;\n  var self = this;\n  var id = this._id;\n  var timer;\n  if (timeout > 0) {\n    timer = setTimeout(function () {\n      cb(new Error('timeout'));\n    }, timeout);\n  }\n  this._cbs[id] = cb;\n  this._n++;\n  return id;\n  function cb() {\n    if (!self._cbs[id]) {\n      // The callback has already run.\n      return;\n    }\n    delete self._cbs[id];\n    self._n--;\n    if (timer) {\n      clearTimeout(timer);\n    }\n    fn.apply(self._ctx, arguments);\n  }\n};\nRegistry.prototype.clear = function () {\n  Object.keys(this._cbs).forEach(function (id) {\n    this._cbs[id](new Error('interrupted'));\n  }, this);\n};\n\n/**\n * Service resolution helper.\n *\n * It is used both by client and server channels, to respectively decode errors\n * and responses, or requests.\n */\nfunction Adapter(clientSvc, serverSvc, hash, isRemote) {\n  this._clientSvc = clientSvc;\n  this._serverSvc = serverSvc;\n  this._hash = hash; // Convenience to access it when creating handshakes.\n  this._isRemote = !!isRemote;\n  this._readers = createReaders(clientSvc, serverSvc);\n}\nAdapter.prototype._decodeRequest = function (buf) {\n  var tap = new Tap(buf);\n  var hdr = MAP_BYTES_TYPE._read(tap);\n  var name = STRING_TYPE._read(tap);\n  var msg, req;\n  if (name) {\n    msg = this._serverSvc.message(name);\n    req = this._readers[name + '?']._read(tap);\n  } else {\n    msg = PING_MESSAGE;\n  }\n  if (!tap.isValid()) {\n    throw new Error(f('truncated %s request', name || 'ping$'));\n  }\n  return new WrappedRequest(msg, hdr, req);\n};\nAdapter.prototype._decodeResponse = function (buf, wres, msg) {\n  var tap = new Tap(buf);\n  utils.copyOwnProperties(MAP_BYTES_TYPE._read(tap), wres.headers, true);\n  var isError = BOOLEAN_TYPE._read(tap);\n  var name = msg.name;\n  if (name) {\n    var reader = this._readers[name + (isError ? '*' : '!')];\n    msg = this._clientSvc.message(name);\n    if (isError) {\n      wres.error = reader._read(tap);\n    } else {\n      wres.response = reader._read(tap);\n    }\n    if (!tap.isValid()) {\n      throw new Error(f('truncated %s response', name));\n    }\n  } else {\n    msg = PING_MESSAGE;\n  }\n};\n\n/** Standard \"un-framing\" stream. */\nfunction FrameDecoder() {\n  stream.Transform.call(this, {\n    readableObjectMode: true\n  });\n  this._id = undefined;\n  this._buf = utils.newBuffer(0);\n  this._bufs = [];\n  this.on('finish', function () {\n    this.push(null);\n  });\n}\nutil.inherits(FrameDecoder, stream.Transform);\nFrameDecoder.prototype._transform = function (buf, encoding, cb) {\n  buf = Buffer.concat([this._buf, buf]);\n  var frameLength;\n  while (buf.length >= 4 && buf.length >= (frameLength = buf.readInt32BE(0)) + 4) {\n    if (frameLength) {\n      this._bufs.push(buf.slice(4, frameLength + 4));\n    } else {\n      var bufs = this._bufs;\n      this._bufs = [];\n      this.push({\n        id: null,\n        payload: bufs\n      });\n    }\n    buf = buf.slice(frameLength + 4);\n  }\n  this._buf = buf;\n  cb();\n};\nFrameDecoder.prototype._flush = function () {\n  if (this._buf.length || this._bufs.length) {\n    var bufs = this._bufs.slice();\n    bufs.unshift(this._buf);\n    var err = toRpcError('TRAILING_DATA');\n    // Attach the data to help debugging (e.g. if the encoded bytes contain a\n    // human-readable protocol like HTTP).\n    err.trailingData = Buffer.concat(bufs).toString();\n    this.emit('error', err);\n  }\n};\n\n/** Standard framing stream. */\nfunction FrameEncoder() {\n  stream.Transform.call(this, {\n    writableObjectMode: true\n  });\n  this.on('finish', function () {\n    this.push(null);\n  });\n}\nutil.inherits(FrameEncoder, stream.Transform);\nFrameEncoder.prototype._transform = function (obj, encoding, cb) {\n  var bufs = obj.payload;\n  var i, l, buf;\n  for (i = 0, l = bufs.length; i < l; i++) {\n    buf = bufs[i];\n    this.push(intBuffer(buf.length));\n    this.push(buf);\n  }\n  this.push(intBuffer(0));\n  cb();\n};\n\n/** Netty-compatible decoding stream. */\nfunction NettyDecoder() {\n  stream.Transform.call(this, {\n    readableObjectMode: true\n  });\n  this._id = undefined;\n  this._frameCount = 0;\n  this._buf = utils.newBuffer(0);\n  this._bufs = [];\n  this.on('finish', function () {\n    this.push(null);\n  });\n}\nutil.inherits(NettyDecoder, stream.Transform);\nNettyDecoder.prototype._transform = function (buf, encoding, cb) {\n  buf = Buffer.concat([this._buf, buf]);\n  while (true) {\n    if (this._id === undefined) {\n      if (buf.length < 8) {\n        this._buf = buf;\n        cb();\n        return;\n      }\n      this._id = buf.readInt32BE(0);\n      this._frameCount = buf.readInt32BE(4);\n      buf = buf.slice(8);\n    }\n    var frameLength;\n    while (this._frameCount && buf.length >= 4 && buf.length >= (frameLength = buf.readInt32BE(0)) + 4) {\n      this._frameCount--;\n      this._bufs.push(buf.slice(4, frameLength + 4));\n      buf = buf.slice(frameLength + 4);\n    }\n    if (this._frameCount) {\n      this._buf = buf;\n      cb();\n      return;\n    } else {\n      var obj = {\n        id: this._id,\n        payload: this._bufs\n      };\n      this._bufs = [];\n      this._id = undefined;\n      this.push(obj);\n    }\n  }\n};\nNettyDecoder.prototype._flush = FrameDecoder.prototype._flush;\n\n/** Netty-compatible encoding stream. */\nfunction NettyEncoder() {\n  stream.Transform.call(this, {\n    writableObjectMode: true\n  });\n  this.on('finish', function () {\n    this.push(null);\n  });\n}\nutil.inherits(NettyEncoder, stream.Transform);\nNettyEncoder.prototype._transform = function (obj, encoding, cb) {\n  var bufs = obj.payload;\n  var l = bufs.length;\n  var buf;\n  // Header: [ ID, number of frames ]\n  buf = utils.newBuffer(8);\n  buf.writeInt32BE(obj.id, 0);\n  buf.writeInt32BE(l, 4);\n  this.push(buf);\n  // Frames, each: [ length, bytes ]\n  var i;\n  for (i = 0; i < l; i++) {\n    buf = bufs[i];\n    this.push(intBuffer(buf.length));\n    this.push(buf);\n  }\n  cb();\n};\n\n/**\n * Returns a buffer containing an integer's big-endian representation.\n *\n * @param n {Number} Integer.\n */\nfunction intBuffer(n) {\n  var buf = utils.newBuffer(4);\n  buf.writeInt32BE(n);\n  return buf;\n}\n\n/**\n * Decode a type used as prefix inside a buffer.\n *\n * @param type {Type} The type of the prefix.\n * @param buf {Buffer} Encoded bytes.\n *\n * This function will return an object `{head, tail}` where head contains the\n * decoded value and tail the rest of the buffer. An error will be thrown if\n * the prefix cannot be decoded.\n */\nfunction readHead(type, buf) {\n  var tap = new Tap(buf);\n  var head = type._read(tap);\n  if (!tap.isValid()) {\n    throw new Error(f('truncated %s', type));\n  }\n  return {\n    head: head,\n    tail: tap.buf.slice(tap.pos)\n  };\n}\n\n/**\n * Generate a decoder, optimizing the case where reader and writer are equal.\n *\n * @param rtype {Type} Reader's type.\n * @param wtype {Type} Writer's type.\n */\nfunction createReader(rtype, wtype) {\n  return rtype.equals(wtype) ? rtype : rtype.createResolver(wtype);\n}\n\n/**\n * Generate all readers for a given protocol combination.\n *\n * @param clientSvc {Service} Client service.\n * @param serverSvc {Service} Client service.\n */\nfunction createReaders(clientSvc, serverSvc) {\n  var obj = {};\n  clientSvc.messages.forEach(function (c) {\n    var n = c.name;\n    var s = serverSvc.message(n);\n    try {\n      if (!s) {\n        throw new Error(f('missing server message: %s', n));\n      }\n      if (s.oneWay !== c.oneWay) {\n        throw new Error(f('inconsistent one-way message: %s', n));\n      }\n      obj[n + '?'] = createReader(s.requestType, c.requestType);\n      obj[n + '*'] = createReader(c.errorType, s.errorType);\n      obj[n + '!'] = createReader(c.responseType, s.responseType);\n    } catch (cause) {\n      throw toRpcError('INCOMPATIBLE_PROTOCOL', cause);\n    }\n  });\n  return obj;\n}\n\n/**\n * Populate a cache from a list of protocols.\n *\n * @param cache {Object} Cache of adapters.\n * @param svc {Service} The local service (either client or server).\n * @param ptcls {Array} Array of protocols to insert.\n * @param isClient {Boolean} Whether the local service is a client's or\n * server's.\n */\nfunction insertRemoteProtocols(cache, ptcls, svc, isClient) {\n  Object.keys(ptcls).forEach(function (hash) {\n    var ptcl = ptcls[hash];\n    var clientSvc, serverSvc;\n    if (isClient) {\n      clientSvc = svc;\n      serverSvc = Service.forProtocol(ptcl);\n    } else {\n      clientSvc = Service.forProtocol(ptcl);\n      serverSvc = svc;\n    }\n    cache[hash] = new Adapter(clientSvc, serverSvc, hash, true);\n  });\n}\n\n/**\n * Extract remote protocols from a cache\n *\n * @param cache {Object} Cache of adapters.\n * @param isClient {Boolean} Whether the remote protocols extracted should be\n * the servers' or clients'.\n */\nfunction getRemoteProtocols(cache, isClient) {\n  var ptcls = {};\n  Object.keys(cache).forEach(function (hs) {\n    var adapter = cache[hs];\n    if (adapter._isRemote) {\n      var svc = isClient ? adapter._serverSvc : adapter._clientSvc;\n      ptcls[hs] = svc.protocol;\n    }\n  });\n  return ptcls;\n}\n\n/**\n * Check whether something is an `Error`.\n *\n * @param any {Object} Any object.\n */\nfunction isError(any) {\n  // Also not ideal, but avoids brittle `instanceof` checks.\n  return !!any && Object.prototype.toString.call(any) === '[object Error]';\n}\n\n/**\n * Forward any errors emitted on the source to the destination.\n *\n * @param src {EventEmitter} The initial source of error events.\n * @param dst {EventEmitter} The new target of the source's error events. The\n * original source will be provided as second argument (the error being the\n * first).\n *\n * As a convenience, the source will be returned.\n */\nfunction forwardErrors(src, dst) {\n  return src.on('error', function (err) {\n    dst.emit('error', err, src);\n  });\n}\n\n/**\n * Create an error.\n *\n * @param msg {String} Error message.\n * @param cause {Error} The cause of the error. It is available as `cause`\n * field on the outer error.\n */\nfunction toError(msg, cause) {\n  var err = new Error(msg);\n  err.cause = cause;\n  return err;\n}\n\n/**\n * Mark an error.\n *\n * @param rpcCode {String} Code representing the failure.\n * @param cause {Error} The cause of the error. It is available as `cause`\n * field on the outer error.\n *\n * This is used to keep the argument of channels' `'error'` event errors.\n */\nfunction toRpcError(rpcCode, cause) {\n  var err = toError(rpcCode.toLowerCase().replace(/_/g, ' '), cause);\n  err.rpcCode = cause && cause.rpcCode ? cause.rpcCode : rpcCode;\n  return err;\n}\n\n/**\n * Provide a helpful error to identify why serialization failed.\n *\n * @param err {Error} The error to decorate.\n * @param obj {...} The object containing fields to validated.\n * @param fields {Array} Information about the fields to validate.\n */\nfunction serializationError(msg, obj, fields) {\n  var details = [];\n  var i, l, field;\n  for (i = 0, l = fields.length; i < l; i++) {\n    field = fields[i];\n    field.type.isValid(obj[field.name], {\n      errorHook: errorHook\n    });\n  }\n  var detailsStr = details.map(function (obj) {\n    return f('%s = %j but expected %s', obj.path, obj.value, obj.type);\n  }).join(', ');\n  var err = new Error(f('%s (%s)', msg, detailsStr));\n  err.details = details;\n  return err;\n  function errorHook(parts, any, type) {\n    var strs = [];\n    var i, l, part;\n    for (i = 0, l = parts.length; i < l; i++) {\n      part = parts[i];\n      if (isNaN(part)) {\n        strs.push('.' + part);\n      } else {\n        strs.push('[' + part + ']');\n      }\n    }\n    details.push({\n      path: field.name + strs.join(''),\n      value: any,\n      type: type\n    });\n  }\n}\n\n/**\n * Compute a prefix of fixed length from a string.\n *\n * @param scope {String} Namespace to be hashed.\n */\nfunction normalizedPrefix(scope) {\n  return scope ? utils.getHash(scope).readInt16BE(0) << 32 - PREFIX_LENGTH : 0;\n}\n\n/**\n * Check whether an ID matches the prefix.\n *\n * @param id {Integer} Number to check.\n * @param prefix {Integer} Already shifted prefix.\n */\nfunction matchesPrefix(id, prefix) {\n  return (id ^ prefix) >> 32 - PREFIX_LENGTH === 0;\n}\n\n/**\n * Check whether something is a stream.\n *\n * @param any {Object} Any object.\n */\nfunction isStream(any) {\n  // This is a hacky way of checking that the transport is a stream-like\n  // object. We unfortunately can't use `instanceof Stream` checks since\n  // some libraries (e.g. websocket-stream) return streams which don't\n  // inherit from it.\n  return !!(any && any.pipe);\n}\n\n/**\n * Get a message, asserting that it exists.\n *\n * @param svc {Service} The protocol to look into.\n * @param name {String} The message's name.\n */\nfunction getExistingMessage(svc, name) {\n  var msg = svc.message(name);\n  if (!msg) {\n    throw new Error(f('unknown message: %s', name));\n  }\n  return msg;\n}\n\n/**\n * Middleware logic.\n *\n * This is used both in clients and servers to intercept call handling (e.g. to\n * populate headers, do access control).\n *\n * @param params {Object} The following parameters:\n *  + fns {Array} Array of middleware functions.\n *  + ctx {Object} Context used to call the middleware functions, onTransition,\n *    and onCompletion.\n *  + wreq {WrappedRequest}\n *  + wres {WrappedResponse}\n *  + onTransition {Function} End of forward phase callback. It accepts an\n *    eventual error as single argument. This will be used for the backward\n *    phase. This function is guaranteed to be called at most once.\n *  + onCompletion {Function} Final handler, it takes an error as unique\n *    argument. This function is guaranteed to be only at most once.\n *  + onError {Function} Error handler, called if an intermediate callback is\n *    called multiple times.\n */\nfunction chainMiddleware(params) {\n  var args = [params.wreq, params.wres];\n  var cbs = [];\n  var cause; // Backpropagated error.\n  forward(0);\n  function forward(pos) {\n    var isDone = false;\n    if (pos < params.fns.length) {\n      params.fns[pos].apply(params.ctx, args.concat(function (err, cb) {\n        if (isDone) {\n          params.onError(toError('duplicate forward middleware call', err));\n          return;\n        }\n        isDone = true;\n        if (err || params.wres && (\n        // Non one-way messages.\n        params.wres.error !== undefined || params.wres.response !== undefined)) {\n          // Stop the forward phase, bypass the handler, and start the backward\n          // phase. Note that we ignore any callback argument in this case.\n          cause = err;\n          backward();\n          return;\n        }\n        if (cb) {\n          cbs.push(cb);\n        }\n        forward(++pos);\n      }));\n    } else {\n      // Done with the middleware forward functions, call the handler.\n      params.onTransition.apply(params.ctx, args.concat(function (err) {\n        if (isDone) {\n          params.onError(toError('duplicate handler call', err));\n          return;\n        }\n        isDone = true;\n        cause = err;\n        process.nextTick(backward);\n      }));\n    }\n  }\n  function backward() {\n    var cb = cbs.pop();\n    if (cb) {\n      var isDone = false;\n      cb.call(params.ctx, cause, function (err) {\n        if (isDone) {\n          params.onError(toError('duplicate backward middleware call', err));\n          return;\n        }\n        // Substitute the error.\n        cause = err;\n        isDone = true;\n        backward();\n      });\n    } else {\n      // Done with all middleware calls.\n      params.onCompletion.call(params.ctx, cause);\n    }\n  }\n}\nmodule.exports = {\n  Adapter: Adapter,\n  HANDSHAKE_REQUEST_TYPE: HANDSHAKE_REQUEST_TYPE,\n  HANDSHAKE_RESPONSE_TYPE: HANDSHAKE_RESPONSE_TYPE,\n  Message: Message,\n  Registry: Registry,\n  Service: Service,\n  discoverProtocol: discoverProtocol,\n  streams: {\n    FrameDecoder: FrameDecoder,\n    FrameEncoder: FrameEncoder,\n    NettyDecoder: NettyDecoder,\n    NettyEncoder: NettyEncoder\n  }\n};","map":{"version":3,"names":["require","types","utils","events","stream","util","Tap","Type","debug","debuglog","f","format","OPTS","namespace","BOOLEAN_TYPE","forSchema","MAP_BYTES_TYPE","type","values","STRING_TYPE","HANDSHAKE_REQUEST_TYPE","name","fields","size","HANDSHAKE_RESPONSE_TYPE","symbols","PREFIX_LENGTH","PING_MESSAGE","Message","reqType","errType","resType","oneWay","doc","isType","Error","requestType","getTypes","errorType","length","responseType","undefined","Object","freeze","schema","opts","isValidName","Array","isArray","request","recordName","capitalize","registry","response","errors","concat","prototype","getSchema","_attrs","reqSchema","msgDoc","errSchema","slice","addDeprecatedGetters","isOneWay","deprecate","Service","messages","ptcl","server","forProtocol","_messagesByName","objectValues","_typesByName","protocol","_hashStr","getHash","JSON","stringify","toString","_server","createServer","silent","Client","Server","compatible","clientSvc","serverSvc","createReaders","err","match","exec","qualify","forEach","obj","msgs","keys","key","isService","any","hasOwnProperty","createClient","client","process","nextTick","objectMode","pts","PassThrough","createChannel","readable","writable","transport","defineProperty","enumerable","get","bufferFrom","message","inspect","createEmitter","cache","buffering","strictTypes","strictErrors","timeout","channel","forwardErrors","createListener","emit","req","cb","equals","_svc$","emitMessage","call","bind","getPending","getFingerprint","algorithm","on","handler","self","onMessage","subprotocol","parent","_strict","_cache","service","_handlers","create","t","getName","typeSchema","push","msgNames","exportAttrs","discoverProtocol","svc","ptclStr","scope","endWritable","once","hreq","hres","serverProtocol","destroy","pending","test","parse","EventEmitter","_channels$","_fns$","_buffering$","_cache$","_policy$","channelPolicy","_strict$","_timeout$","getOption","remoteProtocols","insertRemoteProtocols","msg","_createMessageHandler$","inherits","activeChannels","writableFactory","encoder","FrameEncoder","decoder","FrameDecoder","pipe","StatelessClientChannel","isStream","NettyDecoder","NettyEncoder","StatefulClientChannel","unpipe","channels","splice","indexOf","destroyChannels","noWait","getExistingMessage","wreq","WrappedRequest","_emitMessage$","getRemoteProtocols","use","i","l","fn","arguments","numChannels","CallContext","_msg","Math","floor","random","_emit","wres","ctx","clone","wrapUnions","done","error","string","res","getFields","names","map","body","join","n","Function","_fns","_channels","_nextChannelId","_defaultHandler","defaultHandler","_sysErrFormatter","systemErrorFormatter","_silent","noCapitalize","_createMessageHandler","readableFactory","StatelessServerChannel","StatefulServerChannel","listeners","_onError","channelId","numArgs","args","rpcCode","console","cause","ClientChannel","_endWritable","_prefix","normalizedPrefix","hash","serverHash","adapter","Adapter","_adapter","_registry","Registry","destroyed","draining","clear","isError","ping","_createHandshakeRequest","noSvc","clientHash","clientProtocol","_hash","WrappedResponse","onTransition","onCompletion","fns","chainMiddleware","onError","prev","reqBuf","toBuffer","serializationError","id","add","resBuf","_decodeResponse","_send","_getAdapter","_matchesPrefix","matchesPrefix","abstractFunction","getCache","getProtocol","isDestroyed","_writableFactory","noPing","retry","buf","Buffer","payload","parts","readHead","head","tail","write","end","_readable","_writable","_connected","onEnd","onFinish","timer","clearTimeout","removeListener","onPing","setTimeout","apply","ServerChannel","_createHandshakeResponse","serverMatch","toRpcError","_receive","_decodeRequest","_encodeSystemError","resErr","isStrict","isValid","headers","header","errStr","hdrBuf","onRequest","onHandshake","hdrs","hdr","hasError","locals","prefixLength","_ctx","_mask","_id","_n","_cbs","isRemote","_clientSvc","_serverSvc","_isRemote","_readers","tap","_read","copyOwnProperties","reader","Transform","readableObjectMode","_buf","newBuffer","_bufs","_transform","encoding","frameLength","readInt32BE","bufs","_flush","unshift","trailingData","writableObjectMode","intBuffer","_frameCount","writeInt32BE","pos","createReader","rtype","wtype","createResolver","c","s","ptcls","isClient","hs","src","dst","toError","toLowerCase","replace","details","field","errorHook","detailsStr","path","value","strs","part","isNaN","readInt16BE","prefix","params","cbs","forward","isDone","backward","pop","module","exports","streams"],"sources":["E:/Amanda-project/vue2-project/project-vue2/node_modules/avsc/lib/services.js"],"sourcesContent":["/* jshint node: true */\n\n// TODO: Add broadcast option to client `_emitMessage`, accessible for one-way\n// messages.\n// TODO: Add `server.mount` method to allow combining servers. The API is as\n// follows: a mounted server's (i.e. the method's argument) handlers have lower\n// precedence than the original server (i.e. `this`); the mounted server's\n// middlewares are only invoked for its handlers.\n// TODO: Change `objectMode` client and server channel option to `encoding`\n// (accepting `'netty'`, `'standard'`, and `null` or `undefined`). Perhaps also\n// expose encoders (API TBD).\n\n'use strict';\n\n/** This module implements Avro's IPC/RPC logic. */\n\nvar types = require('./types'),\n    utils = require('./utils'),\n    events = require('events'),\n    stream = require('stream'),\n    util = require('util');\n\n\n// A few convenience imports.\nvar Tap = utils.Tap;\nvar Type = types.Type;\nvar debug = util.debuglog('avsc:services');\nvar f = util.format;\n\n// Various useful types. We instantiate options once, to share the registry.\nvar OPTS = {namespace: 'org.apache.avro.ipc'};\n\nvar BOOLEAN_TYPE = Type.forSchema('boolean', OPTS);\n\nvar MAP_BYTES_TYPE = Type.forSchema({type: 'map', values: 'bytes'}, OPTS);\n\nvar STRING_TYPE = Type.forSchema('string', OPTS);\n\nvar HANDSHAKE_REQUEST_TYPE = Type.forSchema({\n  name: 'HandshakeRequest',\n  type: 'record',\n  fields: [\n    {name: 'clientHash', type: {name: 'MD5', type: 'fixed', size: 16}},\n    {name: 'clientProtocol', type: ['null', 'string'], 'default': null},\n    {name: 'serverHash', type: 'MD5'},\n    {name: 'meta', type: ['null', MAP_BYTES_TYPE], 'default': null}\n  ]\n}, OPTS);\n\nvar HANDSHAKE_RESPONSE_TYPE = Type.forSchema({\n  name: 'HandshakeResponse',\n  type: 'record',\n  fields: [\n    {\n      name: 'match',\n      type: {\n        name: 'HandshakeMatch',\n        type: 'enum',\n        symbols: ['BOTH', 'CLIENT', 'NONE']\n      }\n    },\n    {name: 'serverProtocol', type: ['null', 'string'], 'default': null},\n    {name: 'serverHash', type: ['null', 'MD5'], 'default': null},\n    {name: 'meta', type: ['null', MAP_BYTES_TYPE], 'default': null}\n  ]\n}, OPTS);\n\n// Prefix used to differentiate between messages when sharing a stream. This\n// length should be smaller than 16. The remainder is used for disambiguating\n// between concurrent messages (the current value, 16, therefore supports ~64k\n// concurrent messages).\nvar PREFIX_LENGTH = 16;\n\n// Internal message, used to check protocol compatibility.\nvar PING_MESSAGE = new Message(\n  '', // Empty name (invalid for other \"normal\" messages).\n  Type.forSchema({name: 'PingRequest', type: 'record', fields: []}, OPTS),\n  Type.forSchema(['string'], OPTS),\n  Type.forSchema('null', OPTS)\n);\n\n/** An Avro message, containing its request, response, etc. */\nfunction Message(name, reqType, errType, resType, oneWay, doc) {\n  this.name = name;\n  if (!Type.isType(reqType, 'record')) {\n    throw new Error('invalid request type');\n  }\n  this.requestType = reqType;\n  if (\n    !Type.isType(errType, 'union') ||\n    !Type.isType(errType.getTypes()[0], 'string')\n  ) {\n    throw new Error('invalid error type');\n  }\n  this.errorType = errType;\n  if (oneWay) {\n    if (!Type.isType(resType, 'null') || errType.getTypes().length > 1) {\n      throw new Error('inapplicable one-way parameter');\n    }\n  }\n  this.responseType = resType;\n  this.oneWay = !!oneWay;\n  this.doc = doc !== undefined ? '' + doc : undefined;\n  Object.freeze(this);\n}\n\nMessage.forSchema = function (name, schema, opts) {\n  opts = opts || {};\n  if (!types.isValidName(name)) {\n    throw new Error(f('invalid message name: %s', name));\n  }\n  // We use a record with a placeholder name here (the user might have set\n  // `noAnonymousTypes`, so we can't use an anonymous one). We remove it from\n  // the registry afterwards to avoid exposing it outside.\n  if (!Array.isArray(schema.request)) {\n    throw new Error(f('invalid message request: %s', name));\n  }\n  var recordName = f('%s.%sRequest', OPTS.namespace, utils.capitalize(name));\n  var reqType = Type.forSchema({\n    name: recordName,\n    type: 'record',\n    namespace: opts.namespace || '', // Don't leak request namespace.\n    fields: schema.request\n  }, opts);\n  delete opts.registry[recordName];\n  if (!schema.response) {\n    throw new Error(f('invalid message response: %s', name));\n  }\n  var resType = Type.forSchema(schema.response, opts);\n  if (schema.errors !== undefined && !Array.isArray(schema.errors)) {\n    throw new Error(f('invalid message errors: %s', name));\n  }\n  var errType = Type.forSchema(['string'].concat(schema.errors || []), opts);\n  var oneWay = !!schema['one-way'];\n  return new Message(name, reqType, errType, resType, oneWay, schema.doc);\n};\n\nMessage.prototype.schema = Type.prototype.getSchema;\n\nMessage.prototype._attrs = function (opts) {\n  var reqSchema = this.requestType._attrs(opts);\n  var schema = {\n    request: reqSchema.fields,\n    response: this.responseType._attrs(opts)\n  };\n  var msgDoc = this.doc;\n  if (msgDoc !== undefined) {\n    schema.doc = msgDoc;\n  }\n  var errSchema = this.errorType._attrs(opts);\n  if (errSchema.length > 1) {\n    schema.errors = errSchema.slice(1);\n  }\n  if (this.oneWay) {\n    schema['one-way'] = true;\n  }\n  return schema;\n};\n\n// Deprecated.\n\nutils.addDeprecatedGetters(\n  Message,\n  ['name', 'errorType', 'requestType', 'responseType']\n);\n\nMessage.prototype.isOneWay = util.deprecate(\n  function () { return this.oneWay; },\n  'use `.oneWay` directly instead of `.isOneWay()`'\n);\n\n/**\n * An Avro RPC service.\n *\n * This constructor shouldn't be called directly, but via the\n * `Service.forProtocol` method. This function performs little logic to better\n * support efficient copy.\n */\nfunction Service(name, messages, types, ptcl, server) {\n  if (typeof name != 'string') {\n    // Let's be helpful in case this class is instantiated directly.\n    return Service.forProtocol(name, messages);\n  }\n\n  this.name = name;\n  this._messagesByName = messages || {};\n  this.messages = Object.freeze(utils.objectValues(this._messagesByName));\n\n  this._typesByName = types || {};\n  this.types = Object.freeze(utils.objectValues(this._typesByName));\n\n  this.protocol = ptcl;\n  // We cache a string rather than a buffer to not retain an entire slab.\n  this._hashStr = utils.getHash(JSON.stringify(ptcl)).toString('binary');\n  this.doc = ptcl.doc ? '' + ptcl.doc : undefined;\n\n  // We add a server to each protocol for backwards-compatibility (to allow the\n  // use of `protocol.on`). This covers all cases except the use of the\n  // `strictErrors` option, which requires moving to the new API.\n  this._server = server || this.createServer({silent: true});\n  Object.freeze(this);\n}\n\nService.Client = Client;\n\nService.Server = Server;\n\nService.compatible = function (clientSvc, serverSvc) {\n  try {\n    createReaders(clientSvc, serverSvc);\n  } catch (err) {\n    return false;\n  }\n  return true;\n};\n\nService.forProtocol = function (ptcl, opts) {\n  opts = opts || {};\n\n  var name = ptcl.protocol;\n  if (!name) {\n    throw new Error('missing protocol name');\n  }\n  if (ptcl.namespace !== undefined) {\n    opts.namespace = ptcl.namespace;\n  } else {\n    var match = /^(.*)\\.[^.]+$/.exec(name);\n    if (match) {\n      opts.namespace = match[1];\n    }\n  }\n  name = types.qualify(name, opts.namespace);\n\n  if (ptcl.types) {\n    ptcl.types.forEach(function (obj) { Type.forSchema(obj, opts); });\n  }\n  var msgs;\n  if (ptcl.messages) {\n    msgs = {};\n    Object.keys(ptcl.messages).forEach(function (key) {\n      msgs[key] = Message.forSchema(key, ptcl.messages[key], opts);\n    });\n  }\n\n  return new Service(name, msgs, opts.registry, ptcl);\n};\n\nService.isService = function (any) {\n  // Not fool-proof but likely sufficient.\n  return !!any && any.hasOwnProperty('_hashStr');\n};\n\nService.prototype.createClient = function (opts) {\n  var client = new Client(this, opts);\n  process.nextTick(function () {\n    // We delay this processing such that we can attach handlers to the client\n    // before any channels get created.\n    if (opts && opts.server) {\n      // Convenience in-memory client. This can be useful to make requests\n      // relatively efficiently to an in-process server. Note that it is still\n      // is less efficient than direct method calls (because of the\n      // serialization, which does provide \"type-safety\" though).\n      var obj = {objectMode: true};\n      var pts = [new stream.PassThrough(obj), new stream.PassThrough(obj)];\n      opts.server.createChannel({readable: pts[0], writable: pts[1]}, obj);\n      client.createChannel({readable: pts[1], writable: pts[0]}, obj);\n    } else if (opts && opts.transport) {\n      // Convenience functionality for the common single channel use-case: we\n      // add a single channel using default options to the client.\n      client.createChannel(opts.transport);\n    }\n  });\n  return client;\n};\n\nService.prototype.createServer = function (opts) {\n  return new Server(this, opts);\n};\n\nObject.defineProperty(Service.prototype, 'hash', {\n  enumerable: true,\n  get: function () { return utils.bufferFrom(this._hashStr, 'binary'); }\n});\n\nService.prototype.message = function (name) {\n  return this._messagesByName[name];\n};\n\nService.prototype.type = function (name) {\n  return this._typesByName[name];\n};\n\nService.prototype.inspect = function () {\n  return f('<Service %j>', this.name);\n};\n\n// Deprecated methods.\n\nutils.addDeprecatedGetters(\n  Service,\n  ['message', 'messages', 'name', 'type', 'types']\n);\n\nService.prototype.createEmitter = util.deprecate(\n  function (transport, opts) {\n    opts = opts || {};\n    var client = this.createClient({\n      cache: opts.cache,\n      buffering: false,\n      strictTypes: opts.strictErrors,\n      timeout: opts.timeout\n    });\n    var channel = client.createChannel(transport, opts);\n    forwardErrors(client, channel);\n    return channel;\n  },\n  'use `.createClient()` instead of `.createEmitter()`'\n);\n\nService.prototype.createListener = util.deprecate(\n  function (transport, opts) {\n    if (opts && opts.strictErrors) {\n      throw new Error('use `.createServer()` to support strict errors');\n    }\n    return this._server.createChannel(transport, opts);\n  },\n  'use `.createServer().createChannel()` instead of `.createListener()`'\n);\n\nService.prototype.emit = util.deprecate(\n  function (name, req, channel, cb) {\n    if (!channel || !this.equals(channel.client._svc$)) {\n      throw new Error('invalid emitter');\n    }\n\n    var client = channel.client;\n    // In case the method is overridden.\n    Client.prototype.emitMessage.call(client, name, req, cb && cb.bind(this));\n    return channel.getPending();\n  },\n  'create a client via `.createClient()` to emit messages instead of `.emit()`'\n);\n\nService.prototype.equals = util.deprecate(\n  function (any) {\n    return (\n      Service.isService(any) &&\n      this.getFingerprint().equals(any.getFingerprint())\n    );\n  },\n  'equality testing is deprecated, compare the `.protocol`s instead'\n);\n\nService.prototype.getFingerprint = util.deprecate(\n  function (algorithm) {\n    return utils.getHash(JSON.stringify(this.protocol), algorithm);\n  },\n  'use `.hash` instead of `.getFingerprint()`'\n);\n\nService.prototype.getSchema = util.deprecate(\n  Type.prototype.getSchema,\n  'use `.protocol` instead of `.getSchema()`'\n);\n\nService.prototype.on = util.deprecate(\n  function (name, handler) {\n    var self = this; // This protocol.\n    this._server.onMessage(name, function (req, cb) {\n      return handler.call(self, req, this.channel, cb);\n    });\n    return this;\n  },\n  'use `.createServer().onMessage()` instead of `.on()`'\n);\n\nService.prototype.subprotocol = util.deprecate(\n  function () {\n    var parent = this._server;\n    var opts = {strictTypes: parent._strict, cache: parent._cache};\n    var server = new Server(parent.service, opts);\n    server._handlers = Object.create(parent._handlers);\n    return new Service(\n      this.name,\n      this._messagesByName,\n      this._typesByName,\n      this.protocol,\n      server\n    );\n  },\n  '`.subprotocol()` will be removed in 5.1'\n);\n\nService.prototype._attrs = function (opts) {\n  var ptcl = {protocol: this.name};\n\n  var types = [];\n  this.types.forEach(function (t) {\n    if (t.getName() === undefined) {\n      // Don't include any unnamed types (e.g. primitives).\n      return;\n    }\n    var typeSchema = t._attrs(opts);\n    if (typeof typeSchema != 'string') {\n      // Some of the named types might already have been defined in a\n      // previous type, in this case we don't include its reference.\n      types.push(typeSchema);\n    }\n  });\n  if (types.length) {\n    ptcl.types = types;\n  }\n\n  var msgNames = Object.keys(this._messagesByName);\n  if (msgNames.length) {\n    ptcl.messages = {};\n    msgNames.forEach(function (name) {\n      ptcl.messages[name] = this._messagesByName[name]._attrs(opts);\n    }, this);\n  }\n\n  if (opts && opts.exportAttrs && this.doc !== undefined) {\n    ptcl.doc = this.doc;\n  }\n  return ptcl;\n};\n\n/** Function to retrieve a remote service's protocol. */\nfunction discoverProtocol(transport, opts, cb) {\n  if (cb === undefined && typeof opts == 'function') {\n    cb = opts;\n    opts = undefined;\n  }\n\n  var svc = new Service({protocol: 'Empty'}, OPTS);\n  var ptclStr;\n  svc.createClient({timeout: opts && opts.timeout})\n    .createChannel(transport, {\n      scope: opts && opts.scope,\n      endWritable: typeof transport == 'function' // Stateless transports only.\n    }).once('handshake', function (hreq, hres) {\n        ptclStr = hres.serverProtocol;\n        this.destroy(true);\n      })\n      .once('eot', function (pending, err) {\n        // Stateless transports will throw an interrupted error when the\n        // channel is destroyed, we ignore it here.\n        if (err && !/interrupted/.test(err)) {\n          cb(err); // Likely timeout.\n        } else {\n          cb(null, JSON.parse(ptclStr));\n        }\n      });\n}\n\n/** Load-balanced message sender. */\nfunction Client(svc, opts) {\n  opts = opts || {};\n  events.EventEmitter.call(this);\n\n  // We have to suffix all client properties to be safe, since the message\n  // names aren't prefixed with clients (unlike servers).\n  this._svc$ = svc;\n  this._channels$ = []; // Active channels.\n  this._fns$ = []; // Middleware functions.\n\n  this._buffering$ = !!opts.buffering;\n  this._cache$ = opts.cache || {}; // For backwards compatibility.\n  this._policy$ = opts.channelPolicy;\n  this._strict$ = !!opts.strictTypes;\n  this._timeout$ = utils.getOption(opts, 'timeout', 10000);\n\n  if (opts.remoteProtocols) {\n    insertRemoteProtocols(this._cache$, opts.remoteProtocols, svc, true);\n  }\n\n  this._svc$.messages.forEach(function (msg) {\n    this[msg.name] = this._createMessageHandler$(msg);\n  }, this);\n}\nutil.inherits(Client, events.EventEmitter);\n\nClient.prototype.activeChannels = function () {\n  return this._channels$.slice();\n};\n\nClient.prototype.createChannel = function (transport, opts) {\n  var objectMode = opts && opts.objectMode;\n  var channel;\n  if (typeof transport == 'function') {\n    var writableFactory;\n    if (objectMode) {\n      writableFactory = transport;\n    } else {\n      // We provide a default standard-compliant codec. This should support\n      // most use-cases (for example when speaking to the official Java and\n      // Python implementations over HTTP, or when this library is used for\n      // both the emitting and listening sides).\n      writableFactory = function (cb) {\n        var encoder = new FrameEncoder();\n        var writable = transport(function (err, readable) {\n          if (err) {\n            cb(err);\n            return;\n          }\n          // Since the decoder isn't exposed (so can't have an error handler\n          // attached, we forward any errors to the client). Since errors would\n          // only get thrown when the decoder flushes (if there is trailing\n          // data), at which point the source will have ended, there is no need\n          // to add re-piping logic (destination errors trigger an unpipe).\n          var decoder = new FrameDecoder()\n            .once('error', function (err) { channel.destroy(err); });\n          cb(null, readable.pipe(decoder));\n        });\n        if (writable) {\n          encoder.pipe(writable);\n          return encoder;\n        }\n      };\n    }\n    channel = new StatelessClientChannel(this, writableFactory, opts);\n  } else {\n    var readable, writable;\n    if (isStream(transport)) {\n      readable = writable = transport;\n    } else {\n      readable = transport.readable;\n      writable = transport.writable;\n    }\n    if (!objectMode) {\n      // To ease communication with Java servers, we provide a default codec\n      // compatible with Java servers' `NettyTransportCodec`'s implementation.\n      var decoder = new NettyDecoder();\n      readable = readable.pipe(decoder);\n      var encoder = new NettyEncoder();\n      encoder.pipe(writable);\n      writable = encoder;\n    }\n    channel = new StatefulClientChannel(this, readable, writable, opts);\n    if (!objectMode) {\n      // Since we never expose the automatically created encoder and decoder,\n      // we release them ourselves here when the channel ends. (Unlike for\n      // stateless channels, it is conceivable for the underlying stream to be\n      // reused afterwards).\n      channel.once('eot', function () {\n        readable.unpipe(decoder);\n        encoder.unpipe(writable);\n      });\n      // We also forward any (trailing data) error.\n      decoder.once('error', function (err) { channel.destroy(err); });\n    }\n  }\n  var channels = this._channels$;\n  channels.push(channel);\n  channel.once('_drain', function () {\n    // Remove the channel from the list of active ones.\n    channels.splice(channels.indexOf(this), 1);\n  });\n  // We restrict buffering to startup, otherwise we risk silently hiding errors\n  // (especially since channel timeouts don't apply yet).\n  this._buffering$ = false;\n  this.emit('channel', channel);\n  return channel;\n};\n\nClient.prototype.destroyChannels = function (opts) {\n  this._channels$.forEach(function (channel) {\n    channel.destroy(opts && opts.noWait);\n  });\n};\n\nClient.prototype.emitMessage = function (name, req, opts, cb) {\n  var msg = getExistingMessage(this._svc$, name);\n  var wreq = new WrappedRequest(msg, {}, req);\n  this._emitMessage$(wreq, opts, cb);\n};\n\nClient.prototype.remoteProtocols = function () {\n  return getRemoteProtocols(this._cache$, true);\n};\n\nObject.defineProperty(Client.prototype, 'service', {\n  enumerable: true,\n  get: function () { return this._svc$; }\n});\n\nClient.prototype.use = function (/* fn ... */) {\n  var i, l, fn;\n  for (i = 0, l = arguments.length; i < l; i++) {\n    fn = arguments[i];\n    this._fns$.push(fn.length < 3 ? fn(this) : fn);\n  }\n  return this;\n};\n\nClient.prototype._emitMessage$ = function (wreq, opts, cb) {\n  // Common logic between `client.emitMessage` and the \"named\" message methods.\n  if (!cb && typeof opts === 'function') {\n    cb = opts;\n    opts = undefined;\n  }\n  var self = this;\n  var channels = this._channels$;\n  var numChannels = channels.length;\n  if (!numChannels) {\n    if (this._buffering$) {\n      debug('no active client channels, buffering call');\n      this.once('channel', function () {\n        this._emitMessage$(wreq, opts, cb);\n      });\n    } else {\n      var err = new Error('no active channels');\n      process.nextTick(function () {\n        if (cb) {\n          cb.call(new CallContext(wreq._msg), err);\n        } else {\n          self.emit('error', err);\n        }\n      });\n    }\n    return;\n  }\n\n  opts = opts || {};\n  if (opts.timeout === undefined) {\n    opts.timeout = this._timeout$;\n  }\n\n  var channel;\n  if (numChannels === 1) {\n    // Common case, optimized away.\n    channel = channels[0];\n  } else if (this._policy$) {\n    channel = this._policy$(this._channels$.slice());\n    if (!channel) {\n      debug('policy returned no channel, skipping call');\n      return;\n    }\n  } else {\n    // Random selection, cheap and likely good enough for most use-cases.\n    channel = channels[Math.floor(Math.random() * numChannels)];\n  }\n\n  channel._emit(wreq, opts, function (err, wres) {\n    var ctx = this; // Call context.\n    var errType = ctx.message.errorType;\n    if (err) {\n      // System error, likely the message wasn't sent (or an error occurred\n      // while decoding the response).\n      if (self._strict$) {\n        err = errType.clone(err.message, {wrapUnions: true});\n      }\n      done(err);\n      return;\n    }\n    if (!wres) {\n      // This is a one way message.\n      done();\n      return;\n    }\n    // Message transmission succeeded, we transmit the message data; massaging\n    // any error strings into actual `Error` objects in non-strict mode.\n    err = wres.error;\n    if (!self._strict$) {\n      // Try to coerce an eventual error into more idiomatic JavaScript types:\n      // `undefined` becomes `null` and a remote string \"system\" error is\n      // wrapped inside an actual `Error` object.\n      if (err === undefined) {\n        err = null;\n      } else {\n        if (Type.isType(errType, 'union:unwrapped')) {\n          if (typeof err == 'string') {\n            err = new Error(err);\n          }\n        } else if (err && err.string && typeof err.string == 'string') {\n          err = new Error(err.string);\n        }\n      }\n    }\n    done(err, wres.response);\n\n    function done(err, res) {\n      if (cb) {\n        cb.call(ctx, err, res);\n      } else if (err) {\n        self.emit('error', err);\n      }\n    }\n  });\n};\n\nClient.prototype._createMessageHandler$ = function (msg) {\n  // jshint -W054\n  var fields = msg.requestType.getFields();\n  var names = fields.map(function (f) { return f.getName(); });\n  var body = 'return function ' + msg.name + '(';\n  if (names.length) {\n    body += names.join(', ') + ', ';\n  }\n  body += 'opts, cb) {\\n';\n  body += '  var req = {';\n  body += names.map(function (n) { return n + ': ' + n; }).join(', ');\n  body += '};\\n';\n  body += '  return this.emitMessage(\\'' + msg.name + '\\', req, opts, cb);\\n';\n  body += '};';\n  return (new Function(body))();\n};\n\n/** Message receiver. */\nfunction Server(svc, opts) {\n  opts = opts || {};\n  events.EventEmitter.call(this);\n\n  this.service = svc;\n  this._handlers = {};\n  this._fns = []; // Middleware functions.\n  this._channels = {}; // Active channels.\n  this._nextChannelId = 1;\n\n  this._cache = opts.cache || {}; // Deprecated.\n  this._defaultHandler = opts.defaultHandler;\n  this._sysErrFormatter = opts.systemErrorFormatter;\n  this._silent = !!opts.silent;\n  this._strict = !!opts.strictTypes;\n\n  if (opts.remoteProtocols) {\n    insertRemoteProtocols(this._cache, opts.remoteProtocols, svc, false);\n  }\n\n  svc.messages.forEach(function (msg) {\n    var name = msg.name;\n    if (!opts.noCapitalize) {\n      name = utils.capitalize(name);\n    }\n    this['on' + name] = this._createMessageHandler(msg);\n  }, this);\n}\nutil.inherits(Server, events.EventEmitter);\n\nServer.prototype.activeChannels = function () {\n  return utils.objectValues(this._channels);\n};\n\nServer.prototype.createChannel = function (transport, opts) {\n  var objectMode = opts && opts.objectMode;\n  var channel;\n  if (typeof transport == 'function') {\n    var readableFactory;\n    if (objectMode) {\n      readableFactory = transport;\n    } else {\n      readableFactory = function (cb) {\n        var decoder = new FrameDecoder()\n          .once('error', function (err) { channel.destroy(err); });\n        return transport(function (err, writable) {\n          if (err) {\n            cb(err);\n            return;\n          }\n          var encoder = new FrameEncoder();\n          encoder.pipe(writable);\n          cb(null, encoder);\n        }).pipe(decoder);\n      };\n    }\n    channel = new StatelessServerChannel(this, readableFactory, opts);\n  } else {\n    var readable, writable;\n    if (isStream(transport)) {\n      readable = writable = transport;\n    } else {\n      readable = transport.readable;\n      writable = transport.writable;\n    }\n    if (!objectMode) {\n      var decoder = new NettyDecoder();\n      readable = readable.pipe(decoder);\n      var encoder = new NettyEncoder();\n      encoder.pipe(writable);\n      writable = encoder;\n    }\n    channel = new StatefulServerChannel(this, readable, writable, opts);\n    if (!objectMode) {\n      // Similar to client channels, since we never expose the encoder and\n      // decoder, we must release them ourselves here.\n      channel.once('eot', function () {\n        readable.unpipe(decoder);\n        encoder.unpipe(writable);\n      });\n      decoder.once('error', function (err) { channel.destroy(err); });\n    }\n  }\n\n  if (!this.listeners('error').length) {\n    this.on('error', this._onError);\n  }\n  var channelId = this._nextChannelId++;\n  var channels = this._channels;\n  channels[channelId] = channel\n    .once('eot', function () { delete channels[channelId]; });\n  this.emit('channel', channel);\n  return channel;\n};\n\nServer.prototype.onMessage = function (name, handler) {\n  getExistingMessage(this.service, name); // Check message existence.\n  this._handlers[name] = handler;\n  return this;\n};\n\nServer.prototype.remoteProtocols = function () {\n  return getRemoteProtocols(this._cache, false);\n};\n\nServer.prototype.use = function (/* fn ... */) {\n  var i, l, fn;\n  for (i = 0, l = arguments.length; i < l; i++) {\n    fn = arguments[i];\n    this._fns.push(fn.length < 3 ? fn(this) : fn);\n  }\n  return this;\n};\n\nServer.prototype._createMessageHandler = function (msg) {\n  // jshint -W054\n  var name = msg.name;\n  var fields = msg.requestType.fields;\n  var numArgs = fields.length;\n  var args = fields.length ?\n    ', ' + fields.map(function (f) { return 'req.' + f.name; }).join(', ') :\n    '';\n  // We are careful to not lose the initial handler's number of arguments (or\n  // more specifically whether it would have access to the callback or not).\n  // This is useful to implement \"smart promisification\" logic downstream.\n  var body = 'return function (handler) {\\n';\n  body += '  if (handler.length > ' + numArgs + ') {\\n';\n  body += '    return this.onMessage(\\'' + name + '\\', function (req, cb) {\\n';\n  body += '      return handler.call(this' + args + ', cb);\\n';\n  body += '    });\\n';\n  body += '  } else {\\n';\n  body += '    return this.onMessage(\\'' + name + '\\', function (req) {\\n';\n  body += '      return handler.call(this' + args + ');\\n';\n  body += '    });\\n';\n  body += '  }\\n';\n  body += '};\\n';\n  return (new Function(body))();\n};\n\nServer.prototype._onError = function (err) {\n  /* istanbul ignore if */\n  if (!this._silent && err.rpcCode !== 'UNKNOWN_PROTOCOL') {\n    console.error();\n    if (err.rpcCode) {\n      console.error(err.rpcCode);\n      console.error(err.cause);\n    } else {\n      console.error('INTERNAL_SERVER_ERROR');\n      console.error(err);\n    }\n  }\n};\n\n/** Base message emitter class. See below for the two available variants. */\nfunction ClientChannel(client, opts) {\n  opts = opts || {};\n  events.EventEmitter.call(this);\n\n  this.client = client;\n  this.timeout = utils.getOption(opts, 'timeout', client._timeout$);\n  this._endWritable = !!utils.getOption(opts, 'endWritable', true);\n  this._prefix = normalizedPrefix(opts.scope);\n\n  var cache = client._cache$;\n  var clientSvc = client._svc$;\n  var hash = opts.serverHash;\n  if (!hash) {\n    hash = clientSvc.hash;\n  }\n  var adapter = cache[hash];\n  if (!adapter) {\n    // This might happen even if the server hash option was set if the cache\n    // doesn't contain the corresponding adapter. In this case we fall back to\n    // the client's protocol (as mandated by the spec).\n    hash = clientSvc.hash;\n    adapter = cache[hash] = new Adapter(clientSvc, clientSvc, hash);\n  }\n  this._adapter = adapter;\n\n  this._registry = new Registry(this, PREFIX_LENGTH);\n  this.pending = 0;\n  this.destroyed = false;\n  this.draining = false;\n  this.once('_eot', function (pending, err) {\n    // Since this listener is only run once, we will only forward an error if\n    // it is present during the initial `destroy` call, which is OK.\n    debug('client channel EOT');\n    this.destroyed = true;\n    this.emit('eot', pending, err);\n  });\n}\nutil.inherits(ClientChannel, events.EventEmitter);\n\nClientChannel.prototype.destroy = function (noWait) {\n  debug('destroying client channel');\n  if (!this.draining) {\n    this.draining = true;\n    this.emit('_drain');\n  }\n  var registry = this._registry;\n  var pending = this.pending;\n  if (noWait) {\n    registry.clear();\n  }\n  if (noWait || !pending) {\n    if (isError(noWait)) {\n      debug('fatal client channel error: %s', noWait);\n      this.emit('_eot', pending, noWait);\n    } else {\n      this.emit('_eot', pending);\n    }\n  } else {\n    debug('client channel entering drain mode (%s pending)', pending);\n  }\n};\n\nClientChannel.prototype.ping = function (timeout, cb) {\n  if (!cb && typeof timeout == 'function') {\n    cb = timeout;\n    timeout = undefined;\n  }\n  var self = this;\n  var wreq = new WrappedRequest(PING_MESSAGE);\n  this._emit(wreq, {timeout: timeout}, function (err) {\n    if (cb) {\n      cb.call(self, err);\n    } else if (err) {\n      self.destroy(err);\n    }\n  });\n};\n\nClientChannel.prototype._createHandshakeRequest = function (adapter, noSvc) {\n  var svc = this.client._svc$;\n  return {\n    clientHash: svc.hash,\n    clientProtocol: noSvc ? null : JSON.stringify(svc.protocol),\n    serverHash: adapter._hash\n  };\n};\n\nClientChannel.prototype._emit = function (wreq, opts, cb) {\n  var msg = wreq._msg;\n  var wres = msg.oneWay ? undefined : new WrappedResponse(msg, {});\n  var ctx = new CallContext(msg, this);\n  var self = this;\n  this.pending++;\n  process.nextTick(function () {\n    if (!msg.name) {\n      // Ping request, bypass middleware.\n      onTransition(wreq, wres, onCompletion);\n    } else {\n      self.emit('outgoingCall', ctx, opts);\n      var fns = self.client._fns$;\n      debug('starting client middleware chain (%s middleware)', fns.length);\n      chainMiddleware({\n        fns: fns,\n        ctx: ctx,\n        wreq: wreq,\n        wres: wres,\n        onTransition: onTransition,\n        onCompletion: onCompletion,\n        onError: onError\n      });\n    }\n  });\n\n  function onTransition(wreq, wres, prev) {\n    // Serialize the message.\n    var err, reqBuf;\n    if (self.destroyed) {\n      err = new Error('channel destroyed');\n    } else {\n      try {\n        reqBuf = wreq.toBuffer();\n      } catch (cause) {\n        err = serializationError(\n          f('invalid %j request', msg.name),\n          wreq,\n          [\n            {name: 'headers', type: MAP_BYTES_TYPE},\n            {name: 'request', type: msg.requestType}\n          ]\n        );\n      }\n    }\n    if (err) {\n      prev(err);\n      return;\n    }\n\n    // Generate the response callback.\n    var timeout = (opts && opts.timeout !== undefined) ?\n      opts.timeout :\n      self.timeout;\n    var id = self._registry.add(timeout, function (err, resBuf, adapter) {\n      if (!err && !msg.oneWay) {\n        try {\n          adapter._decodeResponse(resBuf, wres, msg);\n        } catch (cause) {\n          err = cause;\n        }\n      }\n      prev(err);\n    });\n    id |= self._prefix;\n\n    debug('sending message %s', id);\n    self._send(id, reqBuf, !!msg && msg.oneWay);\n  }\n\n  function onCompletion(err) {\n    self.pending--;\n    cb.call(ctx, err, wres);\n    if (self.draining && !self.destroyed && !self.pending) {\n      self.destroy();\n    }\n  }\n\n  function onError(err) {\n    // This will happen if a middleware callback is called multiple times. We\n    // forward the error to the client rather than emit it on the channel since\n    // middleware are a client-level abstraction, so better handled there.\n    self.client.emit('error', err, self);\n  }\n};\n\nClientChannel.prototype._getAdapter = function (hres) {\n  var hash = hres.serverHash;\n  var cache = this.client._cache$;\n  var adapter = cache[hash];\n  if (adapter) {\n    return adapter;\n  }\n  var ptcl = JSON.parse(hres.serverProtocol);\n  var serverSvc = Service.forProtocol(ptcl);\n  adapter = new Adapter(this.client._svc$, serverSvc, hash, true);\n  return cache[hash] = adapter;\n};\n\nClientChannel.prototype._matchesPrefix = function (id) {\n  return matchesPrefix(id, this._prefix);\n};\n\nClientChannel.prototype._send = utils.abstractFunction;\n\n// Deprecated.\n\nutils.addDeprecatedGetters(ClientChannel, ['pending', 'timeout']);\n\nClientChannel.prototype.getCache = util.deprecate(\n  function () { return this.client._cache$; },\n  'use `.remoteProtocols()` instead of `.getCache()`'\n);\n\nClientChannel.prototype.getProtocol = util.deprecate(\n  function () {\n    return this.client._svc$;\n  },\n  'use `.service` instead or `.getProtocol()`'\n);\n\nClientChannel.prototype.isDestroyed = util.deprecate(\n  function () { return this.destroyed; },\n  'use `.destroyed` instead of `.isDestroyed`'\n);\n\n/**\n * Factory-based client channel.\n *\n * This channel doesn't keep a persistent connection to the server and requires\n * prepending a handshake to each message emitted. Usage examples include\n * talking to an HTTP server (where the factory returns an HTTP request).\n *\n * Since each message will use its own writable/readable stream pair, the\n * advantage of this channel is that it is able to keep track of which response\n * corresponds to each request without relying on transport ordering. In\n * particular, this means these channels are compatible with any server\n * implementation.\n */\nfunction StatelessClientChannel(client, writableFactory, opts) {\n  ClientChannel.call(this, client, opts);\n  this._writableFactory = writableFactory;\n\n  if (!opts || !opts.noPing) {\n    // Ping the server to check whether the remote protocol is compatible.\n    // If not, this will throw an error on the channel.\n    debug('emitting ping request');\n    this.ping();\n  }\n}\nutil.inherits(StatelessClientChannel, ClientChannel);\n\nStatelessClientChannel.prototype._send = function (id, reqBuf) {\n  var cb = this._registry.get(id);\n  var adapter = this._adapter;\n  var self = this;\n  process.nextTick(emit);\n  return true;\n\n  function emit(retry) {\n    if (self.destroyed) {\n      // The request's callback will already have been called.\n      return;\n    }\n\n    var hreq = self._createHandshakeRequest(adapter, !retry);\n\n    var writable = self._writableFactory.call(self, function (err, readable) {\n      if (err) {\n        cb(err);\n        return;\n      }\n      readable.on('data', function (obj) {\n        debug('received response %s', obj.id);\n        // We don't check that the prefix matches since the ID likely hasn't\n        // been propagated to the response (see default stateless codec).\n        var buf = Buffer.concat(obj.payload);\n        try {\n          var parts = readHead(HANDSHAKE_RESPONSE_TYPE, buf);\n          var hres = parts.head;\n          if (hres.serverHash) {\n            adapter = self._getAdapter(hres);\n          }\n        } catch (cause) {\n          cb(cause);\n          return;\n        }\n        var match = hres.match;\n        debug('handshake match: %s', match);\n        self.emit('handshake', hreq, hres);\n        if (match === 'NONE') {\n          // Try again, including the full protocol this time.\n          process.nextTick(function() { emit(true); });\n        } else {\n          // Change the default adapter.\n          self._adapter = adapter;\n          cb(null, parts.tail, adapter);\n        }\n      });\n    });\n    if (!writable) {\n      cb(new Error('invalid writable stream'));\n      return;\n    }\n    writable.write({\n      id: id,\n      payload: [HANDSHAKE_REQUEST_TYPE.toBuffer(hreq), reqBuf]\n    });\n    if (self._endWritable) {\n      writable.end();\n    }\n  }\n};\n\n/**\n * Multiplexing client channel.\n *\n * These channels reuse the same streams (both readable and writable) for all\n * messages. This avoids a lot of overhead (e.g. creating new connections,\n * re-issuing handshakes) but requires the underlying transport to support\n * forwarding message IDs.\n */\nfunction StatefulClientChannel(client, readable, writable, opts) {\n  ClientChannel.call(this, client, opts);\n  this._readable = readable;\n  this._writable = writable;\n  this._connected = !!(opts && opts.noPing);\n  this._readable.on('end', onEnd);\n  this._writable.on('finish', onFinish);\n\n  var self = this;\n  var timer = null;\n  this.once('eot', function () {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n    if (!self._connected) {\n      // Clear any buffered calls (they are guaranteed to error out when\n      // reaching the transition phase).\n      self.emit('_ready');\n    }\n    // Remove references to this channel to avoid potential memory leaks.\n    this._writable.removeListener('finish', onFinish);\n    if (this._endWritable) {\n      debug('ending transport');\n      this._writable.end();\n    }\n    this._readable\n      .removeListener('data', onPing)\n      .removeListener('data', onMessage)\n      .removeListener('end', onEnd);\n  });\n\n  var hreq; // For handshake events.\n  if (this._connected) {\n    this._readable.on('data', onMessage);\n  } else {\n    this._readable.on('data', onPing);\n    process.nextTick(ping);\n    if (self.timeout) {\n      timer = setTimeout(function () {\n        self.destroy(new Error('timeout'));\n      }, self.timeout);\n    }\n  }\n\n  function ping(retry) {\n    if (self.destroyed) {\n      return;\n    }\n    hreq = self._createHandshakeRequest(self._adapter, !retry);\n    var payload = [\n      HANDSHAKE_REQUEST_TYPE.toBuffer(hreq),\n      utils.bufferFrom([0, 0]) // No header, no data (empty message name).\n    ];\n    // We can use a static ID here since we are guaranteed that this message is\n    // the only one on the channel (for this scope at least).\n    self._writable.write({id: self._prefix, payload: payload});\n  }\n\n  function onPing(obj) {\n    if (!self._matchesPrefix(obj.id)) {\n      debug('discarding unscoped response %s (still connecting)', obj.id);\n      return;\n    }\n    var buf = Buffer.concat(obj.payload);\n    try {\n      var hres = readHead(HANDSHAKE_RESPONSE_TYPE, buf).head;\n      if (hres.serverHash) {\n        self._adapter = self._getAdapter(hres);\n      }\n    } catch (cause) {\n      // This isn't a recoverable error.\n      self.destroy(cause);\n      return;\n    }\n    var match = hres.match;\n    debug('handshake match: %s', match);\n    self.emit('handshake', hreq, hres);\n    if (match === 'NONE') {\n      process.nextTick(function () { ping(true); });\n    } else {\n      debug('successfully connected');\n      if (timer) {\n        clearTimeout(timer);\n        timer = null;\n      }\n      self._readable.removeListener('data', onPing).on('data', onMessage);\n      self._connected = true;\n      self.emit('_ready');\n      hreq = null; // Release reference.\n    }\n  }\n\n  // Callback used after a connection has been established.\n  function onMessage(obj) {\n    var id = obj.id;\n    if (!self._matchesPrefix(id)) {\n      debug('discarding unscoped message %s', id);\n      return;\n    }\n    var cb = self._registry.get(id);\n    if (cb) {\n      process.nextTick(function () {\n        debug('received message %s', id);\n        // Ensure that the initial callback gets called asynchronously, even\n        // for completely synchronous transports (otherwise the number of\n        // pending requests will sometimes be inconsistent between stateful and\n        // stateless transports).\n        cb(null, Buffer.concat(obj.payload), self._adapter);\n      });\n    }\n  }\n\n  function onEnd() { self.destroy(true); }\n  function onFinish() { self.destroy(); }\n}\nutil.inherits(StatefulClientChannel, ClientChannel);\n\nStatefulClientChannel.prototype._emit = function () {\n  // Override this method to allow calling `_emit` even before the channel is\n  // connected. Note that we don't perform this logic in `_send` since we want\n  // to guarantee that `'handshake'` events are emitted before any\n  // `'outgoingCall'` events.\n  if (this._connected || this.draining) {\n    ClientChannel.prototype._emit.apply(this, arguments);\n  } else {\n    debug('queuing request');\n    var args = [];\n    var i, l;\n    for (i = 0, l = arguments.length; i < l; i++) {\n      args.push(arguments[i]);\n    }\n    this.once('_ready', function () { this._emit.apply(this, args); });\n  }\n};\n\nStatefulClientChannel.prototype._send = function (id, reqBuf, oneWay) {\n  if (oneWay) {\n    var self = this;\n    // Clear the callback, passing in an empty header.\n    process.nextTick(function () {\n      self._registry.get(id)(null, utils.bufferFrom([0, 0, 0]), self._adapter);\n    });\n  }\n  return this._writable.write({id: id, payload: [reqBuf]});\n};\n\n/** The server-side emitter equivalent. */\nfunction ServerChannel(server, opts) {\n  opts = opts || {};\n  events.EventEmitter.call(this);\n\n  this.server = server;\n  this._endWritable = !!utils.getOption(opts, 'endWritable', true);\n  this._prefix = normalizedPrefix(opts.scope);\n\n  var cache = server._cache;\n  var svc = server.service;\n  var hash = svc.hash;\n  if (!cache[hash]) {\n    // Add the channel's protocol to the cache if it isn't already there. This\n    // will save a handshake the first time on channels with the same protocol.\n    cache[hash] = new Adapter(svc, svc, hash);\n  }\n  this._adapter = null;\n\n  this.destroyed = false;\n  this.draining = false;\n  this.pending = 0;\n  this.once('_eot', function (pending, err) {\n    debug('server channel EOT');\n    this.emit('eot', pending, err);\n  });\n}\nutil.inherits(ServerChannel, events.EventEmitter);\n\nServerChannel.prototype.destroy = function (noWait) {\n  if (!this.draining) {\n    this.draining = true;\n    this.emit('_drain');\n  }\n  if (noWait || !this.pending) {\n    this.destroyed = true;\n    if (isError(noWait)) {\n      debug('fatal server channel error: %s', noWait);\n      this.emit('_eot', this.pending, noWait);\n    } else {\n      this.emit('_eot', this.pending);\n    }\n  }\n};\n\nServerChannel.prototype._createHandshakeResponse = function (err, hreq) {\n  var svc = this.server.service;\n  var buf = svc.hash;\n  var serverMatch = hreq && hreq.serverHash.equals(buf);\n  return {\n    match: err ? 'NONE' : (serverMatch ? 'BOTH' : 'CLIENT'),\n    serverProtocol: serverMatch ? null : JSON.stringify(svc.protocol),\n    serverHash: serverMatch ? null : buf\n  };\n};\n\nServerChannel.prototype._getAdapter = function (hreq) {\n  var hash = hreq.clientHash;\n  var adapter = this.server._cache[hash];\n  if (adapter) {\n    return adapter;\n  }\n  if (!hreq.clientProtocol) {\n    throw toRpcError('UNKNOWN_PROTOCOL');\n  }\n  var ptcl = JSON.parse(hreq.clientProtocol);\n  var clientSvc = Service.forProtocol(ptcl);\n  adapter = new Adapter(clientSvc, this.server.service, hash, true);\n  return this.server._cache[hash] = adapter;\n};\n\nServerChannel.prototype._matchesPrefix = function (id) {\n  return matchesPrefix(id, this._prefix);\n};\n\nServerChannel.prototype._receive = function (reqBuf, adapter, cb) {\n  var self = this;\n  var wreq;\n  try {\n    wreq = adapter._decodeRequest(reqBuf);\n  } catch (cause) {\n    cb(self._encodeSystemError(toRpcError('INVALID_REQUEST', cause)));\n    return;\n  }\n\n  var msg = wreq._msg;\n  var wres = new WrappedResponse(msg, {});\n  if (!msg.name) {\n    // Ping message, we don't invoke middleware logic in this case.\n    wres.response = null;\n    cb(wres.toBuffer(), false);\n    return;\n  }\n\n  var ctx = new CallContext(msg, this);\n  self.emit('incomingCall', ctx);\n  var fns = this.server._fns;\n  debug('starting server middleware chain (%s middleware)', fns.length);\n  self.pending++;\n  chainMiddleware({\n    fns: fns,\n    ctx: ctx,\n    wreq: wreq,\n    wres: wres,\n    onTransition: onTransition,\n    onCompletion: onCompletion,\n    onError: onError\n  });\n\n  function onTransition(wreq, wres, prev) {\n    var handler = self.server._handlers[msg.name];\n    if (!handler) {\n      // The underlying service hasn't implemented a handler.\n      var defaultHandler = self.server._defaultHandler;\n      if (defaultHandler) {\n        // We call the default handler with arguments similar (slightly\n        // simpler, there are no phases here) to middleware such that it can\n        // easily access the message name (useful to implement proxies).\n        defaultHandler.call(ctx, wreq, wres, prev);\n      } else {\n        var cause = new Error(f('no handler for %s', msg.name));\n        prev(toRpcError('NOT_IMPLEMENTED', cause));\n      }\n    } else {\n      var pending = !msg.oneWay;\n      try {\n        if (pending) {\n          handler.call(ctx, wreq.request, function (err, res) {\n            pending = false;\n            wres.error = err;\n            wres.response = res;\n            prev();\n          });\n        } else {\n          handler.call(ctx, wreq.request);\n          prev();\n        }\n      } catch (err) {\n        // We catch synchronous failures (same as express) and return the\n        // failure. Note that the server process can still crash if an error\n        // is thrown after the handler returns but before the response is\n        // sent (again, same as express). We are careful to only trigger the\n        // response callback once, emitting the errors afterwards instead.\n        if (pending) {\n          pending = false;\n          prev(err);\n        } else {\n          onError(err);\n        }\n      }\n    }\n  }\n\n  function onCompletion(err) {\n    self.pending--;\n    var server = self.server;\n    var resBuf;\n    if (!err) {\n      var resErr = wres.error;\n      var isStrict = server._strict;\n      if (!isStrict) {\n        if (isError(resErr)) {\n          // If the error type is wrapped, we must wrap the error too.\n          wres.error = msg.errorType.clone(resErr.message, {wrapUnions: true});\n        } else if (resErr === null) {\n          // We also allow `null`'s as error in this mode, converting them to\n          // the Avro-compatible `undefined`.\n          resErr = wres.error = undefined;\n        }\n        if (\n          resErr === undefined &&\n          wres.response === undefined &&\n          msg.responseType.isValid(null)\n        ) {\n          // Finally, for messages with `null` as acceptable response type, we\n          // allow `undefined`; converting them to `null`. This allows users to\n          // write a more natural `cb()` instead of `cb(null, null)`.\n          wres.response = null;\n        }\n      }\n      try {\n        resBuf = wres.toBuffer();\n      } catch (cause) {\n        // Note that we don't add an RPC code here such that the client\n        // receives the default `INTERNAL_SERVER_ERROR` one.\n        if (wres.error !== undefined) {\n          err = serializationError(\n            f('invalid %j error', msg.name), // Sic.\n            wres,\n            [\n              {name: 'headers', type: MAP_BYTES_TYPE},\n              {name: 'error', type: msg.errorType}\n            ]\n          );\n        } else {\n          err = serializationError(\n            f('invalid %j response', msg.name),\n            wres,\n            [\n              {name: 'headers', type: MAP_BYTES_TYPE},\n              {name: 'response', type: msg.responseType}\n            ]\n          );\n        }\n      }\n    }\n    if (!resBuf) {\n      // The headers are only available if the message isn't one-way.\n      resBuf = self._encodeSystemError(err, wres.headers);\n    } else if (resErr !== undefined) {\n      server.emit('error', toRpcError('APPLICATION_ERROR', resErr));\n    }\n    cb(resBuf, msg.oneWay);\n    if (self.draining && !self.pending) {\n      self.destroy();\n    }\n  }\n\n  function onError(err) {\n    // Similar to the client equivalent, we redirect this error to the server\n    // since middleware are defined at server-level.\n    self.server.emit('error', err, self);\n  }\n};\n\n// Deprecated.\n\nutils.addDeprecatedGetters(ServerChannel, ['pending']);\n\nServerChannel.prototype.getCache = util.deprecate(\n  function () { return this.server._cache; },\n  'use `.remoteProtocols()` instead of `.getCache()`'\n);\n\nServerChannel.prototype.getProtocol = util.deprecate(\n  function () {\n    return this.server.service;\n  },\n  'use `.service` instead of `.getProtocol()`'\n);\n\nServerChannel.prototype.isDestroyed = util.deprecate(\n  function () { return this.destroyed; },\n  'use `.destroyed` instead of `.isDestroyed`'\n);\n\n/**\n * Encode an error and optional header into a valid Avro response.\n *\n * @param err {Error} Error to encode.\n * @param header {Object} Optional response header.\n */\nServerChannel.prototype._encodeSystemError = function (err, header) {\n  var server = this.server;\n  server.emit('error', err, this);\n  var errStr;\n  if (server._sysErrFormatter) {\n    // Format the error into a string to send over the wire.\n    errStr = server._sysErrFormatter.call(this, err);\n  } else if (err.rpcCode) {\n    // By default, only forward the error's message when the RPC code is set\n    // (i.e. when this isn't an internal server error).\n    errStr = err.message;\n  }\n  var hdrBuf;\n  if (header) {\n    try {\n      // Propagate the header if possible.\n      hdrBuf = MAP_BYTES_TYPE.toBuffer(header);\n    } catch (cause) {\n      server.emit('error', cause, this);\n    }\n  }\n  return Buffer.concat([\n    hdrBuf || utils.bufferFrom([0]),\n    utils.bufferFrom([1, 0]), // Error flag and first union index.\n    STRING_TYPE.toBuffer(errStr || 'internal server error')\n  ]);\n};\n\n/**\n * Server channel for stateless transport.\n *\n * This channel expect a handshake to precede each message.\n */\nfunction StatelessServerChannel(server, readableFactory, opts) {\n  ServerChannel.call(this, server, opts);\n\n  this._writable = undefined;\n  var self = this;\n  var readable;\n\n  process.nextTick(function () {\n    // Delay listening to allow handlers to be attached even if the factory is\n    // purely synchronous.\n    readable = readableFactory.call(self, function (err, writable) {\n      process.nextTick(function () {\n        // We delay once more here in case this call is synchronous, to allow\n        // the readable to always be populated first.\n        if (err) {\n          onFinish(err);\n          return;\n        }\n        self._writable = writable.on('finish', onFinish);\n        self.emit('_writable');\n      });\n    }).on('data', onRequest).on('end', onEnd);\n  });\n\n\n  function onRequest(obj) {\n    var id = obj.id;\n    var buf = Buffer.concat(obj.payload);\n    var err;\n    try {\n      var parts = readHead(HANDSHAKE_REQUEST_TYPE, buf);\n      var hreq = parts.head;\n      var adapter = self._getAdapter(hreq);\n    } catch (cause) {\n      err = toRpcError('INVALID_HANDSHAKE_REQUEST', cause);\n    }\n\n    var hres = self._createHandshakeResponse(err, hreq);\n    self.emit('handshake', hreq, hres);\n    if (err) {\n      done(self._encodeSystemError(err));\n    } else {\n      self._receive(parts.tail, adapter, done);\n    }\n\n    function done(resBuf) {\n      if (!self.destroyed) {\n        if (!self._writable) {\n          self.once('_writable', function () { done(resBuf); });\n          return;\n        }\n        self._writable.write({\n          id: id,\n          payload: [HANDSHAKE_RESPONSE_TYPE.toBuffer(hres), resBuf]\n        });\n      }\n      if (self._writable && self._endWritable) {\n        self._writable.end();\n      }\n    }\n  }\n\n  function onEnd() { self.destroy(); }\n\n  function onFinish(err) {\n    readable\n      .removeListener('data', onRequest)\n      .removeListener('end', onEnd);\n    self.destroy(err || true);\n  }\n}\nutil.inherits(StatelessServerChannel, ServerChannel);\n\n/**\n * Stateful transport listener.\n *\n * A handshake is done when the channel first receives a message, then all\n * messages are sent without.\n */\nfunction StatefulServerChannel(server, readable, writable, opts) {\n  ServerChannel.call(this, server, opts);\n  this._adapter = undefined;\n  this._writable = writable.on('finish', onFinish);\n  this._readable = readable.on('data', onHandshake).on('end', onEnd);\n\n  this\n    .once('_drain', function () {\n      // Stop listening to incoming events.\n      this._readable\n        .removeListener('data', onHandshake)\n        .removeListener('data', onRequest)\n        .removeListener('end', onEnd);\n    })\n    .once('eot', function () {\n      // Clean up any references to the channel on the underlying streams.\n      this._writable.removeListener('finish', onFinish);\n      if (this._endWritable) {\n        this._writable.end();\n      }\n    });\n\n  var self = this;\n\n  function onHandshake(obj) {\n    var id = obj.id;\n    if (!self._matchesPrefix(id)) {\n      return;\n    }\n    var buf = Buffer.concat(obj.payload);\n    var err;\n    try {\n      var parts = readHead(HANDSHAKE_REQUEST_TYPE, buf);\n      var hreq = parts.head;\n      self._adapter = self._getAdapter(hreq);\n    } catch (cause) {\n      err = toRpcError('INVALID_HANDSHAKE_REQUEST', cause);\n    }\n    var hres = self._createHandshakeResponse(err, hreq);\n    self.emit('handshake', hreq, hres);\n    if (err) {\n      // Either the client's protocol was unknown or it isn't compatible.\n      done(self._encodeSystemError(err));\n    } else {\n      self._readable\n        .removeListener('data', onHandshake)\n        .on('data', onRequest);\n      self._receive(parts.tail, self._adapter, done);\n    }\n\n    function done(resBuf) {\n      if (self.destroyed) {\n        return;\n      }\n      self._writable.write({\n        id: id,\n        payload: [HANDSHAKE_RESPONSE_TYPE.toBuffer(hres), resBuf]\n      });\n    }\n  }\n\n  function onRequest(obj) {\n    // These requests are not prefixed with handshakes.\n    var id = obj.id;\n    if (!self._matchesPrefix(id)) {\n      return;\n    }\n    var reqBuf = Buffer.concat(obj.payload);\n    self._receive(reqBuf, self._adapter, function (resBuf, oneWay) {\n      if (self.destroyed || oneWay) {\n        return;\n      }\n      self._writable.write({id: id, payload: [resBuf]});\n    });\n  }\n\n  function onEnd() { self.destroy(); }\n\n  function onFinish() { self.destroy(true); }\n}\nutil.inherits(StatefulServerChannel, ServerChannel);\n\n// Helpers.\n\n/** Enhanced request, used inside forward middleware functions. */\nfunction WrappedRequest(msg, hdrs, req) {\n  this._msg = msg;\n  this.headers = hdrs || {};\n  this.request = req || {};\n}\n\nWrappedRequest.prototype.toBuffer = function () {\n  var msg = this._msg;\n  return Buffer.concat([\n    MAP_BYTES_TYPE.toBuffer(this.headers),\n    STRING_TYPE.toBuffer(msg.name),\n    msg.requestType.toBuffer(this.request)\n  ]);\n};\n\n/** Enhanced response, used inside forward middleware functions. */\nfunction WrappedResponse(msg, hdr, err, res) {\n  this._msg = msg;\n  this.headers = hdr;\n  this.error = err;\n  this.response = res;\n}\n\nWrappedResponse.prototype.toBuffer = function () {\n  var hdr = MAP_BYTES_TYPE.toBuffer(this.headers);\n  var hasError = this.error !== undefined;\n  return Buffer.concat([\n    hdr,\n    BOOLEAN_TYPE.toBuffer(hasError),\n    hasError ?\n      this._msg.errorType.toBuffer(this.error) :\n      this._msg.responseType.toBuffer(this.response)\n  ]);\n};\n\n/**\n * Context for all middleware and handlers.\n *\n * It exposes a `locals` object which can be used to pass information between\n * each other during a given call.\n */\nfunction CallContext(msg, channel) {\n  this.channel = channel;\n  this.locals = {};\n  this.message = msg;\n  Object.freeze(this);\n}\n\n/**\n * Callback registry.\n *\n * Callbacks added must accept an error as first argument. This is used by\n * client channels to store pending calls. This class isn't exposed by the\n * public API.\n */\nfunction Registry(ctx, prefixLength) {\n  this._ctx = ctx; // Context for all callbacks.\n  this._mask = ~0 >>> (prefixLength | 0); // 16 bits by default.\n  this._id = 0; // Unique integer ID for each call.\n  this._n = 0; // Number of pending calls.\n  this._cbs = {};\n}\n\nRegistry.prototype.get = function (id) { return this._cbs[id & this._mask]; };\n\nRegistry.prototype.add = function (timeout, fn) {\n  this._id = (this._id + 1) & this._mask;\n\n  var self = this;\n  var id = this._id;\n  var timer;\n  if (timeout > 0) {\n    timer = setTimeout(function () { cb(new Error('timeout')); }, timeout);\n  }\n\n  this._cbs[id] = cb;\n  this._n++;\n  return id;\n\n  function cb() {\n    if (!self._cbs[id]) {\n      // The callback has already run.\n      return;\n    }\n    delete self._cbs[id];\n    self._n--;\n    if (timer) {\n      clearTimeout(timer);\n    }\n    fn.apply(self._ctx, arguments);\n  }\n};\n\nRegistry.prototype.clear = function () {\n  Object.keys(this._cbs).forEach(function (id) {\n    this._cbs[id](new Error('interrupted'));\n  }, this);\n};\n\n/**\n * Service resolution helper.\n *\n * It is used both by client and server channels, to respectively decode errors\n * and responses, or requests.\n */\nfunction Adapter(clientSvc, serverSvc, hash, isRemote) {\n  this._clientSvc = clientSvc;\n  this._serverSvc = serverSvc;\n  this._hash = hash; // Convenience to access it when creating handshakes.\n  this._isRemote = !!isRemote;\n  this._readers = createReaders(clientSvc, serverSvc);\n}\n\nAdapter.prototype._decodeRequest = function (buf) {\n  var tap = new Tap(buf);\n  var hdr = MAP_BYTES_TYPE._read(tap);\n  var name = STRING_TYPE._read(tap);\n  var msg, req;\n  if (name) {\n    msg = this._serverSvc.message(name);\n    req = this._readers[name + '?']._read(tap);\n  } else {\n    msg = PING_MESSAGE;\n  }\n  if (!tap.isValid()) {\n    throw new Error(f('truncated %s request', name || 'ping$'));\n  }\n  return new WrappedRequest(msg, hdr, req);\n};\n\nAdapter.prototype._decodeResponse = function (buf, wres, msg) {\n  var tap = new Tap(buf);\n  utils.copyOwnProperties(MAP_BYTES_TYPE._read(tap), wres.headers, true);\n  var isError = BOOLEAN_TYPE._read(tap);\n  var name = msg.name;\n  if (name) {\n    var reader = this._readers[name + (isError ? '*' : '!')];\n    msg = this._clientSvc.message(name);\n    if (isError) {\n      wres.error = reader._read(tap);\n    } else {\n      wres.response = reader._read(tap);\n    }\n    if (!tap.isValid()) {\n      throw new Error(f('truncated %s response', name));\n    }\n  } else {\n    msg = PING_MESSAGE;\n  }\n};\n\n/** Standard \"un-framing\" stream. */\nfunction FrameDecoder() {\n  stream.Transform.call(this, {readableObjectMode: true});\n  this._id = undefined;\n  this._buf = utils.newBuffer(0);\n  this._bufs = [];\n\n  this.on('finish', function () { this.push(null); });\n}\nutil.inherits(FrameDecoder, stream.Transform);\n\nFrameDecoder.prototype._transform = function (buf, encoding, cb) {\n  buf = Buffer.concat([this._buf, buf]);\n  var frameLength;\n  while (\n    buf.length >= 4 &&\n    buf.length >= (frameLength = buf.readInt32BE(0)) + 4\n  ) {\n    if (frameLength) {\n      this._bufs.push(buf.slice(4, frameLength + 4));\n    } else {\n      var bufs = this._bufs;\n      this._bufs = [];\n      this.push({id: null, payload: bufs});\n    }\n    buf = buf.slice(frameLength + 4);\n  }\n  this._buf = buf;\n  cb();\n};\n\nFrameDecoder.prototype._flush = function () {\n  if (this._buf.length || this._bufs.length) {\n    var bufs = this._bufs.slice();\n    bufs.unshift(this._buf);\n    var err = toRpcError('TRAILING_DATA');\n    // Attach the data to help debugging (e.g. if the encoded bytes contain a\n    // human-readable protocol like HTTP).\n    err.trailingData = Buffer.concat(bufs).toString();\n    this.emit('error', err);\n  }\n};\n\n/** Standard framing stream. */\nfunction FrameEncoder() {\n  stream.Transform.call(this, {writableObjectMode: true});\n  this.on('finish', function () { this.push(null); });\n}\nutil.inherits(FrameEncoder, stream.Transform);\n\nFrameEncoder.prototype._transform = function (obj, encoding, cb) {\n  var bufs = obj.payload;\n  var i, l, buf;\n  for (i = 0, l = bufs.length; i < l; i++) {\n    buf = bufs[i];\n    this.push(intBuffer(buf.length));\n    this.push(buf);\n  }\n  this.push(intBuffer(0));\n  cb();\n};\n\n/** Netty-compatible decoding stream. */\nfunction NettyDecoder() {\n  stream.Transform.call(this, {readableObjectMode: true});\n  this._id = undefined;\n  this._frameCount = 0;\n  this._buf = utils.newBuffer(0);\n  this._bufs = [];\n\n  this.on('finish', function () { this.push(null); });\n}\nutil.inherits(NettyDecoder, stream.Transform);\n\nNettyDecoder.prototype._transform = function (buf, encoding, cb) {\n  buf = Buffer.concat([this._buf, buf]);\n\n  while (true) {\n    if (this._id === undefined) {\n      if (buf.length < 8) {\n        this._buf = buf;\n        cb();\n        return;\n      }\n      this._id = buf.readInt32BE(0);\n      this._frameCount = buf.readInt32BE(4);\n      buf = buf.slice(8);\n    }\n\n    var frameLength;\n    while (\n      this._frameCount &&\n      buf.length >= 4 &&\n      buf.length >= (frameLength = buf.readInt32BE(0)) + 4\n    ) {\n      this._frameCount--;\n      this._bufs.push(buf.slice(4, frameLength + 4));\n      buf = buf.slice(frameLength + 4);\n    }\n\n    if (this._frameCount) {\n      this._buf = buf;\n      cb();\n      return;\n    } else {\n      var obj = {id: this._id, payload: this._bufs};\n      this._bufs = [];\n      this._id = undefined;\n      this.push(obj);\n    }\n  }\n};\n\nNettyDecoder.prototype._flush = FrameDecoder.prototype._flush;\n\n/** Netty-compatible encoding stream. */\nfunction NettyEncoder() {\n  stream.Transform.call(this, {writableObjectMode: true});\n  this.on('finish', function () { this.push(null); });\n}\nutil.inherits(NettyEncoder, stream.Transform);\n\nNettyEncoder.prototype._transform = function (obj, encoding, cb) {\n  var bufs = obj.payload;\n  var l = bufs.length;\n  var buf;\n  // Header: [ ID, number of frames ]\n  buf = utils.newBuffer(8);\n  buf.writeInt32BE(obj.id, 0);\n  buf.writeInt32BE(l, 4);\n  this.push(buf);\n  // Frames, each: [ length, bytes ]\n  var i;\n  for (i = 0; i < l; i++) {\n    buf = bufs[i];\n    this.push(intBuffer(buf.length));\n    this.push(buf);\n  }\n  cb();\n};\n\n/**\n * Returns a buffer containing an integer's big-endian representation.\n *\n * @param n {Number} Integer.\n */\nfunction intBuffer(n) {\n  var buf = utils.newBuffer(4);\n  buf.writeInt32BE(n);\n  return buf;\n}\n\n/**\n * Decode a type used as prefix inside a buffer.\n *\n * @param type {Type} The type of the prefix.\n * @param buf {Buffer} Encoded bytes.\n *\n * This function will return an object `{head, tail}` where head contains the\n * decoded value and tail the rest of the buffer. An error will be thrown if\n * the prefix cannot be decoded.\n */\nfunction readHead(type, buf) {\n  var tap = new Tap(buf);\n  var head = type._read(tap);\n  if (!tap.isValid()) {\n    throw new Error(f('truncated %s', type));\n  }\n  return {head: head, tail: tap.buf.slice(tap.pos)};\n}\n\n/**\n * Generate a decoder, optimizing the case where reader and writer are equal.\n *\n * @param rtype {Type} Reader's type.\n * @param wtype {Type} Writer's type.\n */\nfunction createReader(rtype, wtype) {\n  return rtype.equals(wtype) ? rtype : rtype.createResolver(wtype);\n}\n\n/**\n * Generate all readers for a given protocol combination.\n *\n * @param clientSvc {Service} Client service.\n * @param serverSvc {Service} Client service.\n */\nfunction createReaders(clientSvc, serverSvc) {\n  var obj = {};\n  clientSvc.messages.forEach(function (c) {\n    var n = c.name;\n    var s = serverSvc.message(n);\n    try {\n      if (!s) {\n        throw new Error(f('missing server message: %s', n));\n      }\n      if (s.oneWay !== c.oneWay) {\n        throw new Error(f('inconsistent one-way message: %s', n));\n      }\n      obj[n + '?'] = createReader(s.requestType, c.requestType);\n      obj[n + '*'] = createReader(c.errorType, s.errorType);\n      obj[n + '!'] = createReader(c.responseType, s.responseType);\n    } catch (cause) {\n      throw toRpcError('INCOMPATIBLE_PROTOCOL', cause);\n    }\n  });\n  return obj;\n}\n\n/**\n * Populate a cache from a list of protocols.\n *\n * @param cache {Object} Cache of adapters.\n * @param svc {Service} The local service (either client or server).\n * @param ptcls {Array} Array of protocols to insert.\n * @param isClient {Boolean} Whether the local service is a client's or\n * server's.\n */\nfunction insertRemoteProtocols(cache, ptcls, svc, isClient) {\n  Object.keys(ptcls).forEach(function (hash) {\n    var ptcl = ptcls[hash];\n    var clientSvc, serverSvc;\n    if (isClient) {\n      clientSvc = svc;\n      serverSvc = Service.forProtocol(ptcl);\n    } else {\n      clientSvc = Service.forProtocol(ptcl);\n      serverSvc = svc;\n    }\n    cache[hash] = new Adapter(clientSvc, serverSvc, hash, true);\n  });\n}\n\n/**\n * Extract remote protocols from a cache\n *\n * @param cache {Object} Cache of adapters.\n * @param isClient {Boolean} Whether the remote protocols extracted should be\n * the servers' or clients'.\n */\nfunction getRemoteProtocols(cache, isClient) {\n  var ptcls = {};\n  Object.keys(cache).forEach(function (hs) {\n    var adapter = cache[hs];\n    if (adapter._isRemote) {\n      var svc = isClient ? adapter._serverSvc : adapter._clientSvc;\n      ptcls[hs] = svc.protocol;\n    }\n  });\n  return ptcls;\n}\n\n/**\n * Check whether something is an `Error`.\n *\n * @param any {Object} Any object.\n */\nfunction isError(any) {\n  // Also not ideal, but avoids brittle `instanceof` checks.\n  return !!any && Object.prototype.toString.call(any) === '[object Error]';\n}\n\n/**\n * Forward any errors emitted on the source to the destination.\n *\n * @param src {EventEmitter} The initial source of error events.\n * @param dst {EventEmitter} The new target of the source's error events. The\n * original source will be provided as second argument (the error being the\n * first).\n *\n * As a convenience, the source will be returned.\n */\nfunction forwardErrors(src, dst) {\n  return src.on('error', function (err) {\n    dst.emit('error', err, src);\n  });\n}\n\n/**\n * Create an error.\n *\n * @param msg {String} Error message.\n * @param cause {Error} The cause of the error. It is available as `cause`\n * field on the outer error.\n */\nfunction toError(msg, cause) {\n  var err = new Error(msg);\n  err.cause = cause;\n  return err;\n}\n\n/**\n * Mark an error.\n *\n * @param rpcCode {String} Code representing the failure.\n * @param cause {Error} The cause of the error. It is available as `cause`\n * field on the outer error.\n *\n * This is used to keep the argument of channels' `'error'` event errors.\n */\nfunction toRpcError(rpcCode, cause) {\n  var err = toError(rpcCode.toLowerCase().replace(/_/g, ' '), cause);\n  err.rpcCode = (cause && cause.rpcCode) ? cause.rpcCode : rpcCode;\n  return err;\n}\n\n/**\n * Provide a helpful error to identify why serialization failed.\n *\n * @param err {Error} The error to decorate.\n * @param obj {...} The object containing fields to validated.\n * @param fields {Array} Information about the fields to validate.\n */\nfunction serializationError(msg, obj, fields) {\n  var details = [];\n  var i, l, field;\n  for (i = 0, l = fields.length; i < l; i++) {\n    field = fields[i];\n    field.type.isValid(obj[field.name], {errorHook: errorHook});\n  }\n  var detailsStr = details\n    .map(function (obj) {\n      return f('%s = %j but expected %s', obj.path, obj.value, obj.type);\n    })\n    .join(', ');\n  var err = new Error(f('%s (%s)', msg, detailsStr));\n  err.details = details;\n  return err;\n\n  function errorHook(parts, any, type) {\n    var strs = [];\n    var i, l, part;\n    for (i = 0, l = parts.length; i < l; i++) {\n      part = parts[i];\n      if (isNaN(part)) {\n        strs.push('.' + part);\n      } else {\n        strs.push('[' + part + ']');\n      }\n    }\n    details.push({\n      path: field.name + strs.join(''),\n      value: any,\n      type: type\n    });\n  }\n}\n\n/**\n * Compute a prefix of fixed length from a string.\n *\n * @param scope {String} Namespace to be hashed.\n */\nfunction normalizedPrefix(scope) {\n  return scope ?\n    utils.getHash(scope).readInt16BE(0) << (32 - PREFIX_LENGTH) :\n    0;\n}\n\n/**\n * Check whether an ID matches the prefix.\n *\n * @param id {Integer} Number to check.\n * @param prefix {Integer} Already shifted prefix.\n */\nfunction matchesPrefix(id, prefix) {\n  return ((id ^ prefix) >> (32 - PREFIX_LENGTH)) === 0;\n}\n\n/**\n * Check whether something is a stream.\n *\n * @param any {Object} Any object.\n */\nfunction isStream(any) {\n  // This is a hacky way of checking that the transport is a stream-like\n  // object. We unfortunately can't use `instanceof Stream` checks since\n  // some libraries (e.g. websocket-stream) return streams which don't\n  // inherit from it.\n  return !!(any && any.pipe);\n}\n\n/**\n * Get a message, asserting that it exists.\n *\n * @param svc {Service} The protocol to look into.\n * @param name {String} The message's name.\n */\nfunction getExistingMessage(svc, name) {\n  var msg = svc.message(name);\n  if (!msg) {\n    throw new Error(f('unknown message: %s', name));\n  }\n  return msg;\n}\n\n/**\n * Middleware logic.\n *\n * This is used both in clients and servers to intercept call handling (e.g. to\n * populate headers, do access control).\n *\n * @param params {Object} The following parameters:\n *  + fns {Array} Array of middleware functions.\n *  + ctx {Object} Context used to call the middleware functions, onTransition,\n *    and onCompletion.\n *  + wreq {WrappedRequest}\n *  + wres {WrappedResponse}\n *  + onTransition {Function} End of forward phase callback. It accepts an\n *    eventual error as single argument. This will be used for the backward\n *    phase. This function is guaranteed to be called at most once.\n *  + onCompletion {Function} Final handler, it takes an error as unique\n *    argument. This function is guaranteed to be only at most once.\n *  + onError {Function} Error handler, called if an intermediate callback is\n *    called multiple times.\n */\nfunction chainMiddleware(params) {\n  var args = [params.wreq, params.wres];\n  var cbs = [];\n  var cause; // Backpropagated error.\n  forward(0);\n\n  function forward(pos) {\n    var isDone = false;\n    if (pos < params.fns.length) {\n      params.fns[pos].apply(params.ctx, args.concat(function (err, cb) {\n        if (isDone) {\n          params.onError(toError('duplicate forward middleware call', err));\n          return;\n        }\n        isDone = true;\n        if (\n          err || (\n            params.wres && ( // Non one-way messages.\n              params.wres.error !== undefined ||\n              params.wres.response !== undefined\n            )\n          )\n        ) {\n          // Stop the forward phase, bypass the handler, and start the backward\n          // phase. Note that we ignore any callback argument in this case.\n          cause = err;\n          backward();\n          return;\n        }\n        if (cb) {\n          cbs.push(cb);\n        }\n        forward(++pos);\n      }));\n    } else {\n      // Done with the middleware forward functions, call the handler.\n      params.onTransition.apply(params.ctx, args.concat(function (err) {\n        if (isDone) {\n          params.onError(toError('duplicate handler call', err));\n          return;\n        }\n        isDone = true;\n        cause = err;\n        process.nextTick(backward);\n      }));\n    }\n  }\n\n  function backward() {\n    var cb = cbs.pop();\n    if (cb) {\n      var isDone = false;\n      cb.call(params.ctx, cause, function (err) {\n        if (isDone) {\n          params.onError(toError('duplicate backward middleware call', err));\n          return;\n        }\n        // Substitute the error.\n        cause = err;\n        isDone = true;\n        backward();\n      });\n    } else {\n      // Done with all middleware calls.\n      params.onCompletion.call(params.ctx, cause);\n    }\n  }\n}\n\n\nmodule.exports = {\n  Adapter: Adapter,\n  HANDSHAKE_REQUEST_TYPE: HANDSHAKE_REQUEST_TYPE,\n  HANDSHAKE_RESPONSE_TYPE: HANDSHAKE_RESPONSE_TYPE,\n  Message: Message,\n  Registry: Registry,\n  Service: Service,\n  discoverProtocol: discoverProtocol,\n  streams: {\n    FrameDecoder: FrameDecoder,\n    FrameEncoder: FrameEncoder,\n    NettyDecoder: NettyDecoder,\n    NettyEncoder: NettyEncoder\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}