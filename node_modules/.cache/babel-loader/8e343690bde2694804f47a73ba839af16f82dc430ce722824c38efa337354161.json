{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst ArweaveUtils = require(\"./lib/utils\");\nrequire(\"arconnect\");\nclass Wallets {\n  constructor(api, crypto) {\n    this.api = api;\n    this.crypto = crypto;\n  }\n  /**\n   * Get the wallet balance for the given address.\n   *\n   * @param {string} address - The arweave address to get the balance for.\n   *\n   * @returns {Promise<string>} - Promise which resolves with a winston string balance.\n   */\n  getBalance(address) {\n    return this.api.get(`wallet/${address}/balance`, {\n      transformResponse: [\n      /**\n       * We need to specify a response transformer to override\n       * the default JSON.parse behaviour, as this causes\n       * balances to be converted to a number and we want to\n       * return it as a winston string.\n       * @param data\n       */\n      function (data) {\n        return data;\n      }]\n    }).then(response => {\n      return response.data;\n    });\n  }\n  /**\n   * Get the last transaction ID for the given wallet address.\n   *\n   * @param {string} address - The arweave address to get the transaction for.\n   *\n   * @returns {Promise<string>} - Promise which resolves with a transaction ID.\n   */\n  getLastTransactionID(address) {\n    return this.api.get(`wallet/${address}/last_tx`).then(response => {\n      return response.data;\n    });\n  }\n  generate() {\n    return this.crypto.generateJWK();\n  }\n  async jwkToAddress(jwk) {\n    if (!jwk || jwk === \"use_wallet\") {\n      return this.getAddress();\n    } else {\n      return this.getAddress(jwk);\n    }\n  }\n  async getAddress(jwk) {\n    if (!jwk || jwk === \"use_wallet\") {\n      try {\n        // @ts-ignore\n        await arweaveWallet.connect([\"ACCESS_ADDRESS\"]);\n      } catch (_a) {\n        // Permission is already granted\n      }\n      // @ts-ignore\n      return arweaveWallet.getActiveAddress();\n    } else {\n      return this.ownerToAddress(jwk.n);\n    }\n  }\n  async ownerToAddress(owner) {\n    return ArweaveUtils.bufferTob64Url(await this.crypto.hash(ArweaveUtils.b64UrlToBuffer(owner)));\n  }\n}\nexports.default = Wallets;","map":{"version":3,"names":["ArweaveUtils","require","Wallets","constructor","api","crypto","getBalance","address","get","transformResponse","data","then","response","getLastTransactionID","generate","generateJWK","jwkToAddress","jwk","getAddress","arweaveWallet","connect","_a","getActiveAddress","ownerToAddress","n","owner","bufferTob64Url","hash","b64UrlToBuffer","exports","default"],"sources":["../../../src/common/wallets.ts"],"sourcesContent":[null],"mappings":";;;;;AAGA,MAAAA,YAAA,GAAAC,OAAA;AACAA,OAAA;AAEA,MAAqBC,OAAO;EAK1BC,YAAYC,GAAQ,EAAEC,MAAuB;IAC3C,IAAI,CAACD,GAAG,GAAGA,GAAG;IACd,IAAI,CAACC,MAAM,GAAGA,MAAM;EACtB;EAEA;;;;;;;EAOOC,UAAUA,CAACC,OAAe;IAC/B,OAAO,IAAI,CAACH,GAAG,CACZI,GAAG,CAAC,UAAUD,OAAO,UAAU,EAAE;MAChCE,iBAAiB,EAAE;MACjB;;;;;;;MAOA,UAAUC,IAAI;QACZ,OAAOA,IAAI;MACb,CAAC;KAEJ,CAAC,CACDC,IAAI,CAAEC,QAAQ,IAAI;MACjB,OAAOA,QAAQ,CAACF,IAAI;IACtB,CAAC,CAAC;EACN;EAEA;;;;;;;EAOOG,oBAAoBA,CAACN,OAAe;IACzC,OAAO,IAAI,CAACH,GAAG,CAACI,GAAG,CAAC,UAAUD,OAAO,UAAU,CAAC,CAACI,IAAI,CAAEC,QAAQ,IAAI;MACjE,OAAOA,QAAQ,CAACF,IAAI;IACtB,CAAC,CAAC;EACJ;EAEOI,QAAQA,CAAA;IACb,OAAO,IAAI,CAACT,MAAM,CAACU,WAAW,EAAE;EAClC;EAEO,MAAMC,YAAYA,CACvBC,GAAiC;IAEjC,IAAI,CAACA,GAAG,IAAIA,GAAG,KAAK,YAAY,EAAE;MAChC,OAAO,IAAI,CAACC,UAAU,EAAE;KACzB,MAAM;MACL,OAAO,IAAI,CAACA,UAAU,CAACD,GAAG,CAAC;;EAE/B;EAEO,MAAMC,UAAUA,CAACD,GAAiC;IACvD,IAAI,CAACA,GAAG,IAAIA,GAAG,KAAK,YAAY,EAAE;MAChC,IAAI;QACF;QACA,MAAME,aAAa,CAACC,OAAO,CAAC,CAAC,gBAAgB,CAAC,CAAC;OAChD,CAAC,OAAAC,EAAA,EAAM;QACN;MAAA;MAGF;MACA,OAAOF,aAAa,CAACG,gBAAgB,EAAE;KACxC,MAAM;MACL,OAAO,IAAI,CAACC,cAAc,CAACN,GAAG,CAACO,CAAC,CAAC;;EAErC;EAEO,MAAMD,cAAcA,CAACE,KAAa;IACvC,OAAOzB,YAAY,CAAC0B,cAAc,CAChC,MAAM,IAAI,CAACrB,MAAM,CAACsB,IAAI,CAAC3B,YAAY,CAAC4B,cAAc,CAACH,KAAK,CAAC,CAAC,CAC3D;EACH;;AArFFI,OAAA,CAAAC,OAAA,GAAA5B,OAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}