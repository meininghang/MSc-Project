{"ast":null,"code":"/* jshint node: true */\n\n// TODO: Make it easier to implement custom types. This will likely require\n// exposing the `Tap` object, perhaps under another name. Probably worth a\n// major release.\n// TODO: Allow configuring when to write the size when writing arrays and maps,\n// and customizing their block size.\n// TODO: Code-generate `compare` and `clone` record and union methods.\n\n'use strict';\n\n/**\n * This module defines all Avro data types and their serialization logic.\n *\n */\nrequire(\"core-js/modules/es.array.push.js\");\nvar utils = require('./utils'),\n  buffer = require('buffer'),\n  // For `SlowBuffer`.\n  util = require('util');\n\n// Convenience imports.\nvar Tap = utils.Tap;\nvar debug = util.debuglog('avsc:types');\nvar f = util.format;\n\n// All non-union concrete (i.e. non-logical) Avro types.\nvar TYPES = {\n  'array': ArrayType,\n  'boolean': BooleanType,\n  'bytes': BytesType,\n  'double': DoubleType,\n  'enum': EnumType,\n  'error': RecordType,\n  'fixed': FixedType,\n  'float': FloatType,\n  'int': IntType,\n  'long': LongType,\n  'map': MapType,\n  'null': NullType,\n  'record': RecordType,\n  'string': StringType\n};\n\n// Valid (field, type, and symbol) name regex.\nvar NAME_PATTERN = /^[A-Za-z_][A-Za-z0-9_]*$/;\n\n// Random generator.\nvar RANDOM = new utils.Lcg();\n\n// Encoding tap (shared for performance).\nvar TAP = new Tap(new buffer.SlowBuffer(1024));\n\n// Currently active logical type, used for name redirection.\nvar LOGICAL_TYPE = null;\n\n// Underlying types of logical types currently being instantiated. This is used\n// to be able to reference names (i.e. for branches) during instantiation.\nvar UNDERLYING_TYPES = [];\n\n/**\n * \"Abstract\" base Avro type.\n *\n * This class' constructor will register any named types to support recursive\n * schemas. All type values are represented in memory similarly to their JSON\n * representation, except for:\n *\n * + `bytes` and `fixed` which are represented as `Buffer`s.\n * + `union`s which will be \"unwrapped\" unless the `wrapUnions` option is set.\n *\n *  See individual subclasses for details.\n */\nfunction Type(schema, opts) {\n  var type;\n  if (LOGICAL_TYPE) {\n    type = LOGICAL_TYPE;\n    UNDERLYING_TYPES.push([LOGICAL_TYPE, this]);\n    LOGICAL_TYPE = null;\n  } else {\n    type = this;\n  }\n\n  // Lazily instantiated hash string. It will be generated the first time the\n  // type's default fingerprint is computed (for example when using `equals`).\n  // We use a mutable object since types are frozen after instantiation.\n  this._hash = new Hash();\n  this.name = undefined;\n  this.aliases = undefined;\n  this.doc = schema && schema.doc ? '' + schema.doc : undefined;\n  if (schema) {\n    // This is a complex (i.e. non-primitive) type.\n    var name = schema.name;\n    var namespace = schema.namespace === undefined ? opts && opts.namespace : schema.namespace;\n    if (name !== undefined) {\n      // This isn't an anonymous type.\n      name = qualify(name, namespace);\n      if (isPrimitive(name)) {\n        // Avro doesn't allow redefining primitive names.\n        throw new Error(f('cannot rename primitive type: %j', name));\n      }\n      var registry = opts && opts.registry;\n      if (registry) {\n        if (registry[name] !== undefined) {\n          throw new Error(f('duplicate type name: %s', name));\n        }\n        registry[name] = type;\n      }\n    } else if (opts && opts.noAnonymousTypes) {\n      throw new Error(f('missing name property in schema: %j', schema));\n    }\n    this.name = name;\n    this.aliases = schema.aliases ? schema.aliases.map(function (s) {\n      return qualify(s, namespace);\n    }) : [];\n  }\n}\nType.forSchema = function (schema, opts) {\n  opts = opts || {};\n  opts.registry = opts.registry || {};\n  var UnionType = function (wrapUnions) {\n    if (wrapUnions === true) {\n      wrapUnions = 'always';\n    } else if (wrapUnions === false) {\n      wrapUnions = 'never';\n    } else if (wrapUnions === undefined) {\n      wrapUnions = 'auto';\n    } else if (typeof wrapUnions == 'string') {\n      wrapUnions = wrapUnions.toLowerCase();\n    }\n    switch (wrapUnions) {\n      case 'always':\n        return WrappedUnionType;\n      case 'never':\n        return UnwrappedUnionType;\n      case 'auto':\n        return undefined;\n      // Determined dynamically later on.\n      default:\n        throw new Error(f('invalid wrap unions option: %j', wrapUnions));\n    }\n  }(opts.wrapUnions);\n  if (schema === null) {\n    // Let's be helpful for this common error.\n    throw new Error('invalid type: null (did you mean \"null\"?)');\n  }\n  if (Type.isType(schema)) {\n    return schema;\n  }\n  var type;\n  if (opts.typeHook && (type = opts.typeHook(schema, opts))) {\n    if (!Type.isType(type)) {\n      throw new Error(f('invalid typehook return value: %j', type));\n    }\n    return type;\n  }\n  if (typeof schema == 'string') {\n    // Type reference.\n    schema = qualify(schema, opts.namespace);\n    type = opts.registry[schema];\n    if (type) {\n      // Type was already defined, return it.\n      return type;\n    }\n    if (isPrimitive(schema)) {\n      // Reference to a primitive type. These are also defined names by default\n      // so we create the appropriate type and it to the registry for future\n      // reference.\n      return opts.registry[schema] = Type.forSchema({\n        type: schema\n      }, opts);\n    }\n    throw new Error(f('undefined type name: %s', schema));\n  }\n  if (schema.logicalType && opts.logicalTypes && !LOGICAL_TYPE) {\n    var DerivedType = opts.logicalTypes[schema.logicalType];\n    if (DerivedType) {\n      var namespace = opts.namespace;\n      var registry = {};\n      Object.keys(opts.registry).forEach(function (key) {\n        registry[key] = opts.registry[key];\n      });\n      try {\n        debug('instantiating logical type for %s', schema.logicalType);\n        return new DerivedType(schema, opts);\n      } catch (err) {\n        debug('failed to instantiate logical type for %s', schema.logicalType);\n        if (opts.assertLogicalTypes) {\n          // The spec mandates that we fall through to the underlying type if\n          // the logical type is invalid. We provide this option to ease\n          // debugging.\n          throw err;\n        }\n        LOGICAL_TYPE = null;\n        opts.namespace = namespace;\n        opts.registry = registry;\n      }\n    }\n  }\n  if (Array.isArray(schema)) {\n    // Union.\n    var types = schema.map(function (obj) {\n      return Type.forSchema(obj, opts);\n    });\n    if (!UnionType) {\n      UnionType = isAmbiguous(types) ? WrappedUnionType : UnwrappedUnionType;\n    }\n    type = new UnionType(types, opts);\n  } else {\n    // New type definition.\n    type = function (typeName) {\n      var Type = TYPES[typeName];\n      if (Type === undefined) {\n        throw new Error(f('unknown type: %j', typeName));\n      }\n      return new Type(schema, opts);\n    }(schema.type);\n  }\n  return type;\n};\nType.forValue = function (val, opts) {\n  opts = opts || {};\n\n  // Sentinel used when inferring the types of empty arrays.\n  opts.emptyArrayType = opts.emptyArrayType || Type.forSchema({\n    type: 'array',\n    items: 'null'\n  });\n\n  // Optional custom inference hook.\n  if (opts.valueHook) {\n    var type = opts.valueHook(val, opts);\n    if (type !== undefined) {\n      if (!Type.isType(type)) {\n        throw new Error(f('invalid value hook return value: %j', type));\n      }\n      return type;\n    }\n  }\n\n  // Default inference logic.\n  switch (typeof val) {\n    case 'string':\n      return Type.forSchema('string', opts);\n    case 'boolean':\n      return Type.forSchema('boolean', opts);\n    case 'number':\n      if ((val | 0) === val) {\n        return Type.forSchema('int', opts);\n      } else if (Math.abs(val) < 9007199254740991) {\n        return Type.forSchema('float', opts);\n      }\n      return Type.forSchema('double', opts);\n    case 'object':\n      if (val === null) {\n        return Type.forSchema('null', opts);\n      } else if (Array.isArray(val)) {\n        if (!val.length) {\n          return opts.emptyArrayType;\n        }\n        return Type.forSchema({\n          type: 'array',\n          items: Type.forTypes(val.map(function (v) {\n            return Type.forValue(v, opts);\n          }))\n        }, opts);\n      } else if (Buffer.isBuffer(val)) {\n        return Type.forSchema('bytes', opts);\n      }\n      var fieldNames = Object.keys(val);\n      if (fieldNames.some(function (s) {\n        return !isValidName(s);\n      })) {\n        // We have to fall back to a map.\n        return Type.forSchema({\n          type: 'map',\n          values: Type.forTypes(fieldNames.map(function (s) {\n            return Type.forValue(val[s], opts);\n          }), opts)\n        }, opts);\n      }\n      return Type.forSchema({\n        type: 'record',\n        fields: fieldNames.map(function (s) {\n          return {\n            name: s,\n            type: Type.forValue(val[s], opts)\n          };\n        })\n      }, opts);\n    default:\n      throw new Error(f('cannot infer type from: %j', val));\n  }\n};\nType.forTypes = function (types, opts) {\n  if (!types.length) {\n    throw new Error('no types to combine');\n  }\n  if (types.length === 1) {\n    return types[0]; // Nothing to do.\n  }\n\n  opts = opts || {};\n\n  // Extract any union types, with special care for wrapped unions (see below).\n  var expanded = [];\n  var numWrappedUnions = 0;\n  var isValidWrappedUnion = true;\n  types.forEach(function (type) {\n    switch (type.typeName) {\n      case 'union:unwrapped':\n        isValidWrappedUnion = false;\n        expanded = expanded.concat(type.types);\n        break;\n      case 'union:wrapped':\n        numWrappedUnions++;\n        expanded = expanded.concat(type.types);\n        break;\n      case 'null':\n        expanded.push(type);\n        break;\n      default:\n        isValidWrappedUnion = false;\n        expanded.push(type);\n    }\n  });\n  if (numWrappedUnions) {\n    if (!isValidWrappedUnion) {\n      // It is only valid to combine wrapped unions when no other type is\n      // present other than wrapped unions and nulls (otherwise the values of\n      // others wouldn't be valid in the resulting union).\n      throw new Error('cannot combine wrapped union');\n    }\n    var branchTypes = {};\n    expanded.forEach(function (type) {\n      var name = type.branchName;\n      var branchType = branchTypes[name];\n      if (!branchType) {\n        branchTypes[name] = type;\n      } else if (!type.equals(branchType)) {\n        throw new Error('inconsistent branch type');\n      }\n    });\n    var wrapUnions = opts.wrapUnions;\n    var unionType;\n    opts.wrapUnions = true;\n    try {\n      unionType = Type.forSchema(Object.keys(branchTypes).map(function (name) {\n        return branchTypes[name];\n      }), opts);\n    } catch (err) {\n      opts.wrapUnions = wrapUnions;\n      throw err;\n    }\n    opts.wrapUnions = wrapUnions;\n    return unionType;\n  }\n\n  // Group types by category, similar to the logic for unwrapped unions.\n  var bucketized = {};\n  expanded.forEach(function (type) {\n    var bucket = getTypeBucket(type);\n    var bucketTypes = bucketized[bucket];\n    if (!bucketTypes) {\n      bucketized[bucket] = bucketTypes = [];\n    }\n    bucketTypes.push(type);\n  });\n\n  // Generate the \"augmented\" type for each group.\n  var buckets = Object.keys(bucketized);\n  var augmented = buckets.map(function (bucket) {\n    var bucketTypes = bucketized[bucket];\n    if (bucketTypes.length === 1) {\n      return bucketTypes[0];\n    } else {\n      switch (bucket) {\n        case 'null':\n        case 'boolean':\n          return bucketTypes[0];\n        case 'number':\n          return combineNumbers(bucketTypes);\n        case 'string':\n          return combineStrings(bucketTypes, opts);\n        case 'buffer':\n          return combineBuffers(bucketTypes, opts);\n        case 'array':\n          // Remove any sentinel arrays (used when inferring from empty arrays)\n          // to avoid making things nullable when they shouldn't be.\n          bucketTypes = bucketTypes.filter(function (t) {\n            return t !== opts.emptyArrayType;\n          });\n          if (!bucketTypes.length) {\n            // We still don't have a real type, just return the sentinel.\n            return opts.emptyArrayType;\n          }\n          return Type.forSchema({\n            type: 'array',\n            items: Type.forTypes(bucketTypes.map(function (t) {\n              return t.itemsType;\n            }))\n          }, opts);\n        default:\n          return combineObjects(bucketTypes, opts);\n      }\n    }\n  });\n  if (augmented.length === 1) {\n    return augmented[0];\n  } else {\n    // We return an (unwrapped) union of all augmented types.\n    return Type.forSchema(augmented, opts);\n  }\n};\nType.isType = function /* any, [prefix] ... */\n() {\n  var l = arguments.length;\n  if (!l) {\n    return false;\n  }\n  var any = arguments[0];\n  if (!any || typeof any._update != 'function' || typeof any.fingerprint != 'function') {\n    // Not fool-proof, but most likely good enough.\n    return false;\n  }\n  if (l === 1) {\n    // No type names specified, we are done.\n    return true;\n  }\n\n  // We check if at least one of the prefixes matches.\n  var typeName = any.typeName;\n  var i;\n  for (i = 1; i < l; i++) {\n    if (typeName.indexOf(arguments[i]) === 0) {\n      return true;\n    }\n  }\n  return false;\n};\nType.__reset = function (size) {\n  debug('resetting type buffer to %d', size);\n  TAP.buf = new buffer.SlowBuffer(size);\n};\nObject.defineProperty(Type.prototype, 'branchName', {\n  enumerable: true,\n  get: function () {\n    if (this.name) {\n      return this.name;\n    }\n    var type = Type.isType(this, 'logical') ? this.underlyingType : this;\n    if (Type.isType(type, 'abstract')) {\n      return type._concreteTypeName;\n    }\n    return Type.isType(type, 'union') ? undefined : type.typeName;\n  }\n});\nType.prototype.clone = function (val, opts) {\n  if (opts) {\n    opts = {\n      coerce: !!opts.coerceBuffers | 0,\n      // Coerce JSON to Buffer.\n      fieldHook: opts.fieldHook,\n      qualifyNames: !!opts.qualifyNames,\n      skip: !!opts.skipMissingFields,\n      wrap: !!opts.wrapUnions | 0 // Wrap first match into union.\n    };\n\n    return this._copy(val, opts);\n  } else {\n    // If no modifications are required, we can get by with a serialization\n    // roundtrip (generally much faster than a standard deep copy).\n    return this.fromBuffer(this.toBuffer(val));\n  }\n};\nType.prototype.compare = utils.abstractFunction;\nType.prototype.compareBuffers = function (buf1, buf2) {\n  return this._match(new Tap(buf1), new Tap(buf2));\n};\nType.prototype.createResolver = function (type, opts) {\n  if (!Type.isType(type)) {\n    // More explicit error message than the \"incompatible type\" thrown\n    // otherwise (especially because of the overridden `toJSON` method).\n    throw new Error(f('not a type: %j', type));\n  }\n  if (!Type.isType(this, 'union', 'logical') && Type.isType(type, 'logical')) {\n    // Trying to read a logical type as a built-in: unwrap the logical type.\n    // Note that we exclude unions to support resolving into unions containing\n    // logical types.\n    return this.createResolver(type.underlyingType, opts);\n  }\n  opts = opts || {};\n  opts.registry = opts.registry || {};\n  var resolver, key;\n  if (Type.isType(this, 'record', 'error') && Type.isType(type, 'record', 'error')) {\n    // We allow conversions between records and errors.\n    key = this.name + ':' + type.name; // ':' is illegal in Avro type names.\n    resolver = opts.registry[key];\n    if (resolver) {\n      return resolver;\n    }\n  }\n  resolver = new Resolver(this);\n  if (key) {\n    // Register resolver early for recursive schemas.\n    opts.registry[key] = resolver;\n  }\n  if (Type.isType(type, 'union')) {\n    var resolvers = type.types.map(function (t) {\n      return this.createResolver(t, opts);\n    }, this);\n    resolver._read = function (tap) {\n      var index = tap.readLong();\n      var resolver = resolvers[index];\n      if (resolver === undefined) {\n        throw new Error(f('invalid union index: %s', index));\n      }\n      return resolvers[index]._read(tap);\n    };\n  } else {\n    this._update(resolver, type, opts);\n  }\n  if (!resolver._read) {\n    throw new Error(f('cannot read %s as %s', type, this));\n  }\n  return Object.freeze(resolver);\n};\nType.prototype.decode = function (buf, pos, resolver) {\n  var tap = new Tap(buf, pos);\n  var val = readValue(this, tap, resolver);\n  if (!tap.isValid()) {\n    return {\n      value: undefined,\n      offset: -1\n    };\n  }\n  return {\n    value: val,\n    offset: tap.pos\n  };\n};\nType.prototype.encode = function (val, buf, pos) {\n  var tap = new Tap(buf, pos);\n  this._write(tap, val);\n  if (!tap.isValid()) {\n    // Don't throw as there is no way to predict this. We also return the\n    // number of missing bytes to ease resizing.\n    return buf.length - tap.pos;\n  }\n  return tap.pos;\n};\nType.prototype.equals = function (type) {\n  return Type.isType(type) && this.fingerprint().equals(type.fingerprint());\n};\nType.prototype.fingerprint = function (algorithm) {\n  if (!algorithm) {\n    if (!this._hash.str) {\n      var schemaStr = JSON.stringify(this.schema());\n      this._hash.str = utils.getHash(schemaStr).toString('binary');\n    }\n    return utils.bufferFrom(this._hash.str, 'binary');\n  } else {\n    return utils.getHash(JSON.stringify(this.schema()), algorithm);\n  }\n};\nType.prototype.fromBuffer = function (buf, resolver, noCheck) {\n  var tap = new Tap(buf);\n  var val = readValue(this, tap, resolver, noCheck);\n  if (!tap.isValid()) {\n    throw new Error('truncated buffer');\n  }\n  if (!noCheck && tap.pos < buf.length) {\n    throw new Error('trailing data');\n  }\n  return val;\n};\nType.prototype.fromString = function (str) {\n  return this._copy(JSON.parse(str), {\n    coerce: 2\n  });\n};\nType.prototype.inspect = function () {\n  var typeName = this.typeName;\n  var className = getClassName(typeName);\n  if (isPrimitive(typeName)) {\n    // The class name is sufficient to identify the type.\n    return f('<%s>', className);\n  } else {\n    // We add a little metadata for convenience.\n    var obj = this.schema({\n      exportAttrs: true,\n      noDeref: true\n    });\n    if (typeof obj == 'object' && !Type.isType(this, 'logical')) {\n      obj.type = undefined; // Would be redundant with constructor name.\n    }\n\n    return f('<%s %j>', className, obj);\n  }\n};\nType.prototype.isValid = function (val, opts) {\n  // We only have a single flag for now, so no need to complicate things.\n  var flags = (opts && opts.noUndeclaredFields) | 0;\n  var errorHook = opts && opts.errorHook;\n  var hook, path;\n  if (errorHook) {\n    path = [];\n    hook = function (any, type) {\n      errorHook.call(this, path.slice(), any, type, val);\n    };\n  }\n  return this._check(val, flags, hook, path);\n};\nType.prototype.random = utils.abstractFunction;\nType.prototype.schema = function (opts) {\n  // Copy the options to avoid mutating the original options object when we add\n  // the registry of dereferenced types.\n  return this._attrs({\n    exportAttrs: !!(opts && opts.exportAttrs),\n    noDeref: !!(opts && opts.noDeref)\n  });\n};\nType.prototype.toBuffer = function (val) {\n  TAP.pos = 0;\n  this._write(TAP, val);\n  var buf = utils.newBuffer(TAP.pos);\n  if (TAP.isValid()) {\n    TAP.buf.copy(buf, 0, 0, TAP.pos);\n  } else {\n    this._write(new Tap(buf), val);\n  }\n  return buf;\n};\nType.prototype.toJSON = function () {\n  // Convenience to allow using `JSON.stringify(type)` to get a type's schema.\n  return this.schema({\n    exportAttrs: true\n  });\n};\nType.prototype.toString = function (val) {\n  if (val === undefined) {\n    // Consistent behavior with standard `toString` expectations.\n    return JSON.stringify(this.schema({\n      noDeref: true\n    }));\n  }\n  return JSON.stringify(this._copy(val, {\n    coerce: 3\n  }));\n};\nType.prototype.wrap = function (val) {\n  var Branch = this._branchConstructor;\n  return Branch === null ? null : new Branch(val);\n};\nType.prototype._attrs = function (opts) {\n  // This function handles a lot of the common logic to schema generation\n  // across types, for example keeping track of which types have already been\n  // de-referenced (i.e. derefed).\n  opts.derefed = opts.derefed || {};\n  var name = this.name;\n  if (name !== undefined) {\n    if (opts.noDeref || opts.derefed[name]) {\n      return name;\n    }\n    opts.derefed[name] = true;\n  }\n  var schema = {};\n  // The order in which we add fields to the `schema` object matters here.\n  // Since JS objects are unordered, this implementation (unfortunately) relies\n  // on engines returning properties in the same order that they are inserted\n  // in. This is not in the JS spec, but can be \"somewhat\" safely assumed (see\n  // http://stackoverflow.com/q/5525795/1062617).\n  if (this.name !== undefined) {\n    schema.name = name;\n  }\n  schema.type = this.typeName;\n  var derefedSchema = this._deref(schema, opts);\n  if (derefedSchema !== undefined) {\n    // We allow the original schema to be overridden (this will happen for\n    // primitive types and logical types).\n    schema = derefedSchema;\n  }\n  if (opts.exportAttrs) {\n    if (this.aliases && this.aliases.length) {\n      schema.aliases = this.aliases;\n    }\n    if (this.doc !== undefined) {\n      schema.doc = this.doc;\n    }\n  }\n  return schema;\n};\nType.prototype._createBranchConstructor = function () {\n  // jshint -W054\n  var name = this.branchName;\n  if (name === 'null') {\n    return null;\n  }\n  function ConstructorFunction() {\n    return function Branch$(val) {\n      if (~name.indexOf('.')) {\n        this[`${name}`] = val;\n      } else {\n        this[name] = val;\n      }\n    };\n  }\n  var Branch = ConstructorFunction();\n  Branch.type = this;\n  Branch.prototype.unwrap = function () {\n    return this[`${name}`];\n  };\n  Branch.prototype.unwrapped = Branch.prototype.unwrap; // Deprecated.\n  return Branch;\n};\nType.prototype._peek = function (tap) {\n  var pos = tap.pos;\n  var val = this._read(tap);\n  tap.pos = pos;\n  return val;\n};\nType.prototype._check = utils.abstractFunction;\nType.prototype._copy = utils.abstractFunction;\nType.prototype._deref = utils.abstractFunction;\nType.prototype._match = utils.abstractFunction;\nType.prototype._read = utils.abstractFunction;\nType.prototype._skip = utils.abstractFunction;\nType.prototype._update = utils.abstractFunction;\nType.prototype._write = utils.abstractFunction;\n\n// \"Deprecated\" getters (will be explicitly deprecated in 5.1).\n\nType.prototype.getAliases = function () {\n  return this.aliases;\n};\nType.prototype.getFingerprint = Type.prototype.fingerprint;\nType.prototype.getName = function (asBranch) {\n  return this.name || !asBranch ? this.name : this.branchName;\n};\nType.prototype.getSchema = Type.prototype.schema;\nType.prototype.getTypeName = function () {\n  return this.typeName;\n};\n\n// Implementations.\n\n/**\n * Base primitive Avro type.\n *\n * Most of the primitive types share the same cloning and resolution\n * mechanisms, provided by this class. This class also lets us conveniently\n * check whether a type is a primitive using `instanceof`.\n */\nfunction PrimitiveType(noFreeze) {\n  Type.call(this);\n  this._branchConstructor = this._createBranchConstructor();\n  if (!noFreeze) {\n    // Abstract long types can't be frozen at this stage.\n    Object.freeze(this);\n  }\n}\nutil.inherits(PrimitiveType, Type);\nPrimitiveType.prototype._update = function (resolver, type) {\n  if (type.typeName === this.typeName) {\n    resolver._read = this._read;\n  }\n};\nPrimitiveType.prototype._copy = function (val) {\n  this._check(val, undefined, throwInvalidError);\n  return val;\n};\nPrimitiveType.prototype._deref = function () {\n  return this.typeName;\n};\nPrimitiveType.prototype.compare = utils.compare;\n\n/** Nulls. */\nfunction NullType() {\n  PrimitiveType.call(this);\n}\nutil.inherits(NullType, PrimitiveType);\nNullType.prototype._check = function (val, flags, hook) {\n  var b = val === null;\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\nNullType.prototype._read = function () {\n  return null;\n};\nNullType.prototype._skip = function () {};\nNullType.prototype._write = function (tap, val) {\n  if (val !== null) {\n    throwInvalidError(val, this);\n  }\n};\nNullType.prototype._match = function () {\n  return 0;\n};\nNullType.prototype.compare = NullType.prototype._match;\nNullType.prototype.typeName = 'null';\nNullType.prototype.random = NullType.prototype._read;\n\n/** Booleans. */\nfunction BooleanType() {\n  PrimitiveType.call(this);\n}\nutil.inherits(BooleanType, PrimitiveType);\nBooleanType.prototype._check = function (val, flags, hook) {\n  var b = typeof val == 'boolean';\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\nBooleanType.prototype._read = function (tap) {\n  return tap.readBoolean();\n};\nBooleanType.prototype._skip = function (tap) {\n  tap.skipBoolean();\n};\nBooleanType.prototype._write = function (tap, val) {\n  if (typeof val != 'boolean') {\n    throwInvalidError(val, this);\n  }\n  tap.writeBoolean(val);\n};\nBooleanType.prototype._match = function (tap1, tap2) {\n  return tap1.matchBoolean(tap2);\n};\nBooleanType.prototype.typeName = 'boolean';\nBooleanType.prototype.random = function () {\n  return RANDOM.nextBoolean();\n};\n\n/** Integers. */\nfunction IntType() {\n  PrimitiveType.call(this);\n}\nutil.inherits(IntType, PrimitiveType);\nIntType.prototype._check = function (val, flags, hook) {\n  var b = val === (val | 0);\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\nIntType.prototype._read = function (tap) {\n  return tap.readInt();\n};\nIntType.prototype._skip = function (tap) {\n  tap.skipInt();\n};\nIntType.prototype._write = function (tap, val) {\n  if (val !== (val | 0)) {\n    throwInvalidError(val, this);\n  }\n  tap.writeInt(val);\n};\nIntType.prototype._match = function (tap1, tap2) {\n  return tap1.matchInt(tap2);\n};\nIntType.prototype.typeName = 'int';\nIntType.prototype.random = function () {\n  return RANDOM.nextInt(1000) | 0;\n};\n\n/**\n * Longs.\n *\n * We can't capture all the range unfortunately since JavaScript represents all\n * numbers internally as `double`s, so the default implementation plays safe\n * and throws rather than potentially silently change the data. See `__with` or\n * `AbstractLongType` below for a way to implement a custom long type.\n */\nfunction LongType() {\n  PrimitiveType.call(this);\n}\nutil.inherits(LongType, PrimitiveType);\nLongType.prototype._check = function (val, flags, hook) {\n  var b = typeof val == 'number' && val % 1 === 0 && isSafeLong(val);\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\nLongType.prototype._read = function (tap) {\n  var n = tap.readLong();\n  if (!isSafeLong(n)) {\n    throw new Error('potential precision loss');\n  }\n  return n;\n};\nLongType.prototype._skip = function (tap) {\n  tap.skipLong();\n};\nLongType.prototype._write = function (tap, val) {\n  if (typeof val != 'number' || val % 1 || !isSafeLong(val)) {\n    throwInvalidError(val, this);\n  }\n  tap.writeLong(val);\n};\nLongType.prototype._match = function (tap1, tap2) {\n  return tap1.matchLong(tap2);\n};\nLongType.prototype._update = function (resolver, type) {\n  switch (type.typeName) {\n    case 'int':\n      resolver._read = type._read;\n      break;\n    case 'abstract:long':\n    case 'long':\n      resolver._read = this._read;\n    // In case `type` is an `AbstractLongType`.\n  }\n};\n\nLongType.prototype.typeName = 'long';\nLongType.prototype.random = function () {\n  return RANDOM.nextInt();\n};\nLongType.__with = function (methods, noUnpack) {\n  methods = methods || {}; // Will give a more helpful error message.\n  // We map some of the methods to a different name to be able to intercept\n  // their input and output (otherwise we wouldn't be able to perform any\n  // unpacking logic, and the type wouldn't work when nested).\n  var mapping = {\n    toBuffer: '_toBuffer',\n    fromBuffer: '_fromBuffer',\n    fromJSON: '_fromJSON',\n    toJSON: '_toJSON',\n    isValid: '_isValid',\n    compare: 'compare'\n  };\n  var type = new AbstractLongType(noUnpack);\n  Object.keys(mapping).forEach(function (name) {\n    if (methods[name] === undefined) {\n      throw new Error(f('missing method implementation: %s', name));\n    }\n    type[mapping[name]] = methods[name];\n  });\n  return Object.freeze(type);\n};\n\n/** Floats. */\nfunction FloatType() {\n  PrimitiveType.call(this);\n}\nutil.inherits(FloatType, PrimitiveType);\nFloatType.prototype._check = function (val, flags, hook) {\n  var b = typeof val == 'number';\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\nFloatType.prototype._read = function (tap) {\n  return tap.readFloat();\n};\nFloatType.prototype._skip = function (tap) {\n  tap.skipFloat();\n};\nFloatType.prototype._write = function (tap, val) {\n  if (typeof val != 'number') {\n    throwInvalidError(val, this);\n  }\n  tap.writeFloat(val);\n};\nFloatType.prototype._match = function (tap1, tap2) {\n  return tap1.matchFloat(tap2);\n};\nFloatType.prototype._update = function (resolver, type) {\n  switch (type.typeName) {\n    case 'float':\n    case 'int':\n      resolver._read = type._read;\n      break;\n    case 'abstract:long':\n    case 'long':\n      // No need to worry about precision loss here since we're always rounding\n      // to float anyway.\n      resolver._read = function (tap) {\n        return tap.readLong();\n      };\n  }\n};\nFloatType.prototype.typeName = 'float';\nFloatType.prototype.random = function () {\n  return RANDOM.nextFloat(1e3);\n};\n\n/** Doubles. */\nfunction DoubleType() {\n  PrimitiveType.call(this);\n}\nutil.inherits(DoubleType, PrimitiveType);\nDoubleType.prototype._check = function (val, flags, hook) {\n  var b = typeof val == 'number';\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\nDoubleType.prototype._read = function (tap) {\n  return tap.readDouble();\n};\nDoubleType.prototype._skip = function (tap) {\n  tap.skipDouble();\n};\nDoubleType.prototype._write = function (tap, val) {\n  if (typeof val != 'number') {\n    throwInvalidError(val, this);\n  }\n  tap.writeDouble(val);\n};\nDoubleType.prototype._match = function (tap1, tap2) {\n  return tap1.matchDouble(tap2);\n};\nDoubleType.prototype._update = function (resolver, type) {\n  switch (type.typeName) {\n    case 'double':\n    case 'float':\n    case 'int':\n      resolver._read = type._read;\n      break;\n    case 'abstract:long':\n    case 'long':\n      // Similar to inside `FloatType`, no need to worry about precision loss\n      // here since we're always rounding to double anyway.\n      resolver._read = function (tap) {\n        return tap.readLong();\n      };\n  }\n};\nDoubleType.prototype.typeName = 'double';\nDoubleType.prototype.random = function () {\n  return RANDOM.nextFloat();\n};\n\n/** Strings. */\nfunction StringType() {\n  PrimitiveType.call(this);\n}\nutil.inherits(StringType, PrimitiveType);\nStringType.prototype._check = function (val, flags, hook) {\n  var b = typeof val == 'string';\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\nStringType.prototype._read = function (tap) {\n  return tap.readString();\n};\nStringType.prototype._skip = function (tap) {\n  tap.skipString();\n};\nStringType.prototype._write = function (tap, val) {\n  if (typeof val != 'string') {\n    throwInvalidError(val, this);\n  }\n  tap.writeString(val);\n};\nStringType.prototype._match = function (tap1, tap2) {\n  return tap1.matchString(tap2);\n};\nStringType.prototype._update = function (resolver, type) {\n  switch (type.typeName) {\n    case 'bytes':\n    case 'string':\n      resolver._read = this._read;\n  }\n};\nStringType.prototype.typeName = 'string';\nStringType.prototype.random = function () {\n  return RANDOM.nextString(RANDOM.nextInt(32));\n};\n\n/**\n * Bytes.\n *\n * These are represented in memory as `Buffer`s rather than binary-encoded\n * strings. This is more efficient (when decoding/encoding from bytes, the\n * common use-case), idiomatic, and convenient.\n *\n * Note the coercion in `_copy`.\n */\nfunction BytesType() {\n  PrimitiveType.call(this);\n}\nutil.inherits(BytesType, PrimitiveType);\nBytesType.prototype._check = function (val, flags, hook) {\n  var b = Buffer.isBuffer(val);\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\nBytesType.prototype._read = function (tap) {\n  return tap.readBytes();\n};\nBytesType.prototype._skip = function (tap) {\n  tap.skipBytes();\n};\nBytesType.prototype._write = function (tap, val) {\n  if (!Buffer.isBuffer(val)) {\n    throwInvalidError(val, this);\n  }\n  tap.writeBytes(val);\n};\nBytesType.prototype._match = function (tap1, tap2) {\n  return tap1.matchBytes(tap2);\n};\nBytesType.prototype._update = StringType.prototype._update;\nBytesType.prototype._copy = function (obj, opts) {\n  var buf;\n  switch ((opts && opts.coerce) | 0) {\n    case 3:\n      // Coerce buffers to strings.\n      this._check(obj, undefined, throwInvalidError);\n      return obj.toString('binary');\n    case 2:\n      // Coerce strings to buffers.\n      if (typeof obj != 'string') {\n        throw new Error(f('cannot coerce to buffer: %j', obj));\n      }\n      buf = utils.bufferFrom(obj, 'binary');\n      this._check(buf, undefined, throwInvalidError);\n      return buf;\n    case 1:\n      // Coerce buffer JSON representation to buffers.\n      if (!isJsonBuffer(obj)) {\n        throw new Error(f('cannot coerce to buffer: %j', obj));\n      }\n      buf = utils.bufferFrom(obj.data);\n      this._check(buf, undefined, throwInvalidError);\n      return buf;\n    default:\n      // Copy buffer.\n      this._check(obj, undefined, throwInvalidError);\n      return utils.bufferFrom(obj);\n  }\n};\nBytesType.prototype.compare = Buffer.compare;\nBytesType.prototype.typeName = 'bytes';\nBytesType.prototype.random = function () {\n  return RANDOM.nextBuffer(RANDOM.nextInt(32));\n};\n\n/** Base \"abstract\" Avro union type. */\nfunction UnionType(schema, opts) {\n  Type.call(this);\n  if (!Array.isArray(schema)) {\n    throw new Error(f('non-array union schema: %j', schema));\n  }\n  if (!schema.length) {\n    throw new Error('empty union');\n  }\n  this.types = Object.freeze(schema.map(function (obj) {\n    return Type.forSchema(obj, opts);\n  }));\n  this._branchIndices = {};\n  this.types.forEach(function (type, i) {\n    if (Type.isType(type, 'union')) {\n      throw new Error('unions cannot be directly nested');\n    }\n    var branch = type.branchName;\n    if (this._branchIndices[branch] !== undefined) {\n      throw new Error(f('duplicate union branch name: %j', branch));\n    }\n    this._branchIndices[branch] = i;\n  }, this);\n}\nutil.inherits(UnionType, Type);\nUnionType.prototype._branchConstructor = function () {\n  throw new Error('unions cannot be directly wrapped');\n};\nUnionType.prototype._skip = function (tap) {\n  this.types[tap.readLong()]._skip(tap);\n};\nUnionType.prototype._match = function (tap1, tap2) {\n  var n1 = tap1.readLong();\n  var n2 = tap2.readLong();\n  if (n1 === n2) {\n    return this.types[n1]._match(tap1, tap2);\n  } else {\n    return n1 < n2 ? -1 : 1;\n  }\n};\nUnionType.prototype._deref = function (schema, opts) {\n  return this.types.map(function (t) {\n    return t._attrs(opts);\n  });\n};\nUnionType.prototype.getTypes = function () {\n  return this.types;\n};\n\n/**\n * \"Natural\" union type.\n *\n * This representation doesn't require a wrapping object and is therefore\n * simpler and generally closer to what users expect. However it cannot be used\n * to represent all Avro unions since some lead to ambiguities (e.g. if two\n * number types are in the union).\n *\n * Currently, this union supports at most one type in each of the categories\n * below:\n *\n * + `null`\n * + `boolean`\n * + `int`, `long`, `float`, `double`\n * + `string`, `enum`\n * + `bytes`, `fixed`\n * + `array`\n * + `map`, `record`\n */\nfunction UnwrappedUnionType(schema, opts) {\n  UnionType.call(this, schema, opts);\n  this._dynamicBranches = null;\n  this._bucketIndices = {};\n  this.types.forEach(function (type, index) {\n    if (Type.isType(type, 'abstract', 'logical')) {\n      if (!this._dynamicBranches) {\n        this._dynamicBranches = [];\n      }\n      this._dynamicBranches.push({\n        index: index,\n        type: type\n      });\n    } else {\n      var bucket = getTypeBucket(type);\n      if (this._bucketIndices[bucket] !== undefined) {\n        throw new Error(f('ambiguous unwrapped union: %j', this));\n      }\n      this._bucketIndices[bucket] = index;\n    }\n  }, this);\n  Object.freeze(this);\n}\nutil.inherits(UnwrappedUnionType, UnionType);\nUnwrappedUnionType.prototype._getIndex = function (val) {\n  var index = this._bucketIndices[getValueBucket(val)];\n  if (this._dynamicBranches) {\n    // Slower path, we must run the value through all branches.\n    index = this._getBranchIndex(val, index);\n  }\n  return index;\n};\nUnwrappedUnionType.prototype._getBranchIndex = function (any, index) {\n  var logicalBranches = this._dynamicBranches;\n  var i, l, branch;\n  for (i = 0, l = logicalBranches.length; i < l; i++) {\n    branch = logicalBranches[i];\n    if (branch.type._check(any)) {\n      if (index === undefined) {\n        index = branch.index;\n      } else {\n        // More than one branch matches the value so we aren't guaranteed to\n        // infer the correct type. We throw rather than corrupt data. This can\n        // be fixed by \"tightening\" the logical types.\n        throw new Error('ambiguous conversion');\n      }\n    }\n  }\n  return index;\n};\nUnwrappedUnionType.prototype._check = function (val, flags, hook, path) {\n  var index = this._getIndex(val);\n  var b = index !== undefined;\n  if (b) {\n    return this.types[index]._check(val, flags, hook, path);\n  }\n  if (hook) {\n    hook(val, this);\n  }\n  return b;\n};\nUnwrappedUnionType.prototype._read = function (tap) {\n  var index = tap.readLong();\n  var branchType = this.types[index];\n  if (branchType) {\n    return branchType._read(tap);\n  } else {\n    throw new Error(f('invalid union index: %s', index));\n  }\n};\nUnwrappedUnionType.prototype._write = function (tap, val) {\n  var index = this._getIndex(val);\n  if (index === undefined) {\n    throwInvalidError(val, this);\n  }\n  tap.writeLong(index);\n  if (val !== null) {\n    this.types[index]._write(tap, val);\n  }\n};\nUnwrappedUnionType.prototype._update = function (resolver, type, opts) {\n  // jshint -W083\n  // (The loop exits after the first function is created.)\n  var i, l, typeResolver;\n  for (i = 0, l = this.types.length; i < l; i++) {\n    try {\n      typeResolver = this.types[i].createResolver(type, opts);\n    } catch (err) {\n      continue;\n    }\n    resolver._read = function (tap) {\n      return typeResolver._read(tap);\n    };\n    return;\n  }\n};\nUnwrappedUnionType.prototype._copy = function (val, opts) {\n  var coerce = opts && opts.coerce | 0;\n  var wrap = opts && opts.wrap | 0;\n  var index;\n  if (wrap === 2) {\n    // We are parsing a default, so always use the first branch's type.\n    index = 0;\n  } else {\n    switch (coerce) {\n      case 1:\n        // Using the `coerceBuffers` option can cause corruption and erroneous\n        // failures with unwrapped unions (in rare cases when the union also\n        // contains a record which matches a buffer's JSON representation).\n        if (isJsonBuffer(val) && this._bucketIndices.buffer !== undefined) {\n          index = this._bucketIndices.buffer;\n        } else {\n          index = this._getIndex(val);\n        }\n        break;\n      case 2:\n        // Decoding from JSON, we must unwrap the value.\n        if (val === null) {\n          index = this._bucketIndices['null'];\n        } else if (typeof val === 'object') {\n          var keys = Object.keys(val);\n          if (keys.length === 1) {\n            index = this._branchIndices[keys[0]];\n            val = val[keys[0]];\n          }\n        }\n        break;\n      default:\n        index = this._getIndex(val);\n    }\n    if (index === undefined) {\n      throwInvalidError(val, this);\n    }\n  }\n  var type = this.types[index];\n  if (val === null || wrap === 3) {\n    return type._copy(val, opts);\n  } else {\n    switch (coerce) {\n      case 3:\n        // Encoding to JSON, we wrap the value.\n        var obj = {};\n        obj[type.branchName] = type._copy(val, opts);\n        return obj;\n      default:\n        return type._copy(val, opts);\n    }\n  }\n};\nUnwrappedUnionType.prototype.compare = function (val1, val2) {\n  var index1 = this._getIndex(val1);\n  var index2 = this._getIndex(val2);\n  if (index1 === undefined) {\n    throwInvalidError(val1, this);\n  } else if (index2 === undefined) {\n    throwInvalidError(val2, this);\n  } else if (index1 === index2) {\n    return this.types[index1].compare(val1, val2);\n  } else {\n    return utils.compare(index1, index2);\n  }\n};\nUnwrappedUnionType.prototype.typeName = 'union:unwrapped';\nUnwrappedUnionType.prototype.random = function () {\n  var index = RANDOM.nextInt(this.types.length);\n  return this.types[index].random();\n};\n\n/**\n * Compatible union type.\n *\n * Values of this type are represented in memory similarly to their JSON\n * representation (i.e. inside an object with single key the name of the\n * contained type).\n *\n * This is not ideal, but is the most efficient way to unambiguously support\n * all unions. Here are a few reasons why the wrapping object is necessary:\n *\n * + Unions with multiple number types would have undefined behavior, unless\n *   numbers are wrapped (either everywhere, leading to large performance and\n *   convenience costs; or only when necessary inside unions, making it hard to\n *   understand when numbers are wrapped or not).\n * + Fixed types would have to be wrapped to be distinguished from bytes.\n * + Using record's constructor names would work (after a slight change to use\n *   the fully qualified name), but would mean that generic objects could no\n *   longer be valid records (making it inconvenient to do simple things like\n *   creating new records).\n */\nfunction WrappedUnionType(schema, opts) {\n  UnionType.call(this, schema, opts);\n  Object.freeze(this);\n}\nutil.inherits(WrappedUnionType, UnionType);\nWrappedUnionType.prototype._check = function (val, flags, hook, path) {\n  var b = false;\n  if (val === null) {\n    // Shortcut type lookup in this case.\n    b = this._branchIndices['null'] !== undefined;\n  } else if (typeof val == 'object') {\n    var keys = Object.keys(val);\n    if (keys.length === 1) {\n      // We require a single key here to ensure that writes are correct and\n      // efficient as soon as a record passes this check.\n      var name = keys[0];\n      var index = this._branchIndices[name];\n      if (index !== undefined) {\n        if (hook) {\n          // Slow path.\n          path.push(name);\n          b = this.types[index]._check(val[name], flags, hook, path);\n          path.pop();\n          return b;\n        } else {\n          return this.types[index]._check(val[name], flags);\n        }\n      }\n    }\n  }\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\nWrappedUnionType.prototype._read = function (tap) {\n  var type = this.types[tap.readLong()];\n  if (!type) {\n    throw new Error(f('invalid union index'));\n  }\n  var Branch = type._branchConstructor;\n  if (Branch === null) {\n    return null;\n  } else {\n    return new Branch(type._read(tap));\n  }\n};\nWrappedUnionType.prototype._write = function (tap, val) {\n  var index, keys, name;\n  if (val === null) {\n    index = this._branchIndices['null'];\n    if (index === undefined) {\n      throwInvalidError(val, this);\n    }\n    tap.writeLong(index);\n  } else {\n    keys = Object.keys(val);\n    if (keys.length === 1) {\n      name = keys[0];\n      index = this._branchIndices[name];\n    }\n    if (index === undefined) {\n      throwInvalidError(val, this);\n    }\n    tap.writeLong(index);\n    this.types[index]._write(tap, val[name]);\n  }\n};\nWrappedUnionType.prototype._update = function (resolver, type, opts) {\n  // jshint -W083\n  // (The loop exits after the first function is created.)\n  var i, l, typeResolver, Branch;\n  for (i = 0, l = this.types.length; i < l; i++) {\n    try {\n      typeResolver = this.types[i].createResolver(type, opts);\n    } catch (err) {\n      continue;\n    }\n    Branch = this.types[i]._branchConstructor;\n    if (Branch) {\n      resolver._read = function (tap) {\n        return new Branch(typeResolver._read(tap));\n      };\n    } else {\n      resolver._read = function () {\n        return null;\n      };\n    }\n    return;\n  }\n};\nWrappedUnionType.prototype._copy = function (val, opts) {\n  var wrap = opts && opts.wrap | 0;\n  if (wrap === 2) {\n    var firstType = this.types[0];\n    // Promote into first type (used for schema defaults).\n    if (val === null && firstType.typeName === 'null') {\n      return null;\n    }\n    return new firstType._branchConstructor(firstType._copy(val, opts));\n  }\n  if (val === null && this._branchIndices['null'] !== undefined) {\n    return null;\n  }\n  var i, l, obj;\n  if (typeof val == 'object') {\n    var keys = Object.keys(val);\n    if (keys.length === 1) {\n      var name = keys[0];\n      i = this._branchIndices[name];\n      if (i === undefined && opts.qualifyNames) {\n        // We are a bit more flexible than in `_check` here since we have\n        // to deal with other serializers being less strict, so we fall\n        // back to looking up unqualified names.\n        var j, type;\n        for (j = 0, l = this.types.length; j < l; j++) {\n          type = this.types[j];\n          if (type.name && name === unqualify(type.name)) {\n            i = j;\n            break;\n          }\n        }\n      }\n      if (i !== undefined) {\n        obj = this.types[i]._copy(val[name], opts);\n      }\n    }\n  }\n  if (wrap === 1 && obj === undefined) {\n    // Try promoting into first match (convenience, slow).\n    i = 0;\n    l = this.types.length;\n    while (i < l && obj === undefined) {\n      try {\n        obj = this.types[i]._copy(val, opts);\n      } catch (err) {\n        i++;\n      }\n    }\n  }\n  if (obj !== undefined) {\n    return wrap === 3 ? obj : new this.types[i]._branchConstructor(obj);\n  }\n  throwInvalidError(val, this);\n};\nWrappedUnionType.prototype.compare = function (val1, val2) {\n  var name1 = val1 === null ? 'null' : Object.keys(val1)[0];\n  var name2 = val2 === null ? 'null' : Object.keys(val2)[0];\n  var index = this._branchIndices[name1];\n  if (name1 === name2) {\n    return name1 === 'null' ? 0 : this.types[index].compare(val1[name1], val2[name1]);\n  } else {\n    return utils.compare(index, this._branchIndices[name2]);\n  }\n};\nWrappedUnionType.prototype.typeName = 'union:wrapped';\nWrappedUnionType.prototype.random = function () {\n  var index = RANDOM.nextInt(this.types.length);\n  var type = this.types[index];\n  var Branch = type._branchConstructor;\n  if (!Branch) {\n    return null;\n  }\n  return new Branch(type.random());\n};\n\n/**\n * Avro enum type.\n *\n * Represented as strings (with allowed values from the set of symbols). Using\n * integers would be a reasonable option, but the performance boost is arguably\n * offset by the legibility cost and the extra deviation from the JSON encoding\n * convention.\n *\n * An integer representation can still be used (e.g. for compatibility with\n * TypeScript `enum`s) by overriding the `EnumType` with a `LongType` (e.g. via\n * `parse`'s registry).\n */\nfunction EnumType(schema, opts) {\n  Type.call(this, schema, opts);\n  if (!Array.isArray(schema.symbols) || !schema.symbols.length) {\n    throw new Error(f('invalid enum symbols: %j', schema.symbols));\n  }\n  this.symbols = Object.freeze(schema.symbols.slice());\n  this._indices = {};\n  this.symbols.forEach(function (symbol, i) {\n    if (!isValidName(symbol)) {\n      throw new Error(f('invalid %s symbol: %j', this, symbol));\n    }\n    if (this._indices[symbol] !== undefined) {\n      throw new Error(f('duplicate %s symbol: %j', this, symbol));\n    }\n    this._indices[symbol] = i;\n  }, this);\n  this._branchConstructor = this._createBranchConstructor();\n  Object.freeze(this);\n}\nutil.inherits(EnumType, Type);\nEnumType.prototype._check = function (val, flags, hook) {\n  var b = this._indices[val] !== undefined;\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\nEnumType.prototype._read = function (tap) {\n  var index = tap.readLong();\n  var symbol = this.symbols[index];\n  if (symbol === undefined) {\n    throw new Error(f('invalid %s enum index: %s', this.name, index));\n  }\n  return symbol;\n};\nEnumType.prototype._skip = function (tap) {\n  tap.skipLong();\n};\nEnumType.prototype._write = function (tap, val) {\n  var index = this._indices[val];\n  if (index === undefined) {\n    throwInvalidError(val, this);\n  }\n  tap.writeLong(index);\n};\nEnumType.prototype._match = function (tap1, tap2) {\n  return tap1.matchLong(tap2);\n};\nEnumType.prototype.compare = function (val1, val2) {\n  return utils.compare(this._indices[val1], this._indices[val2]);\n};\nEnumType.prototype._update = function (resolver, type) {\n  var symbols = this.symbols;\n  if (type.typeName === 'enum' && (!type.name || ~getAliases(this).indexOf(type.name)) && type.symbols.every(function (s) {\n    return ~symbols.indexOf(s);\n  })) {\n    resolver.symbols = type.symbols;\n    resolver._read = type._read;\n  }\n};\nEnumType.prototype._copy = function (val) {\n  this._check(val, undefined, throwInvalidError);\n  return val;\n};\nEnumType.prototype._deref = function (schema) {\n  schema.symbols = this.symbols;\n};\nEnumType.prototype.getSymbols = function () {\n  return this.symbols;\n};\nEnumType.prototype.typeName = 'enum';\nEnumType.prototype.random = function () {\n  return RANDOM.choice(this.symbols);\n};\n\n/** Avro fixed type. Represented simply as a `Buffer`. */\nfunction FixedType(schema, opts) {\n  Type.call(this, schema, opts);\n  if (schema.size !== (schema.size | 0) || schema.size < 1) {\n    throw new Error(f('invalid %s size', this.branchName));\n  }\n  this.size = schema.size | 0;\n  this._branchConstructor = this._createBranchConstructor();\n  Object.freeze(this);\n}\nutil.inherits(FixedType, Type);\nFixedType.prototype._check = function (val, flags, hook) {\n  var b = Buffer.isBuffer(val) && val.length === this.size;\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\nFixedType.prototype._read = function (tap) {\n  return tap.readFixed(this.size);\n};\nFixedType.prototype._skip = function (tap) {\n  tap.skipFixed(this.size);\n};\nFixedType.prototype._write = function (tap, val) {\n  if (!Buffer.isBuffer(val) || val.length !== this.size) {\n    throwInvalidError(val, this);\n  }\n  tap.writeFixed(val, this.size);\n};\nFixedType.prototype._match = function (tap1, tap2) {\n  return tap1.matchFixed(tap2, this.size);\n};\nFixedType.prototype.compare = Buffer.compare;\nFixedType.prototype._update = function (resolver, type) {\n  if (type.typeName === 'fixed' && this.size === type.size && (!type.name || ~getAliases(this).indexOf(type.name))) {\n    resolver.size = this.size;\n    resolver._read = this._read;\n  }\n};\nFixedType.prototype._copy = BytesType.prototype._copy;\nFixedType.prototype._deref = function (schema) {\n  schema.size = this.size;\n};\nFixedType.prototype.getSize = function () {\n  return this.size;\n};\nFixedType.prototype.typeName = 'fixed';\nFixedType.prototype.random = function () {\n  return RANDOM.nextBuffer(this.size);\n};\n\n/** Avro map. Represented as vanilla objects. */\nfunction MapType(schema, opts) {\n  Type.call(this);\n  if (!schema.values) {\n    throw new Error(f('missing map values: %j', schema));\n  }\n  this.valuesType = Type.forSchema(schema.values, opts);\n  this._branchConstructor = this._createBranchConstructor();\n  Object.freeze(this);\n}\nutil.inherits(MapType, Type);\nMapType.prototype._check = function (val, flags, hook, path) {\n  if (!val || typeof val != 'object' || Array.isArray(val)) {\n    if (hook) {\n      hook(val, this);\n    }\n    return false;\n  }\n  var keys = Object.keys(val);\n  var b = true;\n  var i, l, j, key;\n  if (hook) {\n    // Slow path.\n    j = path.length;\n    path.push('');\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = path[j] = keys[i];\n      if (!this.valuesType._check(val[key], flags, hook, path)) {\n        b = false;\n      }\n    }\n    path.pop();\n  } else {\n    for (i = 0, l = keys.length; i < l; i++) {\n      if (!this.valuesType._check(val[keys[i]], flags)) {\n        return false;\n      }\n    }\n  }\n  return b;\n};\nMapType.prototype._read = function (tap) {\n  var values = this.valuesType;\n  var val = {};\n  var n;\n  while (n = readArraySize(tap)) {\n    while (n--) {\n      var key = tap.readString();\n      val[key] = values._read(tap);\n    }\n  }\n  return val;\n};\nMapType.prototype._skip = function (tap) {\n  var values = this.valuesType;\n  var len, n;\n  while (n = tap.readLong()) {\n    if (n < 0) {\n      len = tap.readLong();\n      tap.pos += len;\n    } else {\n      while (n--) {\n        tap.skipString();\n        values._skip(tap);\n      }\n    }\n  }\n};\nMapType.prototype._write = function (tap, val) {\n  if (!val || typeof val != 'object' || Array.isArray(val)) {\n    throwInvalidError(val, this);\n  }\n  var values = this.valuesType;\n  var keys = Object.keys(val);\n  var n = keys.length;\n  var i, key;\n  if (n) {\n    tap.writeLong(n);\n    for (i = 0; i < n; i++) {\n      key = keys[i];\n      tap.writeString(key);\n      values._write(tap, val[key]);\n    }\n  }\n  tap.writeLong(0);\n};\nMapType.prototype._match = function () {\n  throw new Error('maps cannot be compared');\n};\nMapType.prototype._update = function (rsv, type, opts) {\n  if (type.typeName === 'map') {\n    rsv.valuesType = this.valuesType.createResolver(type.valuesType, opts);\n    rsv._read = this._read;\n  }\n};\nMapType.prototype._copy = function (val, opts) {\n  if (val && typeof val == 'object' && !Array.isArray(val)) {\n    var values = this.valuesType;\n    var keys = Object.keys(val);\n    var i, l, key;\n    var copy = {};\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = keys[i];\n      copy[key] = values._copy(val[key], opts);\n    }\n    return copy;\n  }\n  throwInvalidError(val, this);\n};\nMapType.prototype.compare = MapType.prototype._match;\nMapType.prototype.typeName = 'map';\nMapType.prototype.getValuesType = function () {\n  return this.valuesType;\n};\nMapType.prototype.random = function () {\n  var val = {};\n  var i, l;\n  for (i = 0, l = RANDOM.nextInt(10); i < l; i++) {\n    val[RANDOM.nextString(RANDOM.nextInt(20))] = this.valuesType.random();\n  }\n  return val;\n};\nMapType.prototype._deref = function (schema, opts) {\n  schema.values = this.valuesType._attrs(opts);\n};\n\n/** Avro array. Represented as vanilla arrays. */\nfunction ArrayType(schema, opts) {\n  Type.call(this);\n  if (!schema.items) {\n    throw new Error(f('missing array items: %j', schema));\n  }\n  this.itemsType = Type.forSchema(schema.items, opts);\n  this._branchConstructor = this._createBranchConstructor();\n  Object.freeze(this);\n}\nutil.inherits(ArrayType, Type);\nArrayType.prototype._check = function (val, flags, hook, path) {\n  if (!Array.isArray(val)) {\n    if (hook) {\n      hook(val, this);\n    }\n    return false;\n  }\n  var b = true;\n  var i, l, j;\n  if (hook) {\n    // Slow path.\n    j = path.length;\n    path.push('');\n    for (i = 0, l = val.length; i < l; i++) {\n      path[j] = '' + i;\n      if (!this.itemsType._check(val[i], flags, hook, path)) {\n        b = false;\n      }\n    }\n    path.pop();\n  } else {\n    for (i = 0, l = val.length; i < l; i++) {\n      if (!this.itemsType._check(val[i], flags)) {\n        return false;\n      }\n    }\n  }\n  return b;\n};\nArrayType.prototype._read = function (tap) {\n  var items = this.itemsType;\n  var val = [];\n  var n;\n  while (n = tap.readLong()) {\n    if (n < 0) {\n      n = -n;\n      tap.skipLong(); // Skip size.\n    }\n\n    while (n--) {\n      val.push(items._read(tap));\n    }\n  }\n  return val;\n};\nArrayType.prototype._skip = function (tap) {\n  var len, n;\n  while (n = tap.readLong()) {\n    if (n < 0) {\n      len = tap.readLong();\n      tap.pos += len;\n    } else {\n      while (n--) {\n        this.itemsType._skip(tap);\n      }\n    }\n  }\n};\nArrayType.prototype._write = function (tap, val) {\n  if (!Array.isArray(val)) {\n    throwInvalidError(val, this);\n  }\n  var n = val.length;\n  var i;\n  if (n) {\n    tap.writeLong(n);\n    for (i = 0; i < n; i++) {\n      this.itemsType._write(tap, val[i]);\n    }\n  }\n  tap.writeLong(0);\n};\nArrayType.prototype._match = function (tap1, tap2) {\n  var n1 = tap1.readLong();\n  var n2 = tap2.readLong();\n  var f;\n  while (n1 && n2) {\n    f = this.itemsType._match(tap1, tap2);\n    if (f) {\n      return f;\n    }\n    if (! --n1) {\n      n1 = readArraySize(tap1);\n    }\n    if (! --n2) {\n      n2 = readArraySize(tap2);\n    }\n  }\n  return utils.compare(n1, n2);\n};\nArrayType.prototype._update = function (resolver, type, opts) {\n  if (type.typeName === 'array') {\n    resolver.itemsType = this.itemsType.createResolver(type.itemsType, opts);\n    resolver._read = this._read;\n  }\n};\nArrayType.prototype._copy = function (val, opts) {\n  if (!Array.isArray(val)) {\n    throwInvalidError(val, this);\n  }\n  var items = new Array(val.length);\n  var i, l;\n  for (i = 0, l = val.length; i < l; i++) {\n    items[i] = this.itemsType._copy(val[i], opts);\n  }\n  return items;\n};\nArrayType.prototype._deref = function (schema, opts) {\n  schema.items = this.itemsType._attrs(opts);\n};\nArrayType.prototype.compare = function (val1, val2) {\n  var n1 = val1.length;\n  var n2 = val2.length;\n  var i, l, f;\n  for (i = 0, l = Math.min(n1, n2); i < l; i++) {\n    if (f = this.itemsType.compare(val1[i], val2[i])) {\n      return f;\n    }\n  }\n  return utils.compare(n1, n2);\n};\nArrayType.prototype.getItemsType = function () {\n  return this.itemsType;\n};\nArrayType.prototype.typeName = 'array';\nArrayType.prototype.random = function () {\n  var arr = [];\n  var i, l;\n  for (i = 0, l = RANDOM.nextInt(10); i < l; i++) {\n    arr.push(this.itemsType.random());\n  }\n  return arr;\n};\n\n/**\n * Avro record.\n *\n * Values are represented as instances of a programmatically generated\n * constructor (similar to a \"specific record\"), available via the\n * `getRecordConstructor` method. This \"specific record class\" gives\n * significant speedups over using generics objects.\n *\n * Note that vanilla objects are still accepted as valid as long as their\n * fields match (this makes it much more convenient to do simple things like\n * update nested records).\n *\n * This type is also used for errors (similar, except for the extra `Error`\n * constructor call) and for messages (see comment below).\n */\nfunction RecordType(schema, opts) {\n  // Force creation of the options object in case we need to register this\n  // record's name.\n  opts = opts || {};\n\n  // Save the namespace to restore it as we leave this record's scope.\n  var namespace = opts.namespace;\n  if (schema.namespace !== undefined) {\n    opts.namespace = schema.namespace;\n  } else if (schema.name) {\n    // Fully qualified names' namespaces are used when no explicit namespace\n    // attribute was specified.\n    var match = /^(.*)\\.[^.]+$/.exec(schema.name);\n    if (match) {\n      opts.namespace = match[1];\n    }\n  }\n  Type.call(this, schema, opts);\n  if (!Array.isArray(schema.fields)) {\n    throw new Error(f('non-array record fields: %j', schema.fields));\n  }\n  if (utils.hasDuplicates(schema.fields, function (f) {\n    return f.name;\n  })) {\n    throw new Error(f('duplicate field name: %j', schema.fields));\n  }\n  this._fieldsByName = {};\n  this.fields = Object.freeze(schema.fields.map(function (f) {\n    var field = new Field(f, opts);\n    this._fieldsByName[field.name] = field;\n    return field;\n  }, this));\n  this._branchConstructor = this._createBranchConstructor();\n  this._isError = schema.type === 'error';\n  this.recordConstructor = this._createConstructor(opts.errorStackTraces);\n  this._read = this._createReader();\n  this._skip = this._createSkipper();\n  this._write = this._createWriter();\n  this._check = this._createChecker();\n  opts.namespace = namespace;\n  Object.freeze(this);\n}\nutil.inherits(RecordType, Type);\nRecordType.prototype._getConstructorName = function () {\n  return this.name ? unqualify(this.name) : this._isError ? 'Error$' : 'Record$';\n};\nRecordType.prototype._createConstructor = function (errorStackTraces) {\n  // jshint -W054\n  var ds = {}; // Defaults.\n  var i, l, field, name, defaultValue, hasDefault, stackField;\n  for (i = 0, l = this.fields.length; i < l; i++) {\n    field = this.fields[i];\n    defaultValue = field.defaultValue;\n    hasDefault = defaultValue() !== undefined;\n    name = field.name;\n    if (errorStackTraces && this._isError && name === 'stack' && Type.isType(field.type, 'string') && !hasDefault) {\n      // We keep track of whether we've encountered a valid stack field (in\n      // particular, without a default) to populate a stack trace below.\n      stackField = field;\n    }\n    if (hasDefault) {\n      ds[i] = defaultValue;\n    }\n  }\n  var self = this;\n  function ConstructorFunction(outerArgs) {\n    const constructorName = self._getConstructorName();\n    var innerFunction = {\n      [constructorName]: function (...innerArgs) {\n        for (var i = 0, l = self.fields.length; i < l; i++) {\n          let f = self.fields[i];\n          if (f.defaultValue() === undefined) {\n            this[f.name] = innerArgs[i];\n          } else {\n            if (innerArgs[i] === undefined) {\n              this[f.name] = outerArgs[i]();\n            } else {\n              this[f.name] = innerArgs[i];\n            }\n          }\n        }\n        if (stackField) {\n          if (this.stack === undefined) {\n            if (typeof Error.captureStackTrace === 'function') {\n              Error.captureStackTrace(this, this.constructor);\n            } else {\n              this.stack = Error().stack;\n            }\n          }\n        }\n      }\n    }[constructorName];\n    return innerFunction;\n  }\n  var Record = ConstructorFunction(ds);\n  Record.getType = function () {\n    return self;\n  };\n  Record.type = self;\n  if (this._isError) {\n    util.inherits(Record, Error);\n    Record.prototype.name = this._getConstructorName();\n  }\n  Record.prototype.clone = function (o) {\n    return self.clone(this, o);\n  };\n  Record.prototype.compare = function (v) {\n    return self.compare(this, v);\n  };\n  Record.prototype.isValid = function (o) {\n    return self.isValid(this, o);\n  };\n  Record.prototype.toBuffer = function () {\n    return self.toBuffer(this);\n  };\n  Record.prototype.toString = function () {\n    return self.toString(this);\n  };\n  Record.prototype.wrap = function () {\n    return self.wrap(this);\n  };\n  Record.prototype.wrapped = Record.prototype.wrap; // Deprecated.\n  return Record;\n};\nRecordType.prototype._createChecker = function () {\n  // jshint -W054\n  const values = [];\n  this.fields.forEach(field => {\n    values.push(field.type);\n  });\n  var self = this;\n  function ConstructorFunction(outerArgs) {\n    var constructorName = self._getConstructorName();\n    var innerFunction = {\n      [constructorName]: function (v, f, h, p) {\n        if (v === null || typeof v !== 'object' || f && !this._checkFields(v)) {\n          if (h) {\n            h(v, this);\n          }\n          return false;\n        }\n        const vArray = [];\n        if (!self.fields.length) {\n          return true;\n        } else {\n          for (var i = 0, l = self.fields.length; i < l; i++) {\n            let f = self.fields[i];\n            if (f.defaultValue() !== undefined) {\n              vArray.push(v[f.name]);\n            }\n          }\n        }\n        if (h) {\n          var b = 1;\n          var j = p.length;\n          p.push('');\n          for (var i = 0, l = self.fields.length; i < l; i++) {\n            let f = self.fields[i];\n            p[j] = f.name;\n            b &= f.defaultValue() === undefined ? outerArgs[i]._check(v[f.name], f, h, p) : vArray[i] === undefined || outerArgs[i]._check(vArray[i], f, h, p);\n          }\n          p.pop();\n          return !!b;\n        } else {\n          return self.fields.reduce((prevVal, currentVal, i) => {\n            return prevVal && (currentVal.defaultValue() === undefined ? outerArgs[i]._check(v[currentVal.name]) : vArray[i] === undefined || outerArgs[i]._check(vArray[i], f));\n          }, true);\n        }\n      }\n    }[constructorName];\n    return innerFunction;\n  }\n  return ConstructorFunction(values);\n};\nRecordType.prototype._createReader = function () {\n  // jshint -W054\n  var values = [this.recordConstructor];\n  var i, l;\n  for (i = 0, l = this.fields.length; i < l; i++) {\n    values.push(this.fields[i].type);\n  }\n  var self = this;\n  function ConstructorFunction(outerArgs) {\n    var constructorName = self._getConstructorName();\n    var innerFunction = {\n      [constructorName]: function (t) {\n        return new outerArgs[0](...outerArgs.slice(1).map(ftype => ftype['_read'](t)));\n      }\n    }[constructorName];\n    return innerFunction;\n  }\n  return ConstructorFunction(values);\n};\nRecordType.prototype._createSkipper = function () {\n  // jshint -W054\n  var values = [];\n  this.fields.forEach(field => {\n    values.push(field.type);\n  });\n  var self = this;\n  function ConstructorFunction(outerArgs) {\n    var constructorName = self._getConstructorName();\n    var innerFunction = {\n      [constructorName]: function (t) {\n        outerArgs.forEach(arg => arg._skip(t));\n      }\n    }[constructorName];\n    return innerFunction;\n  }\n  return ConstructorFunction(values);\n};\nRecordType.prototype._createWriter = function () {\n  // jshint -W054\n  // We still do default handling here, in case a normal JS object is passed.\n\n  var values = [];\n  var dValues = {};\n  this.fields.forEach((field, i) => {\n    values.push(field.type);\n    if (field.defaultValue() !== undefined) {\n      dValues[i] = field.type.toBuffer(field.defaultValue()).toString('binary');\n    }\n  });\n  var self = this;\n  function ConstructorFunction(vv, dv) {\n    var constructorName = self._getConstructorName();\n    var innerFunction = {\n      [constructorName]: function (t, v) {\n        for (var i = 0, l = self.fields.length; i < l; i++) {\n          let f = self.fields[i];\n          if (f.defaultValue() === undefined) {\n            vv[i]._write(t, v[f.name]);\n          } else {\n            if (v[f.name] === undefined) {\n              t.writeBinary(dv[i], dv[i].length);\n            } else {\n              vv[i]._write(t, v[f.name]);\n            }\n          }\n        }\n      }\n    }[constructorName];\n    return innerFunction;\n  }\n  return ConstructorFunction(values, dValues);\n};\nRecordType.prototype._update = function (resolver, type, opts) {\n  // jshint -W054\n  if (type.name && !~getAliases(this).indexOf(type.name)) {\n    throw new Error(f('no alias found for %s', type.name));\n  }\n  var rFields = this.fields;\n  var wFields = type.fields;\n  var wFieldsMap = utils.toMap(wFields, function (f) {\n    return f.name;\n  });\n  var resolvers = {}; // Resolvers keyed by writer field name.\n  var i, j, field, name, names, matches, fieldResolver;\n  for (i = 0; i < rFields.length; i++) {\n    field = rFields[i];\n    names = getAliases(field);\n    matches = [];\n    for (j = 0; j < names.length; j++) {\n      name = names[j];\n      if (wFieldsMap[name]) {\n        matches.push(name);\n      }\n    }\n    if (matches.length > 1) {\n      throw new Error(f('ambiguous aliasing for %s.%s (%s)', type.name, field.name, matches));\n    }\n    if (!matches.length) {\n      if (field.defaultValue() === undefined) {\n        throw new Error(f('no matching field for default-less %s.%s', type.name, field.name));\n      }\n    } else {\n      name = matches[0];\n      fieldResolver = {\n        resolver: field.type.createResolver(wFieldsMap[name].type, opts),\n        name: '_' + field.name // Reader field name.\n      };\n\n      if (!resolvers[name]) {\n        resolvers[name] = [fieldResolver];\n      } else {\n        resolvers[name].push(fieldResolver);\n      }\n    }\n  }\n  var self = this;\n  function ConstructorFunction() {\n    var constructorName = self._getConstructorName();\n    var innerFunction = {\n      [constructorName]: function (t, b) {\n        if (b) return;\n        var innerArgs = []; // Arguments for reader constructor.\n        for (i = 0; i < rFields.length; i++) {\n          field = rFields[i];\n          names = getAliases(field);\n          matches = [];\n          for (j = 0; j < names.length; j++) {\n            name = names[j];\n            if (wFieldsMap[name]) {\n              matches.push(name);\n            }\n          }\n          if (!matches.length) {\n            innerArgs.push(undefined);\n          }\n        }\n        for (var i = 0; i < wFields.length; i++) {\n          let wf = type.fields[i];\n          name = wf.name;\n          if (resolvers[name] === undefined) {\n            wf.type._skip(t);\n          } else {\n            var j = resolvers[name].length;\n            while (j--) {\n              innerArgs.unshift(j ? resolvers[name][j].resolver._peek(t) : resolvers[name][j].resolver._read(t));\n            }\n          }\n        }\n        return new self.recordConstructor(...innerArgs);\n      }\n    }[constructorName];\n    return innerFunction;\n  }\n  resolver._read = ConstructorFunction();\n};\nRecordType.prototype._match = function (tap1, tap2) {\n  var fields = this.fields;\n  var i, l, field, order, type;\n  for (i = 0, l = fields.length; i < l; i++) {\n    field = fields[i];\n    order = field._order;\n    type = field.type;\n    if (order) {\n      order *= type._match(tap1, tap2);\n      if (order) {\n        return order;\n      }\n    } else {\n      type._skip(tap1);\n      type._skip(tap2);\n    }\n  }\n  return 0;\n};\nRecordType.prototype._checkFields = function (obj) {\n  var keys = Object.keys(obj);\n  var i, l;\n  for (i = 0, l = keys.length; i < l; i++) {\n    if (!this._fieldsByName[keys[i]]) {\n      return false;\n    }\n  }\n  return true;\n};\nRecordType.prototype._copy = function (val, opts) {\n  // jshint -W058\n  var hook = opts && opts.fieldHook;\n  var values = [undefined];\n  var i, l, field, value;\n  for (i = 0, l = this.fields.length; i < l; i++) {\n    field = this.fields[i];\n    value = val[field.name];\n    if (value === undefined && field.hasOwnProperty('defaultValue')) {\n      value = field.defaultValue();\n    }\n    if (opts && !opts.skip || value !== undefined) {\n      value = field.type._copy(value, opts);\n    }\n    if (hook) {\n      value = hook(field, value, this);\n    }\n    values.push(value);\n  }\n  var Record = this.recordConstructor;\n  return new (Record.bind.apply(Record, values))();\n};\nRecordType.prototype._deref = function (schema, opts) {\n  schema.fields = this.fields.map(function (field) {\n    var fieldType = field.type;\n    var fieldSchema = {\n      name: field.name,\n      type: fieldType._attrs(opts)\n    };\n    if (opts.exportAttrs) {\n      var val = field.defaultValue();\n      if (val !== undefined) {\n        // We must both unwrap all unions and coerce buffers to strings.\n        fieldSchema['default'] = fieldType._copy(val, {\n          coerce: 3,\n          wrap: 3\n        });\n      }\n      var fieldOrder = field.order;\n      if (fieldOrder !== 'ascending') {\n        fieldSchema.order = fieldOrder;\n      }\n      var fieldAliases = field.aliases;\n      if (fieldAliases.length) {\n        fieldSchema.aliases = fieldAliases;\n      }\n      var fieldDoc = field.doc;\n      if (fieldDoc !== undefined) {\n        fieldSchema.doc = fieldDoc;\n      }\n    }\n    return fieldSchema;\n  });\n};\nRecordType.prototype.compare = function (val1, val2) {\n  var fields = this.fields;\n  var i, l, field, name, order, type;\n  for (i = 0, l = fields.length; i < l; i++) {\n    field = fields[i];\n    name = field.name;\n    order = field._order;\n    type = field.type;\n    if (order) {\n      order *= type.compare(val1[name], val2[name]);\n      if (order) {\n        return order;\n      }\n    }\n  }\n  return 0;\n};\nRecordType.prototype.random = function () {\n  // jshint -W058\n  var fields = this.fields.map(function (f) {\n    return f.type.random();\n  });\n  fields.unshift(undefined);\n  var Record = this.recordConstructor;\n  return new (Record.bind.apply(Record, fields))();\n};\nRecordType.prototype.field = function (name) {\n  return this._fieldsByName[name];\n};\nRecordType.prototype.getField = RecordType.prototype.field;\nRecordType.prototype.getFields = function () {\n  return this.fields;\n};\nRecordType.prototype.getRecordConstructor = function () {\n  return this.recordConstructor;\n};\nObject.defineProperty(RecordType.prototype, 'typeName', {\n  enumerable: true,\n  get: function () {\n    return this._isError ? 'error' : 'record';\n  }\n});\n\n/** Derived type abstract class. */\nfunction LogicalType(schema, opts) {\n  this._logicalTypeName = schema.logicalType;\n  Type.call(this);\n  LOGICAL_TYPE = this;\n  try {\n    this._underlyingType = Type.forSchema(schema, opts);\n  } finally {\n    LOGICAL_TYPE = null;\n    // Remove the underlying type now that we're done instantiating. Note that\n    // in some (rare) cases, it might not have been inserted; for example, if\n    // this constructor was manually called with an already instantiated type.\n    var l = UNDERLYING_TYPES.length;\n    if (l && UNDERLYING_TYPES[l - 1][0] === this) {\n      UNDERLYING_TYPES.pop();\n    }\n  }\n  // We create a separate branch constructor for logical types to keep them\n  // monomorphic.\n  if (Type.isType(this.underlyingType, 'union')) {\n    this._branchConstructor = this.underlyingType._branchConstructor;\n  } else {\n    this._branchConstructor = this.underlyingType._createBranchConstructor();\n  }\n  // We don't freeze derived types to allow arbitrary properties. Implementors\n  // can still do so in the subclass' constructor at their convenience.\n}\n\nutil.inherits(LogicalType, Type);\nObject.defineProperty(LogicalType.prototype, 'typeName', {\n  enumerable: true,\n  get: function () {\n    return 'logical:' + this._logicalTypeName;\n  }\n});\nObject.defineProperty(LogicalType.prototype, 'underlyingType', {\n  enumerable: true,\n  get: function () {\n    if (this._underlyingType) {\n      return this._underlyingType;\n    }\n    // If the field wasn't present, it means the logical type isn't complete\n    // yet: we're waiting on its underlying type to be fully instantiated. In\n    // this case, it will be present in the `UNDERLYING_TYPES` array.\n    var i, l, arr;\n    for (i = 0, l = UNDERLYING_TYPES.length; i < l; i++) {\n      arr = UNDERLYING_TYPES[i];\n      if (arr[0] === this) {\n        return arr[1];\n      }\n    }\n  }\n});\nLogicalType.prototype.getUnderlyingType = function () {\n  return this.underlyingType;\n};\nLogicalType.prototype._read = function (tap) {\n  return this._fromValue(this.underlyingType._read(tap));\n};\nLogicalType.prototype._write = function (tap, any) {\n  this.underlyingType._write(tap, this._toValue(any));\n};\nLogicalType.prototype._check = function (any, flags, hook, path) {\n  try {\n    var val = this._toValue(any);\n  } catch (err) {\n    // Handled below.\n  }\n  if (val === undefined) {\n    if (hook) {\n      hook(any, this);\n    }\n    return false;\n  }\n  return this.underlyingType._check(val, flags, hook, path);\n};\nLogicalType.prototype._copy = function (any, opts) {\n  var type = this.underlyingType;\n  switch (opts && opts.coerce) {\n    case 3:\n      // To string.\n      return type._copy(this._toValue(any), opts);\n    case 2:\n      // From string.\n      return this._fromValue(type._copy(any, opts));\n    default:\n      // Normal copy.\n      return this._fromValue(type._copy(this._toValue(any), opts));\n  }\n};\nLogicalType.prototype._update = function (resolver, type, opts) {\n  var _fromValue = this._resolve(type, opts);\n  if (_fromValue) {\n    resolver._read = function (tap) {\n      return _fromValue(type._read(tap));\n    };\n  }\n};\nLogicalType.prototype.compare = function (obj1, obj2) {\n  var val1 = this._toValue(obj1);\n  var val2 = this._toValue(obj2);\n  return this.underlyingType.compare(val1, val2);\n};\nLogicalType.prototype.random = function () {\n  return this._fromValue(this.underlyingType.random());\n};\nLogicalType.prototype._deref = function (schema, opts) {\n  var type = this.underlyingType;\n  var isVisited = type.name !== undefined && opts.derefed[type.name];\n  schema = type._attrs(opts);\n  if (!isVisited && opts.exportAttrs) {\n    if (typeof schema == 'string') {\n      schema = {\n        type: schema\n      };\n    }\n    schema.logicalType = this._logicalTypeName;\n    this._export(schema);\n  }\n  return schema;\n};\nLogicalType.prototype._skip = function (tap) {\n  this.underlyingType._skip(tap);\n};\n\n// Unlike the other methods below, `_export` has a reasonable default which we\n// can provide (not exporting anything).\nLogicalType.prototype._export = function /* schema */ () {};\n\n// Methods to be implemented.\nLogicalType.prototype._fromValue = utils.abstractFunction;\nLogicalType.prototype._toValue = utils.abstractFunction;\nLogicalType.prototype._resolve = utils.abstractFunction;\n\n// General helpers.\n\n/**\n * Customizable long.\n *\n * This allows support of arbitrarily large long (e.g. larger than\n * `Number.MAX_SAFE_INTEGER`). See `LongType.__with` method above. Note that we\n * can't use a logical type because we need a \"lower-level\" hook here: passing\n * through through the standard long would cause a loss of precision.\n */\nfunction AbstractLongType(noUnpack) {\n  this._concreteTypeName = 'long';\n  PrimitiveType.call(this, true);\n  // Note that this type \"inherits\" `LongType` (i.e. gain its prototype\n  // methods) but only \"subclasses\" `PrimitiveType` to avoid being prematurely\n  // frozen.\n  this._noUnpack = !!noUnpack;\n}\nutil.inherits(AbstractLongType, LongType);\nAbstractLongType.prototype.typeName = 'abstract:long';\nAbstractLongType.prototype._check = function (val, flags, hook) {\n  var b = this._isValid(val);\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\nAbstractLongType.prototype._read = function (tap) {\n  var buf, pos;\n  if (this._noUnpack) {\n    pos = tap.pos;\n    tap.skipLong();\n    buf = tap.buf.slice(pos, tap.pos);\n  } else {\n    buf = tap.unpackLongBytes(tap);\n  }\n  if (tap.isValid()) {\n    return this._fromBuffer(buf);\n  }\n};\nAbstractLongType.prototype._write = function (tap, val) {\n  if (!this._isValid(val)) {\n    throwInvalidError(val, this);\n  }\n  var buf = this._toBuffer(val);\n  if (this._noUnpack) {\n    tap.writeFixed(buf);\n  } else {\n    tap.packLongBytes(buf);\n  }\n};\nAbstractLongType.prototype._copy = function (val, opts) {\n  switch (opts && opts.coerce) {\n    case 3:\n      // To string.\n      return this._toJSON(val);\n    case 2:\n      // From string.\n      return this._fromJSON(val);\n    default:\n      // Normal copy.\n      // Slow but guarantees most consistent results. Faster alternatives would\n      // require assumptions on the long class used (e.g. immutability).\n      return this._fromJSON(this._toJSON(val));\n  }\n};\nAbstractLongType.prototype._deref = function () {\n  return 'long';\n};\nAbstractLongType.prototype._update = function (resolver, type) {\n  var self = this;\n  switch (type.typeName) {\n    case 'int':\n      resolver._read = function (tap) {\n        return self._fromJSON(type._read(tap));\n      };\n      break;\n    case 'long':\n      resolver._read = function (tap) {\n        return self._read(tap);\n      };\n  }\n};\nAbstractLongType.prototype.random = function () {\n  return this._fromJSON(LongType.prototype.random());\n};\n\n// Methods to be implemented by the user.\nAbstractLongType.prototype._fromBuffer = utils.abstractFunction;\nAbstractLongType.prototype._toBuffer = utils.abstractFunction;\nAbstractLongType.prototype._fromJSON = utils.abstractFunction;\nAbstractLongType.prototype._toJSON = utils.abstractFunction;\nAbstractLongType.prototype._isValid = utils.abstractFunction;\nAbstractLongType.prototype.compare = utils.abstractFunction;\n\n/** A record field. */\nfunction Field(schema, opts) {\n  var name = schema.name;\n  if (typeof name != 'string' || !isValidName(name)) {\n    throw new Error(f('invalid field name: %s', name));\n  }\n  this.name = name;\n  this.type = Type.forSchema(schema.type, opts);\n  this.aliases = schema.aliases || [];\n  this.doc = schema.doc !== undefined ? '' + schema.doc : undefined;\n  this._order = function (order) {\n    switch (order) {\n      case 'ascending':\n        return 1;\n      case 'descending':\n        return -1;\n      case 'ignore':\n        return 0;\n      default:\n        throw new Error(f('invalid order: %j', order));\n    }\n  }(schema.order === undefined ? 'ascending' : schema.order);\n  var value = schema['default'];\n  if (value !== undefined) {\n    // We need to convert defaults back to a valid format (unions are\n    // disallowed in default definitions, only the first type of each union is\n    // allowed instead).\n    // http://apache-avro.679487.n3.nabble.com/field-union-default-in-Java-td1175327.html\n    var type = this.type;\n    var val = type._copy(value, {\n      coerce: 2,\n      wrap: 2\n    });\n    // The clone call above will throw an error if the default is invalid.\n    if (isPrimitive(type.typeName) && type.typeName !== 'bytes') {\n      // These are immutable.\n      this.defaultValue = function () {\n        return val;\n      };\n    } else {\n      this.defaultValue = function () {\n        return type._copy(val);\n      };\n    }\n  }\n  Object.freeze(this);\n}\nField.prototype.defaultValue = function () {}; // Undefined default.\n\nObject.defineProperty(Field.prototype, 'order', {\n  enumerable: true,\n  get: function () {\n    return ['descending', 'ignore', 'ascending'][this._order + 1];\n  }\n});\nField.prototype.getAliases = function () {\n  return this.aliases;\n};\nField.prototype.getDefault = Field.prototype.defaultValue;\nField.prototype.getName = function () {\n  return this.name;\n};\nField.prototype.getOrder = function () {\n  return this.order;\n};\nField.prototype.getType = function () {\n  return this.type;\n};\n\n/**\n * Resolver to read a writer's schema as a new schema.\n *\n * @param readerType {Type} The type to convert to.\n */\nfunction Resolver(readerType) {\n  // Add all fields here so that all resolvers share the same hidden class.\n  this._readerType = readerType;\n  this._read = null;\n  this.itemsType = null;\n  this.size = 0;\n  this.symbols = null;\n  this.valuesType = null;\n}\nResolver.prototype._peek = Type.prototype._peek;\nResolver.prototype.inspect = function () {\n  return '<Resolver>';\n};\n\n/** Mutable hash container. */\nfunction Hash() {\n  this.str = undefined;\n}\n\n/**\n * Read a value from a tap.\n *\n * @param type {Type} The type to decode.\n * @param tap {Tap} The tap to read from. No checks are performed here.\n * @param resolver {Resolver} Optional resolver. It must match the input type.\n * @param lazy {Boolean} Skip trailing fields when using a resolver.\n */\nfunction readValue(type, tap, resolver, lazy) {\n  if (resolver) {\n    if (resolver._readerType !== type) {\n      throw new Error('invalid resolver');\n    }\n    return resolver._read(tap, lazy);\n  } else {\n    return type._read(tap);\n  }\n}\n\n/**\n * Remove namespace from a name.\n *\n * @param name {String} Full or short name.\n */\nfunction unqualify(name) {\n  var parts = name.split('.');\n  return parts[parts.length - 1];\n}\n\n/**\n * Verify and return fully qualified name.\n *\n * @param name {String} Full or short name. It can be prefixed with a dot to\n * force global namespace.\n * @param namespace {String} Optional namespace.\n */\nfunction qualify(name, namespace) {\n  if (~name.indexOf('.')) {\n    name = name.replace(/^\\./, ''); // Allow absolute referencing.\n  } else if (namespace) {\n    name = namespace + '.' + name;\n  }\n  name.split('.').forEach(function (part) {\n    if (!isValidName(part)) {\n      throw new Error(f('invalid name: %j', name));\n    }\n  });\n  var tail = unqualify(name);\n  // Primitives are always in the global namespace.\n  return isPrimitive(tail) ? tail : name;\n}\n\n/**\n * Get all aliases for a type (including its name).\n *\n * @param obj {Type|Object} Typically a type or a field. Its aliases property\n * must exist and be an array.\n */\nfunction getAliases(obj) {\n  var names = {};\n  if (obj.name) {\n    names[obj.name] = true;\n  }\n  var aliases = obj.aliases;\n  var i, l;\n  for (i = 0, l = aliases.length; i < l; i++) {\n    names[aliases[i]] = true;\n  }\n  return Object.keys(names);\n}\n\n/**\n * Check whether a type's name is a primitive.\n *\n * @param name {String} Type name (e.g. `'string'`, `'array'`).\n */\nfunction isPrimitive(typeName) {\n  // Since we use this module's own `TYPES` object, we can use `instanceof`.\n  var type = TYPES[typeName];\n  return type && type.prototype instanceof PrimitiveType;\n}\n\n/**\n * Return a type's class name from its Avro type name.\n *\n * We can't simply use `constructor.name` since it isn't supported in all\n * browsers.\n *\n * @param typeName {String} Type name.\n */\nfunction getClassName(typeName) {\n  if (typeName === 'error') {\n    typeName = 'record';\n  } else {\n    var match = /^([^:]+):(.*)$/.exec(typeName);\n    if (match) {\n      if (match[1] === 'union') {\n        typeName = match[2] + 'Union';\n      } else {\n        // Logical type.\n        typeName = match[1];\n      }\n    }\n  }\n  return utils.capitalize(typeName) + 'Type';\n}\n\n/**\n * Get the number of elements in an array block.\n *\n * @param tap {Tap} A tap positioned at the beginning of an array block.\n */\nfunction readArraySize(tap) {\n  var n = tap.readLong();\n  if (n < 0) {\n    n = -n;\n    tap.skipLong(); // Skip size.\n  }\n\n  return n;\n}\n\n/**\n * Check whether a long can be represented without precision loss.\n *\n * @param n {Number} The number.\n *\n * Two things to note:\n *\n * + We are not using the `Number` constants for compatibility with older\n *   browsers.\n * + We must remove one from each bound because of rounding errors.\n */\nfunction isSafeLong(n) {\n  return n >= -9007199254740990 && n <= 9007199254740990;\n}\n\n/**\n * Check whether an object is the JSON representation of a buffer.\n */\nfunction isJsonBuffer(obj) {\n  return obj && obj.type === 'Buffer' && Array.isArray(obj.data);\n}\n\n/**\n * Check whether a string is a valid Avro identifier.\n */\nfunction isValidName(str) {\n  return NAME_PATTERN.test(str);\n}\n\n/**\n * Throw a somewhat helpful error on invalid object.\n *\n * @param path {Array} Passed from hook, but unused (because empty where this\n * function is used, since we aren't keeping track of it for effiency).\n * @param val {...} The object to reject.\n * @param type {Type} The type to check against.\n *\n * This method is mostly used from `_write` to signal an invalid object for a\n * given type. Note that this provides less information than calling `isValid`\n * with a hook since the path is not propagated (for efficiency reasons).\n */\nfunction throwInvalidError(val, type) {\n  throw new Error(f('invalid %s: %j', type, val));\n}\n\n/**\n * Get a type's bucket when included inside an unwrapped union.\n *\n * @param type {Type} Any type.\n */\nfunction getTypeBucket(type) {\n  var typeName = type.typeName;\n  switch (typeName) {\n    case 'double':\n    case 'float':\n    case 'int':\n    case 'long':\n      return 'number';\n    case 'bytes':\n    case 'fixed':\n      return 'buffer';\n    case 'enum':\n      return 'string';\n    case 'map':\n    case 'error':\n    case 'record':\n      return 'object';\n    default:\n      return typeName;\n  }\n}\n\n/**\n * Infer a value's bucket (see unwrapped unions for more details).\n *\n * @param val {...} Any value.\n */\nfunction getValueBucket(val) {\n  if (val === null) {\n    return 'null';\n  }\n  var bucket = typeof val;\n  if (bucket === 'object') {\n    // Could be bytes, fixed, array, map, or record.\n    if (Array.isArray(val)) {\n      return 'array';\n    } else if (Buffer.isBuffer(val)) {\n      return 'buffer';\n    }\n  }\n  return bucket;\n}\n\n/**\n * Check whether a collection of types leads to an ambiguous union.\n *\n * @param types {Array} Array of types.\n */\nfunction isAmbiguous(types) {\n  var buckets = {};\n  var i, l, bucket, type;\n  for (i = 0, l = types.length; i < l; i++) {\n    type = types[i];\n    if (!Type.isType(type, 'logical')) {\n      bucket = getTypeBucket(type);\n      if (buckets[bucket]) {\n        return true;\n      }\n      buckets[bucket] = true;\n    }\n  }\n  return false;\n}\n\n/**\n * Combine number types.\n *\n * Note that never have to create a new type here, we are guaranteed to be able\n * to reuse one of the input types as super-type.\n */\nfunction combineNumbers(types) {\n  var typeNames = ['int', 'long', 'float', 'double'];\n  var superIndex = -1;\n  var superType = null;\n  var i, l, type, index;\n  for (i = 0, l = types.length; i < l; i++) {\n    type = types[i];\n    index = typeNames.indexOf(type.typeName);\n    if (index > superIndex) {\n      superIndex = index;\n      superType = type;\n    }\n  }\n  return superType;\n}\n\n/**\n * Combine enums and strings.\n *\n * The order of the returned symbols is undefined and the returned enum is\n *\n */\nfunction combineStrings(types, opts) {\n  var symbols = {};\n  var i, l, type, typeSymbols;\n  for (i = 0, l = types.length; i < l; i++) {\n    type = types[i];\n    if (type.typeName === 'string') {\n      // If at least one of the types is a string, it will be the supertype.\n      return type;\n    }\n    typeSymbols = type.symbols;\n    var j, m;\n    for (j = 0, m = typeSymbols.length; j < m; j++) {\n      symbols[typeSymbols[j]] = true;\n    }\n  }\n  return Type.forSchema({\n    type: 'enum',\n    symbols: Object.keys(symbols)\n  }, opts);\n}\n\n/**\n * Combine bytes and fixed.\n *\n * This function is optimized to avoid creating new types when possible: in\n * case of a size mismatch between fixed types, it will continue looking\n * through the array to find an existing bytes type (rather than exit early by\n * creating one eagerly).\n */\nfunction combineBuffers(types, opts) {\n  var size = -1;\n  var i, l, type;\n  for (i = 0, l = types.length; i < l; i++) {\n    type = types[i];\n    if (type.typeName === 'bytes') {\n      return type;\n    }\n    if (size === -1) {\n      size = type.size;\n    } else if (type.size !== size) {\n      // Don't create a bytes type right away, we might be able to reuse one\n      // later on in the types array. Just mark this for now.\n      size = -2;\n    }\n  }\n  return size < 0 ? Type.forSchema('bytes', opts) : types[0];\n}\n\n/**\n * Combine maps and records.\n *\n * Field defaults are kept when possible (i.e. when no coercion to a map\n * happens), with later definitions overriding previous ones.\n */\nfunction combineObjects(types, opts) {\n  var allTypes = []; // Field and value types.\n  var fieldTypes = {}; // Record field types grouped by field name.\n  var fieldDefaults = {};\n  var isValidRecord = true;\n\n  // Check whether the final type will be a map or a record.\n  var i, l, type, fields;\n  for (i = 0, l = types.length; i < l; i++) {\n    type = types[i];\n    if (type.typeName === 'map') {\n      isValidRecord = false;\n      allTypes.push(type.valuesType);\n    } else {\n      fields = type.fields;\n      var j, m, field, fieldDefault, fieldName, fieldType;\n      for (j = 0, m = fields.length; j < m; j++) {\n        field = fields[j];\n        fieldName = field.name;\n        fieldType = field.type;\n        allTypes.push(fieldType);\n        if (isValidRecord) {\n          if (!fieldTypes[fieldName]) {\n            fieldTypes[fieldName] = [];\n          }\n          fieldTypes[fieldName].push(fieldType);\n          fieldDefault = field.defaultValue();\n          if (fieldDefault !== undefined) {\n            // Later defaults will override any previous ones.\n            fieldDefaults[fieldName] = fieldDefault;\n          }\n        }\n      }\n    }\n  }\n  if (isValidRecord) {\n    // Check that no fields are missing and that we have the approriate\n    // defaults for those which are.\n    var fieldNames = Object.keys(fieldTypes);\n    for (i = 0, l = fieldNames.length; i < l; i++) {\n      fieldName = fieldNames[i];\n      if (fieldTypes[fieldName].length < types.length && fieldDefaults[fieldName] === undefined) {\n        // At least one of the records is missing a field with no default.\n        if (opts && opts.strictDefaults) {\n          isValidRecord = false;\n        } else {\n          fieldTypes[fieldName].unshift(Type.forSchema('null', opts));\n          fieldDefaults[fieldName] = null;\n        }\n      }\n    }\n  }\n  var schema;\n  if (isValidRecord) {\n    schema = {\n      type: 'record',\n      fields: fieldNames.map(function (s) {\n        var fieldType = Type.forTypes(fieldTypes[s], opts);\n        var fieldDefault = fieldDefaults[s];\n        if (fieldDefault !== undefined && ~fieldType.typeName.indexOf('union')) {\n          // Ensure that the default's corresponding type is first.\n          var unionTypes = fieldType.types.slice();\n          var i, l;\n          for (i = 0, l = unionTypes.length; i < l; i++) {\n            if (unionTypes[i].isValid(fieldDefault)) {\n              break;\n            }\n          }\n          if (i > 0) {\n            var unionType = unionTypes[0];\n            unionTypes[0] = unionTypes[i];\n            unionTypes[i] = unionType;\n            fieldType = Type.forSchema(unionTypes, opts);\n          }\n        }\n        return {\n          name: s,\n          type: fieldType,\n          'default': fieldDefaults[s]\n        };\n      })\n    };\n  } else {\n    schema = {\n      type: 'map',\n      values: Type.forTypes(allTypes, opts)\n    };\n  }\n  return Type.forSchema(schema, opts);\n}\nmodule.exports = {\n  Type: Type,\n  getTypeBucket: getTypeBucket,\n  getValueBucket: getValueBucket,\n  isPrimitive: isPrimitive,\n  isValidName: isValidName,\n  qualify: qualify,\n  builtins: function () {\n    var types = {\n      LogicalType: LogicalType,\n      UnwrappedUnionType: UnwrappedUnionType,\n      WrappedUnionType: WrappedUnionType\n    };\n    var typeNames = Object.keys(TYPES);\n    var i, l, typeName;\n    for (i = 0, l = typeNames.length; i < l; i++) {\n      typeName = typeNames[i];\n      types[getClassName(typeName)] = TYPES[typeName];\n    }\n    return types;\n  }()\n};","map":{"version":3,"names":["require","utils","buffer","util","Tap","debug","debuglog","f","format","TYPES","ArrayType","BooleanType","BytesType","DoubleType","EnumType","RecordType","FixedType","FloatType","IntType","LongType","MapType","NullType","StringType","NAME_PATTERN","RANDOM","Lcg","TAP","SlowBuffer","LOGICAL_TYPE","UNDERLYING_TYPES","Type","schema","opts","type","push","_hash","Hash","name","undefined","aliases","doc","namespace","qualify","isPrimitive","Error","registry","noAnonymousTypes","map","s","forSchema","UnionType","wrapUnions","toLowerCase","WrappedUnionType","UnwrappedUnionType","isType","typeHook","logicalType","logicalTypes","DerivedType","Object","keys","forEach","key","err","assertLogicalTypes","Array","isArray","types","obj","isAmbiguous","typeName","forValue","val","emptyArrayType","items","valueHook","Math","abs","length","forTypes","v","Buffer","isBuffer","fieldNames","some","isValidName","values","fields","expanded","numWrappedUnions","isValidWrappedUnion","concat","branchTypes","branchName","branchType","equals","unionType","bucketized","bucket","getTypeBucket","bucketTypes","buckets","augmented","combineNumbers","combineStrings","combineBuffers","filter","t","itemsType","combineObjects","l","arguments","any","_update","fingerprint","i","indexOf","__reset","size","buf","defineProperty","prototype","enumerable","get","underlyingType","_concreteTypeName","clone","coerce","coerceBuffers","fieldHook","qualifyNames","skip","skipMissingFields","wrap","_copy","fromBuffer","toBuffer","compare","abstractFunction","compareBuffers","buf1","buf2","_match","createResolver","resolver","Resolver","resolvers","_read","tap","index","readLong","freeze","decode","pos","readValue","isValid","value","offset","encode","_write","algorithm","str","schemaStr","JSON","stringify","getHash","toString","bufferFrom","noCheck","fromString","parse","inspect","className","getClassName","exportAttrs","noDeref","flags","noUndeclaredFields","errorHook","hook","path","call","slice","_check","random","_attrs","newBuffer","copy","toJSON","Branch","_branchConstructor","derefed","derefedSchema","_deref","_createBranchConstructor","ConstructorFunction","Branch$","unwrap","unwrapped","_peek","_skip","getAliases","getFingerprint","getName","asBranch","getSchema","getTypeName","PrimitiveType","noFreeze","inherits","throwInvalidError","b","readBoolean","skipBoolean","writeBoolean","tap1","tap2","matchBoolean","nextBoolean","readInt","skipInt","writeInt","matchInt","nextInt","isSafeLong","n","skipLong","writeLong","matchLong","__with","methods","noUnpack","mapping","fromJSON","AbstractLongType","readFloat","skipFloat","writeFloat","matchFloat","nextFloat","readDouble","skipDouble","writeDouble","matchDouble","readString","skipString","writeString","matchString","nextString","readBytes","skipBytes","writeBytes","matchBytes","isJsonBuffer","data","nextBuffer","_branchIndices","branch","n1","n2","getTypes","_dynamicBranches","_bucketIndices","_getIndex","getValueBucket","_getBranchIndex","logicalBranches","typeResolver","val1","val2","index1","index2","pop","firstType","j","unqualify","name1","name2","symbols","_indices","symbol","every","getSymbols","choice","readFixed","skipFixed","writeFixed","matchFixed","getSize","valuesType","readArraySize","len","rsv","getValuesType","min","getItemsType","arr","match","exec","hasDuplicates","_fieldsByName","field","Field","_isError","recordConstructor","_createConstructor","errorStackTraces","_createReader","_createSkipper","_createWriter","_createChecker","_getConstructorName","ds","defaultValue","hasDefault","stackField","self","outerArgs","constructorName","innerFunction","innerArgs","stack","captureStackTrace","constructor","Record","getType","o","wrapped","h","p","_checkFields","vArray","reduce","prevVal","currentVal","ftype","arg","dValues","vv","dv","writeBinary","rFields","wFields","wFieldsMap","toMap","names","matches","fieldResolver","wf","unshift","order","_order","hasOwnProperty","bind","apply","fieldType","fieldSchema","fieldOrder","fieldAliases","fieldDoc","getField","getFields","getRecordConstructor","LogicalType","_logicalTypeName","_underlyingType","getUnderlyingType","_fromValue","_toValue","_resolve","obj1","obj2","isVisited","_export","_noUnpack","_isValid","unpackLongBytes","_fromBuffer","_toBuffer","packLongBytes","_toJSON","_fromJSON","getDefault","getOrder","readerType","_readerType","lazy","parts","split","replace","part","tail","capitalize","test","typeNames","superIndex","superType","typeSymbols","m","allTypes","fieldTypes","fieldDefaults","isValidRecord","fieldDefault","fieldName","strictDefaults","unionTypes","module","exports","builtins"],"sources":["E:/Amanda-project/vue2-project/project-vue2/node_modules/avsc/lib/types.js"],"sourcesContent":["/* jshint node: true */\n\n// TODO: Make it easier to implement custom types. This will likely require\n// exposing the `Tap` object, perhaps under another name. Probably worth a\n// major release.\n// TODO: Allow configuring when to write the size when writing arrays and maps,\n// and customizing their block size.\n// TODO: Code-generate `compare` and `clone` record and union methods.\n\n'use strict';\n\n/**\n * This module defines all Avro data types and their serialization logic.\n *\n */\n\nvar utils = require('./utils'),\n    buffer = require('buffer'), // For `SlowBuffer`.\n    util = require('util');\n\n\n// Convenience imports.\nvar Tap = utils.Tap;\nvar debug = util.debuglog('avsc:types');\nvar f = util.format;\n\n// All non-union concrete (i.e. non-logical) Avro types.\nvar TYPES = {\n  'array': ArrayType,\n  'boolean': BooleanType,\n  'bytes': BytesType,\n  'double': DoubleType,\n  'enum': EnumType,\n  'error': RecordType,\n  'fixed': FixedType,\n  'float': FloatType,\n  'int': IntType,\n  'long': LongType,\n  'map': MapType,\n  'null': NullType,\n  'record': RecordType,\n  'string': StringType\n};\n\n// Valid (field, type, and symbol) name regex.\nvar NAME_PATTERN = /^[A-Za-z_][A-Za-z0-9_]*$/;\n\n// Random generator.\nvar RANDOM = new utils.Lcg();\n\n// Encoding tap (shared for performance).\nvar TAP = new Tap(new buffer.SlowBuffer(1024));\n\n// Currently active logical type, used for name redirection.\nvar LOGICAL_TYPE = null;\n\n// Underlying types of logical types currently being instantiated. This is used\n// to be able to reference names (i.e. for branches) during instantiation.\nvar UNDERLYING_TYPES = [];\n\n/**\n * \"Abstract\" base Avro type.\n *\n * This class' constructor will register any named types to support recursive\n * schemas. All type values are represented in memory similarly to their JSON\n * representation, except for:\n *\n * + `bytes` and `fixed` which are represented as `Buffer`s.\n * + `union`s which will be \"unwrapped\" unless the `wrapUnions` option is set.\n *\n *  See individual subclasses for details.\n */\nfunction Type(schema, opts) {\n  var type;\n  if (LOGICAL_TYPE) {\n    type = LOGICAL_TYPE;\n    UNDERLYING_TYPES.push([LOGICAL_TYPE, this]);\n    LOGICAL_TYPE = null;\n  } else {\n    type = this;\n  }\n\n  // Lazily instantiated hash string. It will be generated the first time the\n  // type's default fingerprint is computed (for example when using `equals`).\n  // We use a mutable object since types are frozen after instantiation.\n  this._hash = new Hash();\n  this.name = undefined;\n  this.aliases = undefined;\n  this.doc = (schema && schema.doc) ? '' + schema.doc : undefined;\n\n  if (schema) {\n    // This is a complex (i.e. non-primitive) type.\n    var name = schema.name;\n    var namespace = schema.namespace === undefined ?\n      opts && opts.namespace :\n      schema.namespace;\n    if (name !== undefined) {\n      // This isn't an anonymous type.\n      name = qualify(name, namespace);\n      if (isPrimitive(name)) {\n        // Avro doesn't allow redefining primitive names.\n        throw new Error(f('cannot rename primitive type: %j', name));\n      }\n      var registry = opts && opts.registry;\n      if (registry) {\n        if (registry[name] !== undefined) {\n          throw new Error(f('duplicate type name: %s', name));\n        }\n        registry[name] = type;\n      }\n    } else if (opts && opts.noAnonymousTypes) {\n      throw new Error(f('missing name property in schema: %j', schema));\n    }\n    this.name = name;\n    this.aliases = schema.aliases ?\n      schema.aliases.map(function (s) { return qualify(s, namespace); }) :\n      [];\n  }\n}\n\nType.forSchema = function (schema, opts) {\n  opts = opts || {};\n  opts.registry = opts.registry || {};\n\n  var UnionType = (function (wrapUnions) {\n    if (wrapUnions === true) {\n      wrapUnions = 'always';\n    } else if (wrapUnions === false) {\n      wrapUnions = 'never';\n    } else if (wrapUnions === undefined) {\n      wrapUnions = 'auto';\n    } else if (typeof wrapUnions == 'string') {\n      wrapUnions = wrapUnions.toLowerCase();\n    }\n    switch (wrapUnions) {\n      case 'always':\n        return WrappedUnionType;\n      case 'never':\n        return UnwrappedUnionType;\n      case 'auto':\n        return undefined; // Determined dynamically later on.\n      default:\n        throw new Error(f('invalid wrap unions option: %j', wrapUnions));\n    }\n  })(opts.wrapUnions);\n\n  if (schema === null) {\n    // Let's be helpful for this common error.\n    throw new Error('invalid type: null (did you mean \"null\"?)');\n  }\n\n  if (Type.isType(schema)) {\n    return schema;\n  }\n\n  var type;\n  if (opts.typeHook && (type = opts.typeHook(schema, opts))) {\n    if (!Type.isType(type)) {\n      throw new Error(f('invalid typehook return value: %j', type));\n    }\n    return type;\n  }\n\n  if (typeof schema == 'string') { // Type reference.\n    schema = qualify(schema, opts.namespace);\n    type = opts.registry[schema];\n    if (type) {\n      // Type was already defined, return it.\n      return type;\n    }\n    if (isPrimitive(schema)) {\n      // Reference to a primitive type. These are also defined names by default\n      // so we create the appropriate type and it to the registry for future\n      // reference.\n      return opts.registry[schema] = Type.forSchema({type: schema}, opts);\n    }\n    throw new Error(f('undefined type name: %s', schema));\n  }\n\n  if (schema.logicalType && opts.logicalTypes && !LOGICAL_TYPE) {\n    var DerivedType = opts.logicalTypes[schema.logicalType];\n    if (DerivedType) {\n      var namespace = opts.namespace;\n      var registry = {};\n      Object.keys(opts.registry).forEach(function (key) {\n        registry[key] = opts.registry[key];\n      });\n      try {\n        debug('instantiating logical type for %s', schema.logicalType);\n        return new DerivedType(schema, opts);\n      } catch (err) {\n        debug('failed to instantiate logical type for %s', schema.logicalType);\n        if (opts.assertLogicalTypes) {\n          // The spec mandates that we fall through to the underlying type if\n          // the logical type is invalid. We provide this option to ease\n          // debugging.\n          throw err;\n        }\n        LOGICAL_TYPE = null;\n        opts.namespace = namespace;\n        opts.registry = registry;\n      }\n    }\n  }\n\n  if (Array.isArray(schema)) { // Union.\n    var types = schema.map(function (obj) {\n      return Type.forSchema(obj, opts);\n    });\n    if (!UnionType) {\n      UnionType = isAmbiguous(types) ? WrappedUnionType : UnwrappedUnionType;\n    }\n    type = new UnionType(types, opts);\n  } else { // New type definition.\n    type = (function (typeName) {\n      var Type = TYPES[typeName];\n      if (Type === undefined) {\n        throw new Error(f('unknown type: %j', typeName));\n      }\n      return new Type(schema, opts);\n    })(schema.type);\n  }\n  return type;\n};\n\nType.forValue = function (val, opts) {\n  opts = opts || {};\n\n  // Sentinel used when inferring the types of empty arrays.\n  opts.emptyArrayType = opts.emptyArrayType || Type.forSchema({\n    type: 'array', items: 'null'\n  });\n\n  // Optional custom inference hook.\n  if (opts.valueHook) {\n    var type = opts.valueHook(val, opts);\n    if (type !== undefined) {\n      if (!Type.isType(type)) {\n        throw new Error(f('invalid value hook return value: %j', type));\n      }\n      return type;\n    }\n  }\n\n  // Default inference logic.\n  switch (typeof val) {\n    case 'string':\n      return Type.forSchema('string', opts);\n    case 'boolean':\n      return Type.forSchema('boolean', opts);\n    case 'number':\n      if ((val | 0) === val) {\n        return Type.forSchema('int', opts);\n      } else if (Math.abs(val) < 9007199254740991) {\n        return Type.forSchema('float', opts);\n      }\n      return Type.forSchema('double', opts);\n    case 'object':\n      if (val === null) {\n        return Type.forSchema('null', opts);\n      } else if (Array.isArray(val)) {\n        if (!val.length) {\n          return opts.emptyArrayType;\n        }\n        return Type.forSchema({\n          type: 'array',\n          items: Type.forTypes(\n            val.map(function (v) { return Type.forValue(v, opts); })\n          )\n        }, opts);\n      } else if (Buffer.isBuffer(val)) {\n        return Type.forSchema('bytes', opts);\n      }\n      var fieldNames = Object.keys(val);\n      if (fieldNames.some(function (s) { return !isValidName(s); })) {\n        // We have to fall back to a map.\n        return Type.forSchema({\n          type: 'map',\n          values: Type.forTypes(fieldNames.map(function (s) {\n            return Type.forValue(val[s], opts);\n          }), opts)\n        }, opts);\n      }\n      return Type.forSchema({\n        type: 'record',\n        fields: fieldNames.map(function (s) {\n          return {name: s, type: Type.forValue(val[s], opts)};\n        })\n      }, opts);\n    default:\n      throw new Error(f('cannot infer type from: %j', val));\n  }\n};\n\nType.forTypes = function (types, opts) {\n  if (!types.length) {\n    throw new Error('no types to combine');\n  }\n  if (types.length === 1) {\n    return types[0]; // Nothing to do.\n  }\n  opts = opts || {};\n\n  // Extract any union types, with special care for wrapped unions (see below).\n  var expanded = [];\n  var numWrappedUnions = 0;\n  var isValidWrappedUnion = true;\n  types.forEach(function (type) {\n    switch (type.typeName) {\n      case 'union:unwrapped':\n        isValidWrappedUnion = false;\n        expanded = expanded.concat(type.types);\n        break;\n      case 'union:wrapped':\n        numWrappedUnions++;\n        expanded = expanded.concat(type.types);\n        break;\n      case 'null':\n        expanded.push(type);\n        break;\n      default:\n        isValidWrappedUnion = false;\n        expanded.push(type);\n    }\n  });\n  if (numWrappedUnions) {\n    if (!isValidWrappedUnion) {\n      // It is only valid to combine wrapped unions when no other type is\n      // present other than wrapped unions and nulls (otherwise the values of\n      // others wouldn't be valid in the resulting union).\n      throw new Error('cannot combine wrapped union');\n    }\n    var branchTypes = {};\n    expanded.forEach(function (type) {\n      var name = type.branchName;\n      var branchType = branchTypes[name];\n      if (!branchType) {\n        branchTypes[name] = type;\n      } else if (!type.equals(branchType)) {\n        throw new Error('inconsistent branch type');\n      }\n    });\n    var wrapUnions = opts.wrapUnions;\n    var unionType;\n    opts.wrapUnions = true;\n    try {\n      unionType = Type.forSchema(Object.keys(branchTypes).map(function (name) {\n        return branchTypes[name];\n      }), opts);\n    } catch (err) {\n      opts.wrapUnions = wrapUnions;\n      throw err;\n    }\n    opts.wrapUnions = wrapUnions;\n    return unionType;\n  }\n\n  // Group types by category, similar to the logic for unwrapped unions.\n  var bucketized = {};\n  expanded.forEach(function (type) {\n    var bucket = getTypeBucket(type);\n    var bucketTypes = bucketized[bucket];\n    if (!bucketTypes) {\n      bucketized[bucket] = bucketTypes = [];\n    }\n    bucketTypes.push(type);\n  });\n\n  // Generate the \"augmented\" type for each group.\n  var buckets = Object.keys(bucketized);\n  var augmented = buckets.map(function (bucket) {\n    var bucketTypes = bucketized[bucket];\n    if (bucketTypes.length === 1) {\n      return bucketTypes[0];\n    } else {\n      switch (bucket) {\n        case 'null':\n        case 'boolean':\n          return bucketTypes[0];\n        case 'number':\n          return combineNumbers(bucketTypes);\n        case 'string':\n          return combineStrings(bucketTypes, opts);\n        case 'buffer':\n          return combineBuffers(bucketTypes, opts);\n        case 'array':\n          // Remove any sentinel arrays (used when inferring from empty arrays)\n          // to avoid making things nullable when they shouldn't be.\n          bucketTypes = bucketTypes.filter(function (t) {\n            return t !== opts.emptyArrayType;\n          });\n          if (!bucketTypes.length) {\n            // We still don't have a real type, just return the sentinel.\n            return opts.emptyArrayType;\n          }\n          return Type.forSchema({\n            type: 'array',\n            items: Type.forTypes(bucketTypes.map(function (t) {\n              return t.itemsType;\n            }))\n          }, opts);\n        default:\n          return combineObjects(bucketTypes, opts);\n      }\n    }\n  });\n\n  if (augmented.length === 1) {\n    return augmented[0];\n  } else {\n    // We return an (unwrapped) union of all augmented types.\n    return Type.forSchema(augmented, opts);\n  }\n};\n\nType.isType = function (/* any, [prefix] ... */) {\n  var l = arguments.length;\n  if (!l) {\n    return false;\n  }\n\n  var any = arguments[0];\n  if (\n    !any ||\n    typeof any._update != 'function' ||\n    typeof any.fingerprint != 'function'\n  ) {\n    // Not fool-proof, but most likely good enough.\n    return false;\n  }\n\n  if (l === 1) {\n    // No type names specified, we are done.\n    return true;\n  }\n\n  // We check if at least one of the prefixes matches.\n  var typeName = any.typeName;\n  var i;\n  for (i = 1; i < l; i++) {\n    if (typeName.indexOf(arguments[i]) === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\nType.__reset = function (size) {\n  debug('resetting type buffer to %d', size);\n  TAP.buf = new buffer.SlowBuffer(size);\n};\n\nObject.defineProperty(Type.prototype, 'branchName', {\n  enumerable: true,\n  get: function () {\n    if (this.name) {\n      return this.name;\n    }\n    var type = Type.isType(this, 'logical') ? this.underlyingType : this;\n    if (Type.isType(type, 'abstract')) {\n      return type._concreteTypeName;\n    }\n    return Type.isType(type, 'union') ? undefined : type.typeName;\n  }\n});\n\nType.prototype.clone = function (val, opts) {\n  if (opts) {\n    opts = {\n      coerce: !!opts.coerceBuffers | 0, // Coerce JSON to Buffer.\n      fieldHook: opts.fieldHook,\n      qualifyNames: !!opts.qualifyNames,\n      skip: !!opts.skipMissingFields,\n      wrap: !!opts.wrapUnions | 0 // Wrap first match into union.\n    };\n    return this._copy(val, opts);\n  } else {\n    // If no modifications are required, we can get by with a serialization\n    // roundtrip (generally much faster than a standard deep copy).\n    return this.fromBuffer(this.toBuffer(val));\n  }\n};\n\nType.prototype.compare = utils.abstractFunction;\n\nType.prototype.compareBuffers = function (buf1, buf2) {\n  return this._match(new Tap(buf1), new Tap(buf2));\n};\n\nType.prototype.createResolver = function (type, opts) {\n  if (!Type.isType(type)) {\n    // More explicit error message than the \"incompatible type\" thrown\n    // otherwise (especially because of the overridden `toJSON` method).\n    throw new Error(f('not a type: %j', type));\n  }\n\n  if (!Type.isType(this, 'union', 'logical') && Type.isType(type, 'logical')) {\n    // Trying to read a logical type as a built-in: unwrap the logical type.\n    // Note that we exclude unions to support resolving into unions containing\n    // logical types.\n    return this.createResolver(type.underlyingType, opts);\n  }\n\n  opts = opts || {};\n  opts.registry = opts.registry || {};\n\n  var resolver, key;\n  if (\n    Type.isType(this, 'record', 'error') &&\n    Type.isType(type, 'record', 'error')\n  ) {\n    // We allow conversions between records and errors.\n    key = this.name + ':' + type.name; // ':' is illegal in Avro type names.\n    resolver = opts.registry[key];\n    if (resolver) {\n      return resolver;\n    }\n  }\n\n  resolver = new Resolver(this);\n  if (key) { // Register resolver early for recursive schemas.\n    opts.registry[key] = resolver;\n  }\n\n  if (Type.isType(type, 'union')) {\n    var resolvers = type.types.map(function (t) {\n      return this.createResolver(t, opts);\n    }, this);\n    resolver._read = function (tap) {\n      var index = tap.readLong();\n      var resolver = resolvers[index];\n      if (resolver === undefined) {\n        throw new Error(f('invalid union index: %s', index));\n      }\n      return resolvers[index]._read(tap);\n    };\n  } else {\n    this._update(resolver, type, opts);\n  }\n\n  if (!resolver._read) {\n    throw new Error(f('cannot read %s as %s', type, this));\n  }\n  return Object.freeze(resolver);\n};\n\nType.prototype.decode = function (buf, pos, resolver) {\n  var tap = new Tap(buf, pos);\n  var val = readValue(this, tap, resolver);\n  if (!tap.isValid()) {\n    return {value: undefined, offset: -1};\n  }\n  return {value: val, offset: tap.pos};\n};\n\nType.prototype.encode = function (val, buf, pos) {\n  var tap = new Tap(buf, pos);\n  this._write(tap, val);\n  if (!tap.isValid()) {\n    // Don't throw as there is no way to predict this. We also return the\n    // number of missing bytes to ease resizing.\n    return buf.length - tap.pos;\n  }\n  return tap.pos;\n};\n\nType.prototype.equals = function (type) {\n  return (\n    Type.isType(type) &&\n    this.fingerprint().equals(type.fingerprint())\n  );\n};\n\nType.prototype.fingerprint = function (algorithm) {\n  if (!algorithm) {\n    if (!this._hash.str) {\n      var schemaStr = JSON.stringify(this.schema());\n      this._hash.str = utils.getHash(schemaStr).toString('binary');\n    }\n    return utils.bufferFrom(this._hash.str, 'binary');\n  } else {\n    return utils.getHash(JSON.stringify(this.schema()), algorithm);\n  }\n};\n\nType.prototype.fromBuffer = function (buf, resolver, noCheck) {\n  var tap = new Tap(buf);\n  var val = readValue(this, tap, resolver, noCheck);\n  if (!tap.isValid()) {\n    throw new Error('truncated buffer');\n  }\n  if (!noCheck && tap.pos < buf.length) {\n    throw new Error('trailing data');\n  }\n  return val;\n};\n\nType.prototype.fromString = function (str) {\n  return this._copy(JSON.parse(str), {coerce: 2});\n};\n\nType.prototype.inspect = function () {\n  var typeName = this.typeName;\n  var className = getClassName(typeName);\n  if (isPrimitive(typeName)) {\n    // The class name is sufficient to identify the type.\n    return f('<%s>', className);\n  } else {\n    // We add a little metadata for convenience.\n    var obj = this.schema({exportAttrs: true, noDeref: true});\n    if (typeof obj == 'object' && !Type.isType(this, 'logical')) {\n      obj.type = undefined; // Would be redundant with constructor name.\n    }\n    return f('<%s %j>', className, obj);\n  }\n};\n\nType.prototype.isValid = function (val, opts) {\n  // We only have a single flag for now, so no need to complicate things.\n  var flags = (opts && opts.noUndeclaredFields) | 0;\n  var errorHook = opts && opts.errorHook;\n  var hook, path;\n  if (errorHook) {\n    path = [];\n    hook = function (any, type) {\n      errorHook.call(this, path.slice(), any, type, val);\n    };\n  }\n  return this._check(val, flags, hook, path);\n};\n\nType.prototype.random = utils.abstractFunction;\n\nType.prototype.schema = function (opts) {\n  // Copy the options to avoid mutating the original options object when we add\n  // the registry of dereferenced types.\n  return this._attrs({\n    exportAttrs: !!(opts && opts.exportAttrs),\n    noDeref: !!(opts && opts.noDeref)\n  });\n};\n\nType.prototype.toBuffer = function (val) {\n  TAP.pos = 0;\n  this._write(TAP, val);\n  var buf = utils.newBuffer(TAP.pos);\n  if (TAP.isValid()) {\n    TAP.buf.copy(buf, 0, 0, TAP.pos);\n  } else {\n    this._write(new Tap(buf), val);\n  }\n  return buf;\n};\n\nType.prototype.toJSON = function () {\n  // Convenience to allow using `JSON.stringify(type)` to get a type's schema.\n  return this.schema({exportAttrs: true});\n};\n\nType.prototype.toString = function (val) {\n  if (val === undefined) {\n    // Consistent behavior with standard `toString` expectations.\n    return JSON.stringify(this.schema({noDeref: true}));\n  }\n  return JSON.stringify(this._copy(val, {coerce: 3}));\n};\n\nType.prototype.wrap = function (val) {\n  var Branch = this._branchConstructor;\n  return Branch === null ? null : new Branch(val);\n};\n\nType.prototype._attrs = function (opts) {\n  // This function handles a lot of the common logic to schema generation\n  // across types, for example keeping track of which types have already been\n  // de-referenced (i.e. derefed).\n  opts.derefed = opts.derefed || {};\n  var name = this.name;\n  if (name !== undefined) {\n    if (opts.noDeref || opts.derefed[name]) {\n      return name;\n    }\n    opts.derefed[name] = true;\n  }\n  var schema = {};\n  // The order in which we add fields to the `schema` object matters here.\n  // Since JS objects are unordered, this implementation (unfortunately) relies\n  // on engines returning properties in the same order that they are inserted\n  // in. This is not in the JS spec, but can be \"somewhat\" safely assumed (see\n  // http://stackoverflow.com/q/5525795/1062617).\n  if (this.name !== undefined) {\n    schema.name = name;\n  }\n  schema.type = this.typeName;\n  var derefedSchema = this._deref(schema, opts);\n  if (derefedSchema !== undefined) {\n    // We allow the original schema to be overridden (this will happen for\n    // primitive types and logical types).\n    schema = derefedSchema;\n  }\n  if (opts.exportAttrs) {\n    if (this.aliases && this.aliases.length) {\n      schema.aliases = this.aliases;\n    }\n    if (this.doc !== undefined) {\n      schema.doc = this.doc;\n    }\n  }\n  return schema;\n};\n\nType.prototype._createBranchConstructor = function () {\n  // jshint -W054\n  var name = this.branchName;\n  if (name === 'null') {\n    return null;\n  }\n  function ConstructorFunction() {\n    return function Branch$(val) {\n      if (~name.indexOf('.')) {\n        this[`${name}`] = val;\n      } else {\n        this[name] = val;\n      }\n    };\n  }\n  var Branch = ConstructorFunction();\n  Branch.type = this;\n  Branch.prototype.unwrap = function() { return this[`${name}`]; };\n  Branch.prototype.unwrapped = Branch.prototype.unwrap; // Deprecated.\n  return Branch;\n};\n\nType.prototype._peek = function (tap) {\n  var pos = tap.pos;\n  var val = this._read(tap);\n  tap.pos = pos;\n  return val;\n};\n\nType.prototype._check = utils.abstractFunction;\nType.prototype._copy = utils.abstractFunction;\nType.prototype._deref = utils.abstractFunction;\nType.prototype._match = utils.abstractFunction;\nType.prototype._read = utils.abstractFunction;\nType.prototype._skip = utils.abstractFunction;\nType.prototype._update = utils.abstractFunction;\nType.prototype._write = utils.abstractFunction;\n\n// \"Deprecated\" getters (will be explicitly deprecated in 5.1).\n\nType.prototype.getAliases = function () { return this.aliases; };\n\nType.prototype.getFingerprint = Type.prototype.fingerprint;\n\nType.prototype.getName = function (asBranch) {\n  return (this.name || !asBranch) ? this.name : this.branchName;\n};\n\nType.prototype.getSchema = Type.prototype.schema;\n\nType.prototype.getTypeName = function () { return this.typeName; };\n\n// Implementations.\n\n/**\n * Base primitive Avro type.\n *\n * Most of the primitive types share the same cloning and resolution\n * mechanisms, provided by this class. This class also lets us conveniently\n * check whether a type is a primitive using `instanceof`.\n */\nfunction PrimitiveType(noFreeze) {\n  Type.call(this);\n  this._branchConstructor = this._createBranchConstructor();\n  if (!noFreeze) {\n    // Abstract long types can't be frozen at this stage.\n    Object.freeze(this);\n  }\n}\nutil.inherits(PrimitiveType, Type);\n\nPrimitiveType.prototype._update = function (resolver, type) {\n  if (type.typeName === this.typeName) {\n    resolver._read = this._read;\n  }\n};\n\nPrimitiveType.prototype._copy = function (val) {\n  this._check(val, undefined, throwInvalidError);\n  return val;\n};\n\nPrimitiveType.prototype._deref = function () { return this.typeName; };\n\nPrimitiveType.prototype.compare = utils.compare;\n\n/** Nulls. */\nfunction NullType() { PrimitiveType.call(this); }\nutil.inherits(NullType, PrimitiveType);\n\nNullType.prototype._check = function (val, flags, hook) {\n  var b = val === null;\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nNullType.prototype._read = function () { return null; };\n\nNullType.prototype._skip = function () {};\n\nNullType.prototype._write = function (tap, val) {\n  if (val !== null) {\n    throwInvalidError(val, this);\n  }\n};\n\nNullType.prototype._match = function () { return 0; };\n\nNullType.prototype.compare = NullType.prototype._match;\n\nNullType.prototype.typeName = 'null';\n\nNullType.prototype.random = NullType.prototype._read;\n\n/** Booleans. */\nfunction BooleanType() { PrimitiveType.call(this); }\nutil.inherits(BooleanType, PrimitiveType);\n\nBooleanType.prototype._check = function (val, flags, hook) {\n  var b = typeof val == 'boolean';\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nBooleanType.prototype._read = function (tap) { return tap.readBoolean(); };\n\nBooleanType.prototype._skip = function (tap) { tap.skipBoolean(); };\n\nBooleanType.prototype._write = function (tap, val) {\n  if (typeof val != 'boolean') {\n    throwInvalidError(val, this);\n  }\n  tap.writeBoolean(val);\n};\n\nBooleanType.prototype._match = function (tap1, tap2) {\n  return tap1.matchBoolean(tap2);\n};\n\nBooleanType.prototype.typeName = 'boolean';\n\nBooleanType.prototype.random = function () { return RANDOM.nextBoolean(); };\n\n/** Integers. */\nfunction IntType() { PrimitiveType.call(this); }\nutil.inherits(IntType, PrimitiveType);\n\nIntType.prototype._check = function (val, flags, hook) {\n  var b = val === (val | 0);\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nIntType.prototype._read = function (tap) { return tap.readInt(); };\n\nIntType.prototype._skip = function (tap) { tap.skipInt(); };\n\nIntType.prototype._write = function (tap, val) {\n  if (val !== (val | 0)) {\n    throwInvalidError(val, this);\n  }\n  tap.writeInt(val);\n};\n\nIntType.prototype._match = function (tap1, tap2) {\n  return tap1.matchInt(tap2);\n};\n\nIntType.prototype.typeName = 'int';\n\nIntType.prototype.random = function () { return RANDOM.nextInt(1000) | 0; };\n\n/**\n * Longs.\n *\n * We can't capture all the range unfortunately since JavaScript represents all\n * numbers internally as `double`s, so the default implementation plays safe\n * and throws rather than potentially silently change the data. See `__with` or\n * `AbstractLongType` below for a way to implement a custom long type.\n */\nfunction LongType() { PrimitiveType.call(this); }\nutil.inherits(LongType, PrimitiveType);\n\nLongType.prototype._check = function (val, flags, hook) {\n  var b = typeof val == 'number' && val % 1 === 0 && isSafeLong(val);\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nLongType.prototype._read = function (tap) {\n  var n = tap.readLong();\n  if (!isSafeLong(n)) {\n    throw new Error('potential precision loss');\n  }\n  return n;\n};\n\nLongType.prototype._skip = function (tap) { tap.skipLong(); };\n\nLongType.prototype._write = function (tap, val) {\n  if (typeof val != 'number' || val % 1 || !isSafeLong(val)) {\n    throwInvalidError(val, this);\n  }\n  tap.writeLong(val);\n};\n\nLongType.prototype._match = function (tap1, tap2) {\n  return tap1.matchLong(tap2);\n};\n\nLongType.prototype._update = function (resolver, type) {\n  switch (type.typeName) {\n    case 'int':\n      resolver._read = type._read;\n      break;\n    case 'abstract:long':\n    case 'long':\n      resolver._read = this._read; // In case `type` is an `AbstractLongType`.\n  }\n};\n\nLongType.prototype.typeName = 'long';\n\nLongType.prototype.random = function () { return RANDOM.nextInt(); };\n\nLongType.__with = function (methods, noUnpack) {\n  methods = methods || {}; // Will give a more helpful error message.\n  // We map some of the methods to a different name to be able to intercept\n  // their input and output (otherwise we wouldn't be able to perform any\n  // unpacking logic, and the type wouldn't work when nested).\n  var mapping = {\n    toBuffer: '_toBuffer',\n    fromBuffer: '_fromBuffer',\n    fromJSON: '_fromJSON',\n    toJSON: '_toJSON',\n    isValid: '_isValid',\n    compare: 'compare'\n  };\n  var type = new AbstractLongType(noUnpack);\n  Object.keys(mapping).forEach(function (name) {\n    if (methods[name] === undefined) {\n      throw new Error(f('missing method implementation: %s', name));\n    }\n    type[mapping[name]] = methods[name];\n  });\n  return Object.freeze(type);\n};\n\n/** Floats. */\nfunction FloatType() { PrimitiveType.call(this); }\nutil.inherits(FloatType, PrimitiveType);\n\nFloatType.prototype._check = function (val, flags, hook) {\n  var b = typeof val == 'number';\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nFloatType.prototype._read = function (tap) { return tap.readFloat(); };\n\nFloatType.prototype._skip = function (tap) { tap.skipFloat(); };\n\nFloatType.prototype._write = function (tap, val) {\n  if (typeof val != 'number') {\n    throwInvalidError(val, this);\n  }\n  tap.writeFloat(val);\n};\n\nFloatType.prototype._match = function (tap1, tap2) {\n  return tap1.matchFloat(tap2);\n};\n\nFloatType.prototype._update = function (resolver, type) {\n  switch (type.typeName) {\n    case 'float':\n    case 'int':\n      resolver._read = type._read;\n      break;\n    case 'abstract:long':\n    case 'long':\n      // No need to worry about precision loss here since we're always rounding\n      // to float anyway.\n      resolver._read = function (tap) { return tap.readLong(); };\n  }\n};\n\nFloatType.prototype.typeName = 'float';\n\nFloatType.prototype.random = function () { return RANDOM.nextFloat(1e3); };\n\n/** Doubles. */\nfunction DoubleType() { PrimitiveType.call(this); }\nutil.inherits(DoubleType, PrimitiveType);\n\nDoubleType.prototype._check = function (val, flags, hook) {\n  var b = typeof val == 'number';\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nDoubleType.prototype._read = function (tap) { return tap.readDouble(); };\n\nDoubleType.prototype._skip = function (tap) { tap.skipDouble(); };\n\nDoubleType.prototype._write = function (tap, val) {\n  if (typeof val != 'number') {\n    throwInvalidError(val, this);\n  }\n  tap.writeDouble(val);\n};\n\nDoubleType.prototype._match = function (tap1, tap2) {\n  return tap1.matchDouble(tap2);\n};\n\nDoubleType.prototype._update = function (resolver, type) {\n  switch (type.typeName) {\n    case 'double':\n    case 'float':\n    case 'int':\n      resolver._read = type._read;\n      break;\n    case 'abstract:long':\n    case 'long':\n      // Similar to inside `FloatType`, no need to worry about precision loss\n      // here since we're always rounding to double anyway.\n      resolver._read = function (tap) { return tap.readLong(); };\n  }\n};\n\nDoubleType.prototype.typeName = 'double';\n\nDoubleType.prototype.random = function () { return RANDOM.nextFloat(); };\n\n/** Strings. */\nfunction StringType() { PrimitiveType.call(this); }\nutil.inherits(StringType, PrimitiveType);\n\nStringType.prototype._check = function (val, flags, hook) {\n  var b = typeof val == 'string';\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nStringType.prototype._read = function (tap) { return tap.readString(); };\n\nStringType.prototype._skip = function (tap) { tap.skipString(); };\n\nStringType.prototype._write = function (tap, val) {\n  if (typeof val != 'string') {\n    throwInvalidError(val, this);\n  }\n  tap.writeString(val);\n};\n\nStringType.prototype._match = function (tap1, tap2) {\n  return tap1.matchString(tap2);\n};\n\nStringType.prototype._update = function (resolver, type) {\n  switch (type.typeName) {\n    case 'bytes':\n    case 'string':\n      resolver._read = this._read;\n  }\n};\n\nStringType.prototype.typeName = 'string';\n\nStringType.prototype.random = function () {\n  return RANDOM.nextString(RANDOM.nextInt(32));\n};\n\n/**\n * Bytes.\n *\n * These are represented in memory as `Buffer`s rather than binary-encoded\n * strings. This is more efficient (when decoding/encoding from bytes, the\n * common use-case), idiomatic, and convenient.\n *\n * Note the coercion in `_copy`.\n */\nfunction BytesType() { PrimitiveType.call(this); }\nutil.inherits(BytesType, PrimitiveType);\n\nBytesType.prototype._check = function (val, flags, hook) {\n  var b = Buffer.isBuffer(val);\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nBytesType.prototype._read = function (tap) { return tap.readBytes(); };\n\nBytesType.prototype._skip = function (tap) { tap.skipBytes(); };\n\nBytesType.prototype._write = function (tap, val) {\n  if (!Buffer.isBuffer(val)) {\n    throwInvalidError(val, this);\n  }\n  tap.writeBytes(val);\n};\n\nBytesType.prototype._match = function (tap1, tap2) {\n  return tap1.matchBytes(tap2);\n};\n\nBytesType.prototype._update = StringType.prototype._update;\n\nBytesType.prototype._copy = function (obj, opts) {\n  var buf;\n  switch ((opts && opts.coerce) | 0) {\n    case 3: // Coerce buffers to strings.\n      this._check(obj, undefined, throwInvalidError);\n      return obj.toString('binary');\n    case 2: // Coerce strings to buffers.\n      if (typeof obj != 'string') {\n        throw new Error(f('cannot coerce to buffer: %j', obj));\n      }\n      buf = utils.bufferFrom(obj, 'binary');\n      this._check(buf, undefined, throwInvalidError);\n      return buf;\n    case 1: // Coerce buffer JSON representation to buffers.\n      if (!isJsonBuffer(obj)) {\n        throw new Error(f('cannot coerce to buffer: %j', obj));\n      }\n      buf = utils.bufferFrom(obj.data);\n      this._check(buf, undefined, throwInvalidError);\n      return buf;\n    default: // Copy buffer.\n      this._check(obj, undefined, throwInvalidError);\n      return utils.bufferFrom(obj);\n  }\n};\n\nBytesType.prototype.compare = Buffer.compare;\n\nBytesType.prototype.typeName = 'bytes';\n\nBytesType.prototype.random = function () {\n  return RANDOM.nextBuffer(RANDOM.nextInt(32));\n};\n\n/** Base \"abstract\" Avro union type. */\nfunction UnionType(schema, opts) {\n  Type.call(this);\n\n  if (!Array.isArray(schema)) {\n    throw new Error(f('non-array union schema: %j', schema));\n  }\n  if (!schema.length) {\n    throw new Error('empty union');\n  }\n  this.types = Object.freeze(schema.map(function (obj) {\n    return Type.forSchema(obj, opts);\n  }));\n\n  this._branchIndices = {};\n  this.types.forEach(function (type, i) {\n    if (Type.isType(type, 'union')) {\n      throw new Error('unions cannot be directly nested');\n    }\n    var branch = type.branchName;\n    if (this._branchIndices[branch] !== undefined) {\n      throw new Error(f('duplicate union branch name: %j', branch));\n    }\n    this._branchIndices[branch] = i;\n  }, this);\n}\nutil.inherits(UnionType, Type);\n\nUnionType.prototype._branchConstructor = function () {\n  throw new Error('unions cannot be directly wrapped');\n};\n\nUnionType.prototype._skip = function (tap) {\n  this.types[tap.readLong()]._skip(tap);\n};\n\nUnionType.prototype._match = function (tap1, tap2) {\n  var n1 = tap1.readLong();\n  var n2 = tap2.readLong();\n  if (n1 === n2) {\n    return this.types[n1]._match(tap1, tap2);\n  } else {\n    return n1 < n2 ? -1 : 1;\n  }\n};\n\nUnionType.prototype._deref = function (schema, opts) {\n  return this.types.map(function (t) { return t._attrs(opts); });\n};\n\nUnionType.prototype.getTypes = function () { return this.types; };\n\n/**\n * \"Natural\" union type.\n *\n * This representation doesn't require a wrapping object and is therefore\n * simpler and generally closer to what users expect. However it cannot be used\n * to represent all Avro unions since some lead to ambiguities (e.g. if two\n * number types are in the union).\n *\n * Currently, this union supports at most one type in each of the categories\n * below:\n *\n * + `null`\n * + `boolean`\n * + `int`, `long`, `float`, `double`\n * + `string`, `enum`\n * + `bytes`, `fixed`\n * + `array`\n * + `map`, `record`\n */\nfunction UnwrappedUnionType(schema, opts) {\n  UnionType.call(this, schema, opts);\n\n  this._dynamicBranches = null;\n  this._bucketIndices = {};\n  this.types.forEach(function (type, index) {\n    if (Type.isType(type, 'abstract', 'logical')) {\n      if (!this._dynamicBranches) {\n        this._dynamicBranches = [];\n      }\n      this._dynamicBranches.push({index: index, type: type});\n    } else {\n      var bucket = getTypeBucket(type);\n      if (this._bucketIndices[bucket] !== undefined) {\n        throw new Error(f('ambiguous unwrapped union: %j', this));\n      }\n      this._bucketIndices[bucket] = index;\n    }\n  }, this);\n\n  Object.freeze(this);\n}\nutil.inherits(UnwrappedUnionType, UnionType);\n\nUnwrappedUnionType.prototype._getIndex = function (val) {\n  var index = this._bucketIndices[getValueBucket(val)];\n  if (this._dynamicBranches) {\n    // Slower path, we must run the value through all branches.\n    index = this._getBranchIndex(val, index);\n  }\n  return index;\n};\n\nUnwrappedUnionType.prototype._getBranchIndex = function (any, index) {\n  var logicalBranches = this._dynamicBranches;\n  var i, l, branch;\n  for (i = 0, l = logicalBranches.length; i < l; i++) {\n    branch = logicalBranches[i];\n    if (branch.type._check(any)) {\n      if (index === undefined) {\n        index = branch.index;\n      } else {\n        // More than one branch matches the value so we aren't guaranteed to\n        // infer the correct type. We throw rather than corrupt data. This can\n        // be fixed by \"tightening\" the logical types.\n        throw new Error('ambiguous conversion');\n      }\n    }\n  }\n  return index;\n};\n\nUnwrappedUnionType.prototype._check = function (val, flags, hook, path) {\n  var index = this._getIndex(val);\n  var b = index !== undefined;\n  if (b) {\n    return this.types[index]._check(val, flags, hook, path);\n  }\n  if (hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nUnwrappedUnionType.prototype._read = function (tap) {\n  var index = tap.readLong();\n  var branchType = this.types[index];\n  if (branchType) {\n    return branchType._read(tap);\n  } else {\n    throw new Error(f('invalid union index: %s', index));\n  }\n};\n\nUnwrappedUnionType.prototype._write = function (tap, val) {\n  var index = this._getIndex(val);\n  if (index === undefined) {\n    throwInvalidError(val, this);\n  }\n  tap.writeLong(index);\n  if (val !== null) {\n    this.types[index]._write(tap, val);\n  }\n};\n\nUnwrappedUnionType.prototype._update = function (resolver, type, opts) {\n  // jshint -W083\n  // (The loop exits after the first function is created.)\n  var i, l, typeResolver;\n  for (i = 0, l = this.types.length; i < l; i++) {\n    try {\n      typeResolver = this.types[i].createResolver(type, opts);\n    } catch (err) {\n      continue;\n    }\n    resolver._read = function (tap) { return typeResolver._read(tap); };\n    return;\n  }\n};\n\nUnwrappedUnionType.prototype._copy = function (val, opts) {\n  var coerce = opts && opts.coerce | 0;\n  var wrap = opts && opts.wrap | 0;\n  var index;\n  if (wrap === 2) {\n    // We are parsing a default, so always use the first branch's type.\n    index = 0;\n  } else {\n    switch (coerce) {\n      case 1:\n        // Using the `coerceBuffers` option can cause corruption and erroneous\n        // failures with unwrapped unions (in rare cases when the union also\n        // contains a record which matches a buffer's JSON representation).\n        if (isJsonBuffer(val) && this._bucketIndices.buffer !== undefined) {\n          index = this._bucketIndices.buffer;\n        } else {\n          index = this._getIndex(val);\n        }\n        break;\n      case 2:\n        // Decoding from JSON, we must unwrap the value.\n        if (val === null) {\n          index = this._bucketIndices['null'];\n        } else if (typeof val === 'object') {\n          var keys = Object.keys(val);\n          if (keys.length === 1) {\n            index = this._branchIndices[keys[0]];\n            val = val[keys[0]];\n          }\n        }\n        break;\n      default:\n        index = this._getIndex(val);\n    }\n    if (index === undefined) {\n      throwInvalidError(val, this);\n    }\n  }\n  var type = this.types[index];\n  if (val === null || wrap === 3) {\n    return type._copy(val, opts);\n  } else {\n    switch (coerce) {\n      case 3:\n        // Encoding to JSON, we wrap the value.\n        var obj = {};\n        obj[type.branchName] = type._copy(val, opts);\n        return obj;\n      default:\n        return type._copy(val, opts);\n    }\n  }\n};\n\nUnwrappedUnionType.prototype.compare = function (val1, val2) {\n  var index1 = this._getIndex(val1);\n  var index2 = this._getIndex(val2);\n  if (index1 === undefined) {\n    throwInvalidError(val1, this);\n  } else if (index2 === undefined) {\n    throwInvalidError(val2, this);\n  } else if (index1 === index2) {\n    return this.types[index1].compare(val1, val2);\n  } else {\n    return utils.compare(index1, index2);\n  }\n};\n\nUnwrappedUnionType.prototype.typeName = 'union:unwrapped';\n\nUnwrappedUnionType.prototype.random = function () {\n  var index = RANDOM.nextInt(this.types.length);\n  return this.types[index].random();\n};\n\n/**\n * Compatible union type.\n *\n * Values of this type are represented in memory similarly to their JSON\n * representation (i.e. inside an object with single key the name of the\n * contained type).\n *\n * This is not ideal, but is the most efficient way to unambiguously support\n * all unions. Here are a few reasons why the wrapping object is necessary:\n *\n * + Unions with multiple number types would have undefined behavior, unless\n *   numbers are wrapped (either everywhere, leading to large performance and\n *   convenience costs; or only when necessary inside unions, making it hard to\n *   understand when numbers are wrapped or not).\n * + Fixed types would have to be wrapped to be distinguished from bytes.\n * + Using record's constructor names would work (after a slight change to use\n *   the fully qualified name), but would mean that generic objects could no\n *   longer be valid records (making it inconvenient to do simple things like\n *   creating new records).\n */\nfunction WrappedUnionType(schema, opts) {\n  UnionType.call(this, schema, opts);\n  Object.freeze(this);\n}\nutil.inherits(WrappedUnionType, UnionType);\n\nWrappedUnionType.prototype._check = function (val, flags, hook, path) {\n  var b = false;\n  if (val === null) {\n    // Shortcut type lookup in this case.\n    b = this._branchIndices['null'] !== undefined;\n  } else if (typeof val == 'object') {\n    var keys = Object.keys(val);\n    if (keys.length === 1) {\n      // We require a single key here to ensure that writes are correct and\n      // efficient as soon as a record passes this check.\n      var name = keys[0];\n      var index = this._branchIndices[name];\n      if (index !== undefined) {\n        if (hook) {\n          // Slow path.\n          path.push(name);\n          b = this.types[index]._check(val[name], flags, hook, path);\n          path.pop();\n          return b;\n        } else {\n          return this.types[index]._check(val[name], flags);\n        }\n      }\n    }\n  }\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nWrappedUnionType.prototype._read = function (tap) {\n  var type = this.types[tap.readLong()];\n  if (!type) {\n    throw new Error(f('invalid union index'));\n  }\n  var Branch = type._branchConstructor;\n  if (Branch === null) {\n    return null;\n  } else {\n    return new Branch(type._read(tap));\n  }\n};\n\nWrappedUnionType.prototype._write = function (tap, val) {\n  var index, keys, name;\n  if (val === null) {\n    index = this._branchIndices['null'];\n    if (index === undefined) {\n      throwInvalidError(val, this);\n    }\n    tap.writeLong(index);\n  } else {\n    keys = Object.keys(val);\n    if (keys.length === 1) {\n      name = keys[0];\n      index = this._branchIndices[name];\n    }\n    if (index === undefined) {\n      throwInvalidError(val, this);\n    }\n    tap.writeLong(index);\n    this.types[index]._write(tap, val[name]);\n  }\n};\n\nWrappedUnionType.prototype._update = function (resolver, type, opts) {\n  // jshint -W083\n  // (The loop exits after the first function is created.)\n  var i, l, typeResolver, Branch;\n  for (i = 0, l = this.types.length; i < l; i++) {\n    try {\n      typeResolver = this.types[i].createResolver(type, opts);\n    } catch (err) {\n      continue;\n    }\n    Branch = this.types[i]._branchConstructor;\n    if (Branch) {\n      resolver._read = function (tap) {\n        return new Branch(typeResolver._read(tap));\n      };\n    } else {\n      resolver._read = function () { return null; };\n    }\n    return;\n  }\n};\n\nWrappedUnionType.prototype._copy = function (val, opts) {\n  var wrap = opts && opts.wrap | 0;\n  if (wrap === 2) {\n    var firstType = this.types[0];\n    // Promote into first type (used for schema defaults).\n    if (val === null && firstType.typeName === 'null') {\n      return null;\n    }\n    return new firstType._branchConstructor(firstType._copy(val, opts));\n  }\n  if (val === null && this._branchIndices['null'] !== undefined) {\n    return null;\n  }\n\n  var i, l, obj;\n  if (typeof val == 'object') {\n    var keys = Object.keys(val);\n    if (keys.length === 1) {\n      var name = keys[0];\n      i = this._branchIndices[name];\n      if (i === undefined && opts.qualifyNames) {\n        // We are a bit more flexible than in `_check` here since we have\n        // to deal with other serializers being less strict, so we fall\n        // back to looking up unqualified names.\n        var j, type;\n        for (j = 0, l = this.types.length; j < l; j++) {\n          type = this.types[j];\n          if (type.name && name === unqualify(type.name)) {\n            i = j;\n            break;\n          }\n        }\n      }\n      if (i !== undefined) {\n        obj = this.types[i]._copy(val[name], opts);\n      }\n    }\n  }\n  if (wrap === 1 && obj === undefined) {\n    // Try promoting into first match (convenience, slow).\n    i = 0;\n    l = this.types.length;\n    while (i < l && obj === undefined) {\n      try {\n        obj = this.types[i]._copy(val, opts);\n      } catch (err) {\n        i++;\n      }\n    }\n  }\n  if (obj !== undefined) {\n    return wrap === 3 ? obj : new this.types[i]._branchConstructor(obj);\n  }\n  throwInvalidError(val, this);\n};\n\nWrappedUnionType.prototype.compare = function (val1, val2) {\n  var name1 = val1 === null ? 'null' : Object.keys(val1)[0];\n  var name2 = val2 === null ? 'null' : Object.keys(val2)[0];\n  var index = this._branchIndices[name1];\n  if (name1 === name2) {\n    return name1 === 'null' ?\n      0 :\n      this.types[index].compare(val1[name1], val2[name1]);\n  } else {\n    return utils.compare(index, this._branchIndices[name2]);\n  }\n};\n\nWrappedUnionType.prototype.typeName = 'union:wrapped';\n\nWrappedUnionType.prototype.random = function () {\n  var index = RANDOM.nextInt(this.types.length);\n  var type = this.types[index];\n  var Branch = type._branchConstructor;\n  if (!Branch) {\n    return null;\n  }\n  return new Branch(type.random());\n};\n\n/**\n * Avro enum type.\n *\n * Represented as strings (with allowed values from the set of symbols). Using\n * integers would be a reasonable option, but the performance boost is arguably\n * offset by the legibility cost and the extra deviation from the JSON encoding\n * convention.\n *\n * An integer representation can still be used (e.g. for compatibility with\n * TypeScript `enum`s) by overriding the `EnumType` with a `LongType` (e.g. via\n * `parse`'s registry).\n */\nfunction EnumType(schema, opts) {\n  Type.call(this, schema, opts);\n  if (!Array.isArray(schema.symbols) || !schema.symbols.length) {\n    throw new Error(f('invalid enum symbols: %j', schema.symbols));\n  }\n  this.symbols = Object.freeze(schema.symbols.slice());\n  this._indices = {};\n  this.symbols.forEach(function (symbol, i) {\n    if (!isValidName(symbol)) {\n      throw new Error(f('invalid %s symbol: %j', this, symbol));\n    }\n    if (this._indices[symbol] !== undefined) {\n      throw new Error(f('duplicate %s symbol: %j', this, symbol));\n    }\n    this._indices[symbol] = i;\n  }, this);\n  this._branchConstructor = this._createBranchConstructor();\n  Object.freeze(this);\n}\nutil.inherits(EnumType, Type);\n\nEnumType.prototype._check = function (val, flags, hook) {\n  var b = this._indices[val] !== undefined;\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nEnumType.prototype._read = function (tap) {\n  var index = tap.readLong();\n  var symbol = this.symbols[index];\n  if (symbol === undefined) {\n    throw new Error(f('invalid %s enum index: %s', this.name, index));\n  }\n  return symbol;\n};\n\nEnumType.prototype._skip = function (tap) { tap.skipLong(); };\n\nEnumType.prototype._write = function (tap, val) {\n  var index = this._indices[val];\n  if (index === undefined) {\n    throwInvalidError(val, this);\n  }\n  tap.writeLong(index);\n};\n\nEnumType.prototype._match = function (tap1, tap2) {\n  return tap1.matchLong(tap2);\n};\n\nEnumType.prototype.compare = function (val1, val2) {\n  return utils.compare(this._indices[val1], this._indices[val2]);\n};\n\nEnumType.prototype._update = function (resolver, type) {\n  var symbols = this.symbols;\n  if (\n    type.typeName === 'enum' &&\n    (!type.name || ~getAliases(this).indexOf(type.name)) &&\n    type.symbols.every(function (s) { return ~symbols.indexOf(s); })\n  ) {\n    resolver.symbols = type.symbols;\n    resolver._read = type._read;\n  }\n};\n\nEnumType.prototype._copy = function (val) {\n  this._check(val, undefined, throwInvalidError);\n  return val;\n};\n\nEnumType.prototype._deref = function (schema) {\n  schema.symbols = this.symbols;\n};\n\nEnumType.prototype.getSymbols = function () { return this.symbols; };\n\nEnumType.prototype.typeName = 'enum';\n\nEnumType.prototype.random = function () {\n  return RANDOM.choice(this.symbols);\n};\n\n/** Avro fixed type. Represented simply as a `Buffer`. */\nfunction FixedType(schema, opts) {\n  Type.call(this, schema, opts);\n  if (schema.size !== (schema.size | 0) || schema.size < 1) {\n    throw new Error(f('invalid %s size', this.branchName));\n  }\n  this.size = schema.size | 0;\n  this._branchConstructor = this._createBranchConstructor();\n  Object.freeze(this);\n}\nutil.inherits(FixedType, Type);\n\nFixedType.prototype._check = function (val, flags, hook) {\n  var b = Buffer.isBuffer(val) && val.length === this.size;\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nFixedType.prototype._read = function (tap) {\n  return tap.readFixed(this.size);\n};\n\nFixedType.prototype._skip = function (tap) {\n  tap.skipFixed(this.size);\n};\n\nFixedType.prototype._write = function (tap, val) {\n  if (!Buffer.isBuffer(val) || val.length !== this.size) {\n    throwInvalidError(val, this);\n  }\n  tap.writeFixed(val, this.size);\n};\n\nFixedType.prototype._match = function (tap1, tap2) {\n  return tap1.matchFixed(tap2, this.size);\n};\n\nFixedType.prototype.compare = Buffer.compare;\n\nFixedType.prototype._update = function (resolver, type) {\n  if (\n    type.typeName === 'fixed' &&\n    this.size === type.size &&\n    (!type.name || ~getAliases(this).indexOf(type.name))\n  ) {\n    resolver.size = this.size;\n    resolver._read = this._read;\n  }\n};\n\nFixedType.prototype._copy = BytesType.prototype._copy;\n\nFixedType.prototype._deref = function (schema) { schema.size = this.size; };\n\nFixedType.prototype.getSize = function () { return this.size; };\n\nFixedType.prototype.typeName = 'fixed';\n\nFixedType.prototype.random = function () {\n  return RANDOM.nextBuffer(this.size);\n};\n\n/** Avro map. Represented as vanilla objects. */\nfunction MapType(schema, opts) {\n  Type.call(this);\n  if (!schema.values) {\n    throw new Error(f('missing map values: %j', schema));\n  }\n  this.valuesType = Type.forSchema(schema.values, opts);\n  this._branchConstructor = this._createBranchConstructor();\n  Object.freeze(this);\n}\nutil.inherits(MapType, Type);\n\nMapType.prototype._check = function (val, flags, hook, path) {\n  if (!val || typeof val != 'object' || Array.isArray(val)) {\n    if (hook) {\n      hook(val, this);\n    }\n    return false;\n  }\n\n  var keys = Object.keys(val);\n  var b = true;\n  var i, l, j, key;\n  if (hook) {\n    // Slow path.\n    j = path.length;\n    path.push('');\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = path[j] = keys[i];\n      if (!this.valuesType._check(val[key], flags, hook, path)) {\n        b = false;\n      }\n    }\n    path.pop();\n  } else {\n    for (i = 0, l = keys.length; i < l; i++) {\n      if (!this.valuesType._check(val[keys[i]], flags)) {\n        return false;\n      }\n    }\n  }\n  return b;\n};\n\nMapType.prototype._read = function (tap) {\n  var values = this.valuesType;\n  var val = {};\n  var n;\n  while ((n = readArraySize(tap))) {\n    while (n--) {\n      var key = tap.readString();\n      val[key] = values._read(tap);\n    }\n  }\n  return val;\n};\n\nMapType.prototype._skip = function (tap) {\n  var values = this.valuesType;\n  var len, n;\n  while ((n = tap.readLong())) {\n    if (n < 0) {\n      len = tap.readLong();\n      tap.pos += len;\n    } else {\n      while (n--) {\n        tap.skipString();\n        values._skip(tap);\n      }\n    }\n  }\n};\n\nMapType.prototype._write = function (tap, val) {\n  if (!val || typeof val != 'object' || Array.isArray(val)) {\n    throwInvalidError(val, this);\n  }\n\n  var values = this.valuesType;\n  var keys = Object.keys(val);\n  var n = keys.length;\n  var i, key;\n  if (n) {\n    tap.writeLong(n);\n    for (i = 0; i < n; i++) {\n      key = keys[i];\n      tap.writeString(key);\n      values._write(tap, val[key]);\n    }\n  }\n  tap.writeLong(0);\n};\n\nMapType.prototype._match = function () {\n  throw new Error('maps cannot be compared');\n};\n\nMapType.prototype._update = function (rsv, type, opts) {\n  if (type.typeName === 'map') {\n    rsv.valuesType = this.valuesType.createResolver(type.valuesType, opts);\n    rsv._read = this._read;\n  }\n};\n\nMapType.prototype._copy = function (val, opts) {\n  if (val && typeof val == 'object' && !Array.isArray(val)) {\n    var values = this.valuesType;\n    var keys = Object.keys(val);\n    var i, l, key;\n    var copy = {};\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = keys[i];\n      copy[key] = values._copy(val[key], opts);\n    }\n    return copy;\n  }\n  throwInvalidError(val, this);\n};\n\nMapType.prototype.compare = MapType.prototype._match;\n\nMapType.prototype.typeName = 'map';\n\nMapType.prototype.getValuesType = function () { return this.valuesType; };\n\nMapType.prototype.random = function () {\n  var val = {};\n  var i, l;\n  for (i = 0, l = RANDOM.nextInt(10); i < l; i++) {\n    val[RANDOM.nextString(RANDOM.nextInt(20))] = this.valuesType.random();\n  }\n  return val;\n};\n\nMapType.prototype._deref = function (schema, opts) {\n  schema.values = this.valuesType._attrs(opts);\n};\n\n/** Avro array. Represented as vanilla arrays. */\nfunction ArrayType(schema, opts) {\n  Type.call(this);\n  if (!schema.items) {\n    throw new Error(f('missing array items: %j', schema));\n  }\n  this.itemsType = Type.forSchema(schema.items, opts);\n  this._branchConstructor = this._createBranchConstructor();\n  Object.freeze(this);\n}\nutil.inherits(ArrayType, Type);\n\nArrayType.prototype._check = function (val, flags, hook, path) {\n  if (!Array.isArray(val)) {\n    if (hook) {\n      hook(val, this);\n    }\n    return false;\n  }\n\n  var b = true;\n  var i, l, j;\n  if (hook) {\n    // Slow path.\n    j = path.length;\n    path.push('');\n    for (i = 0, l = val.length; i < l; i++) {\n      path[j] = '' + i;\n      if (!this.itemsType._check(val[i], flags, hook, path)) {\n        b = false;\n      }\n    }\n    path.pop();\n  } else {\n    for (i = 0, l = val.length; i < l; i++) {\n      if (!this.itemsType._check(val[i], flags)) {\n        return false;\n      }\n    }\n  }\n  return b;\n};\n\nArrayType.prototype._read = function (tap) {\n  var items = this.itemsType;\n  var val = [];\n  var n;\n  while ((n = tap.readLong())) {\n    if (n < 0) {\n      n = -n;\n      tap.skipLong(); // Skip size.\n    }\n    while (n--) {\n      val.push(items._read(tap));\n    }\n  }\n  return val;\n};\n\nArrayType.prototype._skip = function (tap) {\n  var len, n;\n  while ((n = tap.readLong())) {\n    if (n < 0) {\n      len = tap.readLong();\n      tap.pos += len;\n    } else {\n      while (n--) {\n        this.itemsType._skip(tap);\n      }\n    }\n  }\n};\n\nArrayType.prototype._write = function (tap, val) {\n  if (!Array.isArray(val)) {\n    throwInvalidError(val, this);\n  }\n\n  var n = val.length;\n  var i;\n  if (n) {\n    tap.writeLong(n);\n    for (i = 0; i < n; i++) {\n      this.itemsType._write(tap, val[i]);\n    }\n  }\n  tap.writeLong(0);\n};\n\nArrayType.prototype._match = function (tap1, tap2) {\n  var n1 = tap1.readLong();\n  var n2 = tap2.readLong();\n  var f;\n  while (n1 && n2) {\n    f = this.itemsType._match(tap1, tap2);\n    if (f) {\n      return f;\n    }\n    if (!--n1) {\n      n1 = readArraySize(tap1);\n    }\n    if (!--n2) {\n      n2 = readArraySize(tap2);\n    }\n  }\n  return utils.compare(n1, n2);\n};\n\nArrayType.prototype._update = function (resolver, type, opts) {\n  if (type.typeName === 'array') {\n    resolver.itemsType = this.itemsType.createResolver(type.itemsType, opts);\n    resolver._read = this._read;\n  }\n};\n\nArrayType.prototype._copy = function (val, opts) {\n  if (!Array.isArray(val)) {\n    throwInvalidError(val, this);\n  }\n  var items = new Array(val.length);\n  var i, l;\n  for (i = 0, l = val.length; i < l; i++) {\n    items[i] = this.itemsType._copy(val[i], opts);\n  }\n  return items;\n};\n\nArrayType.prototype._deref = function (schema, opts) {\n  schema.items = this.itemsType._attrs(opts);\n};\n\nArrayType.prototype.compare = function (val1, val2) {\n  var n1 = val1.length;\n  var n2 = val2.length;\n  var i, l, f;\n  for (i = 0, l = Math.min(n1, n2); i < l; i++) {\n    if ((f = this.itemsType.compare(val1[i], val2[i]))) {\n      return f;\n    }\n  }\n  return utils.compare(n1, n2);\n};\n\nArrayType.prototype.getItemsType = function () { return this.itemsType; };\n\nArrayType.prototype.typeName = 'array';\n\nArrayType.prototype.random = function () {\n  var arr = [];\n  var i, l;\n  for (i = 0, l = RANDOM.nextInt(10); i < l; i++) {\n    arr.push(this.itemsType.random());\n  }\n  return arr;\n};\n\n/**\n * Avro record.\n *\n * Values are represented as instances of a programmatically generated\n * constructor (similar to a \"specific record\"), available via the\n * `getRecordConstructor` method. This \"specific record class\" gives\n * significant speedups over using generics objects.\n *\n * Note that vanilla objects are still accepted as valid as long as their\n * fields match (this makes it much more convenient to do simple things like\n * update nested records).\n *\n * This type is also used for errors (similar, except for the extra `Error`\n * constructor call) and for messages (see comment below).\n */\nfunction RecordType(schema, opts) {\n  // Force creation of the options object in case we need to register this\n  // record's name.\n  opts = opts || {};\n\n  // Save the namespace to restore it as we leave this record's scope.\n  var namespace = opts.namespace;\n  if (schema.namespace !== undefined) {\n    opts.namespace = schema.namespace;\n  } else if (schema.name) {\n    // Fully qualified names' namespaces are used when no explicit namespace\n    // attribute was specified.\n    var match = /^(.*)\\.[^.]+$/.exec(schema.name);\n    if (match) {\n      opts.namespace = match[1];\n    }\n  }\n  Type.call(this, schema, opts);\n\n  if (!Array.isArray(schema.fields)) {\n    throw new Error(f('non-array record fields: %j', schema.fields));\n  }\n  if (utils.hasDuplicates(schema.fields, function (f) { return f.name; })) {\n    throw new Error(f('duplicate field name: %j', schema.fields));\n  }\n  this._fieldsByName = {};\n  this.fields = Object.freeze(schema.fields.map(function (f) {\n    var field = new Field(f, opts);\n    this._fieldsByName[field.name] = field;\n    return field;\n  }, this));\n  this._branchConstructor = this._createBranchConstructor();\n  this._isError = schema.type === 'error';\n  this.recordConstructor = this._createConstructor(opts.errorStackTraces);\n  this._read = this._createReader();\n  this._skip = this._createSkipper();\n  this._write = this._createWriter();\n  this._check = this._createChecker();\n\n  opts.namespace = namespace;\n  Object.freeze(this);\n}\nutil.inherits(RecordType, Type);\n\nRecordType.prototype._getConstructorName = function () {\n  return this.name ?\n    unqualify(this.name) :\n    this._isError ? 'Error$' : 'Record$';\n};\n\nRecordType.prototype._createConstructor = function (errorStackTraces) {\n  // jshint -W054\n  var ds = {}; // Defaults.\n  var i, l, field, name, defaultValue, hasDefault, stackField;\n\n  for (i = 0, l = this.fields.length; i < l; i++) {\n    field = this.fields[i];\n    defaultValue = field.defaultValue;\n    hasDefault = defaultValue() !== undefined;\n    name = field.name;\n    if (\n      errorStackTraces && this._isError && name === 'stack' &&\n      Type.isType(field.type, 'string') && !hasDefault\n    ) {\n      // We keep track of whether we've encountered a valid stack field (in\n      // particular, without a default) to populate a stack trace below.\n      stackField = field;\n    }\n    if (hasDefault) {\n      ds[i] = defaultValue;\n    }\n  }\n\n  var self = this;\n  function ConstructorFunction(outerArgs) {\n    const constructorName = self._getConstructorName();\n    var innerFunction = ({\n      [constructorName]: function(...innerArgs) {\n        for(var i = 0, l = self.fields.length; i < l; i++) {\n          let f = self.fields[i];\n          if (f.defaultValue() === undefined) {\n            this[f.name] = innerArgs[i];\n          } else {\n            if (innerArgs[i] === undefined) {\n              this[f.name] = outerArgs[i]();\n            } else {\n              this[f.name] = innerArgs[i];\n            }\n          }\n        }\n        if (stackField) {\n          if (this.stack === undefined) {\n            if (typeof Error.captureStackTrace === 'function') {\n              Error.captureStackTrace(this, this.constructor);\n            } else {\n              this.stack = Error().stack;\n            }\n          }\n        }\n      }\n    })[constructorName];\n    return innerFunction;\n  }\n  var Record = ConstructorFunction(ds);\n  Record.getType = function () { return self; };\n  Record.type = self;\n  if (this._isError) {\n    util.inherits(Record, Error);\n    Record.prototype.name = this._getConstructorName();\n  }\n  Record.prototype.clone = function (o) { return self.clone(this, o); };\n  Record.prototype.compare = function (v) { return self.compare(this, v); };\n  Record.prototype.isValid = function (o) { return self.isValid(this, o); };\n  Record.prototype.toBuffer = function () { return self.toBuffer(this); };\n  Record.prototype.toString = function () { return self.toString(this); };\n  Record.prototype.wrap = function () { return self.wrap(this); };\n  Record.prototype.wrapped = Record.prototype.wrap; // Deprecated.\n  return Record;\n};\n\nRecordType.prototype._createChecker = function () {\n  // jshint -W054\n  const values = [];\n  this.fields.forEach(field => {\n    values.push(field.type);\n  });\n  var self = this;\n  function ConstructorFunction(outerArgs) {\n    var constructorName = self._getConstructorName();\n    var innerFunction = ({\n      [constructorName]: function (v, f, h, p) {\n        if (v === null || typeof v !== 'object' || (f && !this._checkFields(v))) {\n          if (h) {\n            h(v, this);\n          }\n          return false;\n        }\n        const vArray = [];\n        if (!self.fields.length) {\n          return true;\n        } else {\n          for (var i =0, l = self.fields.length; i < l; i++) {\n            let f = self.fields[i];\n            if (f.defaultValue() !== undefined) {\n              vArray.push(v[f.name]);\n            }\n          }\n        }\n        if (h) {\n          var b = 1;\n          var j = p.length;\n          p.push('');\n          for (var i =0, l = self.fields.length; i < l; i++) {\n            let f = self.fields[i];\n            p[j] = f.name;\n            b &= f.defaultValue() === undefined ?\n              outerArgs[i]._check(v[f.name], f, h, p)\n              :\n              vArray[i] === undefined || outerArgs[i]._check(vArray[i], f, h, p);\n          }\n          p.pop();\n          return !!b;\n        } else {\n          return self.fields.reduce((prevVal, currentVal, i) => {\n            return prevVal && (\n              currentVal.defaultValue() === undefined ?\n                outerArgs[i]._check(v[currentVal.name])\n                :\n                vArray[i] === undefined || outerArgs[i]._check(vArray[i], f)\n            );\n          }, true);\n        }\n      }\n    })[constructorName];\n    return innerFunction;\n  }\n  return ConstructorFunction(values);\n};\n\nRecordType.prototype._createReader = function () {\n  // jshint -W054\n  var values = [this.recordConstructor];\n  var i, l;\n  for (i = 0, l = this.fields.length; i < l; i++) {\n    values.push(this.fields[i].type);\n  }\n  var self = this;\n  function ConstructorFunction(outerArgs) {\n    var constructorName = self._getConstructorName();\n    var innerFunction = ({\n      [constructorName]: function (t) {\n        return new outerArgs[0](...outerArgs.slice(1).map(ftype => ftype['_read'](t)));\n      }\n    })[constructorName];\n    return innerFunction;\n  }\n  return ConstructorFunction(values);\n};\n\nRecordType.prototype._createSkipper = function () {\n  // jshint -W054\n  var values = [];\n  this.fields.forEach((field) => {\n    values.push(field.type);\n  });\n  var self = this;\n  function ConstructorFunction(outerArgs) {\n    var constructorName = self._getConstructorName();\n    var innerFunction = ({\n      [constructorName]: function (t) {\n        outerArgs.forEach(arg => arg._skip(t));\n      }\n    })[constructorName];\n    return innerFunction;\n  }\n  return ConstructorFunction(values);\n};\n\nRecordType.prototype._createWriter = function () {\n  // jshint -W054\n  // We still do default handling here, in case a normal JS object is passed.\n\n  var values = [];\n  var dValues = {};\n  this.fields.forEach((field, i) => {\n    values.push(field.type);\n    if (field.defaultValue() !== undefined) {\n      dValues[i] = field.type.toBuffer(field.defaultValue()).toString('binary');\n    }\n  });\n  var self = this;\n  function ConstructorFunction(vv, dv) {\n    var constructorName = self._getConstructorName();\n    var innerFunction = ({\n      [constructorName]: function (t, v) {\n        for (var i=0, l = self.fields.length; i<l; i++) {\n          let f = self.fields[i];\n          if (f.defaultValue() === undefined) {\n            vv[i]._write(t, v[f.name]);\n          } else {\n            if (v[f.name] === undefined) {\n              t.writeBinary(dv[i], dv[i].length);\n            } else {\n              vv[i]._write(t, v[f.name]);\n            }\n          }\n        }\n      }\n    })[constructorName];\n    return innerFunction;\n  }\n  return ConstructorFunction(values, dValues);\n};\n\nRecordType.prototype._update = function (resolver, type, opts) {\n  // jshint -W054\n  if (type.name && !~getAliases(this).indexOf(type.name)) {\n    throw new Error(f('no alias found for %s', type.name));\n  }\n\n  var rFields = this.fields;\n  var wFields = type.fields;\n  var wFieldsMap = utils.toMap(wFields, function (f) { return f.name; });\n  var resolvers = {}; // Resolvers keyed by writer field name.\n  var i, j, field, name, names, matches, fieldResolver;\n  for (i = 0; i < rFields.length; i++) {\n    field = rFields[i];\n    names = getAliases(field);\n    matches = [];\n    for (j = 0; j < names.length; j++) {\n      name = names[j];\n      if (wFieldsMap[name]) {\n        matches.push(name);\n      }\n    }\n    if (matches.length > 1) {\n      throw new Error(\n        f('ambiguous aliasing for %s.%s (%s)', type.name, field.name, matches)\n      );\n    }\n    if (!matches.length) {\n      if (field.defaultValue() === undefined) {\n        throw new Error(\n          f('no matching field for default-less %s.%s', type.name, field.name)\n        );\n      }\n    } else {\n      name = matches[0];\n      fieldResolver = {\n        resolver: field.type.createResolver(wFieldsMap[name].type, opts),\n        name: '_' + field.name // Reader field name.\n      };\n      if (!resolvers[name]) {\n        resolvers[name] = [fieldResolver];\n      } else {\n        resolvers[name].push(fieldResolver);\n      }\n    }\n  }\n\n  var self = this;\n  function ConstructorFunction() {\n    var constructorName = self._getConstructorName();\n    var innerFunction = ({\n      [constructorName]: function (t, b) {\n        if (b) return;\n        var innerArgs = []; // Arguments for reader constructor.\n        for (i = 0; i < rFields.length; i++) {\n          field = rFields[i];\n          names = getAliases(field);\n          matches = [];\n          for (j = 0; j < names.length; j++) {\n            name = names[j];\n            if (wFieldsMap[name]) {\n              matches.push(name);\n            }\n          }\n          if (!matches.length) {\n            innerArgs.push(undefined);\n          }\n        }\n        for (var i = 0; i < wFields.length; i++) {\n          let wf = type.fields[i];\n          name = wf.name;\n          if (resolvers[name] === undefined) {\n            wf.type._skip(t);\n          } else {\n            var j = resolvers[name].length;\n            while (j--) {\n              innerArgs.unshift(j ? resolvers[name][j].resolver._peek(t) : resolvers[name][j].resolver._read(t))\n            }\n          }\n        }\n        return new self.recordConstructor(...innerArgs);\n      }\n    })[constructorName];\n    return innerFunction;\n  }\n  resolver._read = ConstructorFunction();\n    \n};\n\nRecordType.prototype._match = function (tap1, tap2) {\n  var fields = this.fields;\n  var i, l, field, order, type;\n  for (i = 0, l = fields.length; i < l; i++) {\n    field = fields[i];\n    order = field._order;\n    type = field.type;\n    if (order) {\n      order *= type._match(tap1, tap2);\n      if (order) {\n        return order;\n      }\n    } else {\n      type._skip(tap1);\n      type._skip(tap2);\n    }\n  }\n  return 0;\n};\n\nRecordType.prototype._checkFields = function (obj) {\n  var keys = Object.keys(obj);\n  var i, l;\n  for (i = 0, l = keys.length; i < l; i++) {\n    if (!this._fieldsByName[keys[i]]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nRecordType.prototype._copy = function (val, opts) {\n  // jshint -W058\n  var hook = opts && opts.fieldHook;\n  var values = [undefined];\n  var i, l, field, value;\n  for (i = 0, l = this.fields.length; i < l; i++) {\n    field = this.fields[i];\n    value = val[field.name];\n    if (value === undefined && field.hasOwnProperty('defaultValue')) {\n      value = field.defaultValue();\n    }\n    if ((opts && !opts.skip) || value !== undefined) {\n      value = field.type._copy(value, opts);\n    }\n    if (hook) {\n      value = hook(field, value, this);\n    }\n    values.push(value);\n  }\n  var Record = this.recordConstructor;\n  return new (Record.bind.apply(Record, values))();\n};\n\nRecordType.prototype._deref = function (schema, opts) {\n  schema.fields = this.fields.map(function (field) {\n    var fieldType = field.type;\n    var fieldSchema = {\n      name: field.name,\n      type: fieldType._attrs(opts)\n    };\n    if (opts.exportAttrs) {\n      var val = field.defaultValue();\n      if (val !== undefined) {\n        // We must both unwrap all unions and coerce buffers to strings.\n        fieldSchema['default'] = fieldType._copy(val, {coerce: 3, wrap: 3});\n      }\n      var fieldOrder = field.order;\n      if (fieldOrder !== 'ascending') {\n        fieldSchema.order = fieldOrder;\n      }\n      var fieldAliases = field.aliases;\n      if (fieldAliases.length) {\n        fieldSchema.aliases = fieldAliases;\n      }\n      var fieldDoc = field.doc;\n      if (fieldDoc !== undefined) {\n        fieldSchema.doc = fieldDoc;\n      }\n    }\n    return fieldSchema;\n  });\n};\n\nRecordType.prototype.compare = function (val1, val2) {\n  var fields = this.fields;\n  var i, l, field, name, order, type;\n  for (i = 0, l = fields.length; i < l; i++) {\n    field = fields[i];\n    name = field.name;\n    order = field._order;\n    type = field.type;\n    if (order) {\n      order *= type.compare(val1[name], val2[name]);\n      if (order) {\n        return order;\n      }\n    }\n  }\n  return 0;\n};\n\nRecordType.prototype.random = function () {\n  // jshint -W058\n  var fields = this.fields.map(function (f) { return f.type.random(); });\n  fields.unshift(undefined);\n  var Record = this.recordConstructor;\n  return new (Record.bind.apply(Record, fields))();\n};\n\nRecordType.prototype.field = function (name) {\n  return this._fieldsByName[name];\n};\n\nRecordType.prototype.getField = RecordType.prototype.field;\n\nRecordType.prototype.getFields = function () { return this.fields; };\n\nRecordType.prototype.getRecordConstructor = function () {\n  return this.recordConstructor;\n};\n\nObject.defineProperty(RecordType.prototype, 'typeName', {\n  enumerable: true,\n  get: function () { return this._isError ? 'error' : 'record'; }\n});\n\n/** Derived type abstract class. */\nfunction LogicalType(schema, opts) {\n  this._logicalTypeName = schema.logicalType;\n  Type.call(this);\n  LOGICAL_TYPE = this;\n  try {\n    this._underlyingType = Type.forSchema(schema, opts);\n  } finally {\n    LOGICAL_TYPE = null;\n    // Remove the underlying type now that we're done instantiating. Note that\n    // in some (rare) cases, it might not have been inserted; for example, if\n    // this constructor was manually called with an already instantiated type.\n    var l = UNDERLYING_TYPES.length;\n    if (l && UNDERLYING_TYPES[l - 1][0] === this) {\n      UNDERLYING_TYPES.pop();\n    }\n  }\n  // We create a separate branch constructor for logical types to keep them\n  // monomorphic.\n  if (Type.isType(this.underlyingType, 'union')) {\n    this._branchConstructor = this.underlyingType._branchConstructor;\n  } else {\n    this._branchConstructor = this.underlyingType._createBranchConstructor();\n  }\n  // We don't freeze derived types to allow arbitrary properties. Implementors\n  // can still do so in the subclass' constructor at their convenience.\n}\nutil.inherits(LogicalType, Type);\n\nObject.defineProperty(LogicalType.prototype, 'typeName', {\n  enumerable: true,\n  get: function () { return 'logical:' + this._logicalTypeName; }\n});\n\nObject.defineProperty(LogicalType.prototype, 'underlyingType', {\n  enumerable: true,\n  get: function () {\n    if (this._underlyingType) {\n      return this._underlyingType;\n    }\n    // If the field wasn't present, it means the logical type isn't complete\n    // yet: we're waiting on its underlying type to be fully instantiated. In\n    // this case, it will be present in the `UNDERLYING_TYPES` array.\n    var i, l, arr;\n    for (i = 0, l = UNDERLYING_TYPES.length; i < l; i++) {\n      arr = UNDERLYING_TYPES[i];\n      if (arr[0] === this) {\n        return arr[1];\n      }\n    }\n  }\n});\n\nLogicalType.prototype.getUnderlyingType = function () {\n  return this.underlyingType;\n};\n\nLogicalType.prototype._read = function (tap) {\n  return this._fromValue(this.underlyingType._read(tap));\n};\n\nLogicalType.prototype._write = function (tap, any) {\n  this.underlyingType._write(tap, this._toValue(any));\n};\n\nLogicalType.prototype._check = function (any, flags, hook, path) {\n  try {\n    var val = this._toValue(any);\n  } catch (err) {\n    // Handled below.\n  }\n  if (val === undefined) {\n    if (hook) {\n      hook(any, this);\n    }\n    return false;\n  }\n  return this.underlyingType._check(val, flags, hook, path);\n};\n\nLogicalType.prototype._copy = function (any, opts) {\n  var type = this.underlyingType;\n  switch (opts && opts.coerce) {\n    case 3: // To string.\n      return type._copy(this._toValue(any), opts);\n    case 2: // From string.\n      return this._fromValue(type._copy(any, opts));\n    default: // Normal copy.\n      return this._fromValue(type._copy(this._toValue(any), opts));\n  }\n};\n\nLogicalType.prototype._update = function (resolver, type, opts) {\n  var _fromValue = this._resolve(type, opts);\n  if (_fromValue) {\n    resolver._read = function (tap) { return _fromValue(type._read(tap)); };\n  }\n};\n\nLogicalType.prototype.compare = function (obj1, obj2) {\n  var val1 = this._toValue(obj1);\n  var val2 = this._toValue(obj2);\n  return this.underlyingType.compare(val1, val2);\n};\n\nLogicalType.prototype.random = function () {\n  return this._fromValue(this.underlyingType.random());\n};\n\nLogicalType.prototype._deref = function (schema, opts) {\n  var type = this.underlyingType;\n  var isVisited = type.name !== undefined && opts.derefed[type.name];\n  schema = type._attrs(opts);\n  if (!isVisited && opts.exportAttrs) {\n    if (typeof schema == 'string') {\n      schema = {type: schema};\n    }\n    schema.logicalType = this._logicalTypeName;\n    this._export(schema);\n  }\n  return schema;\n};\n\nLogicalType.prototype._skip = function (tap) {\n  this.underlyingType._skip(tap);\n};\n\n// Unlike the other methods below, `_export` has a reasonable default which we\n// can provide (not exporting anything).\nLogicalType.prototype._export = function (/* schema */) {};\n\n// Methods to be implemented.\nLogicalType.prototype._fromValue = utils.abstractFunction;\nLogicalType.prototype._toValue = utils.abstractFunction;\nLogicalType.prototype._resolve = utils.abstractFunction;\n\n\n// General helpers.\n\n/**\n * Customizable long.\n *\n * This allows support of arbitrarily large long (e.g. larger than\n * `Number.MAX_SAFE_INTEGER`). See `LongType.__with` method above. Note that we\n * can't use a logical type because we need a \"lower-level\" hook here: passing\n * through through the standard long would cause a loss of precision.\n */\nfunction AbstractLongType(noUnpack) {\n  this._concreteTypeName = 'long';\n  PrimitiveType.call(this, true);\n  // Note that this type \"inherits\" `LongType` (i.e. gain its prototype\n  // methods) but only \"subclasses\" `PrimitiveType` to avoid being prematurely\n  // frozen.\n  this._noUnpack = !!noUnpack;\n}\nutil.inherits(AbstractLongType, LongType);\n\nAbstractLongType.prototype.typeName = 'abstract:long';\n\nAbstractLongType.prototype._check = function (val, flags, hook) {\n  var b = this._isValid(val);\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nAbstractLongType.prototype._read = function (tap) {\n  var buf, pos;\n  if (this._noUnpack) {\n    pos = tap.pos;\n    tap.skipLong();\n    buf = tap.buf.slice(pos, tap.pos);\n  } else {\n    buf = tap.unpackLongBytes(tap);\n  }\n  if (tap.isValid()) {\n    return this._fromBuffer(buf);\n  }\n};\n\nAbstractLongType.prototype._write = function (tap, val) {\n  if (!this._isValid(val)) {\n    throwInvalidError(val, this);\n  }\n  var buf = this._toBuffer(val);\n  if (this._noUnpack) {\n    tap.writeFixed(buf);\n  } else {\n    tap.packLongBytes(buf);\n  }\n};\n\nAbstractLongType.prototype._copy = function (val, opts) {\n  switch (opts && opts.coerce) {\n    case 3: // To string.\n      return this._toJSON(val);\n    case 2: // From string.\n      return this._fromJSON(val);\n    default: // Normal copy.\n      // Slow but guarantees most consistent results. Faster alternatives would\n      // require assumptions on the long class used (e.g. immutability).\n      return this._fromJSON(this._toJSON(val));\n  }\n};\n\nAbstractLongType.prototype._deref = function () { return 'long'; }\n\nAbstractLongType.prototype._update = function (resolver, type) {\n  var self = this;\n  switch (type.typeName) {\n    case 'int':\n      resolver._read = function (tap) {\n        return self._fromJSON(type._read(tap));\n      };\n      break;\n    case 'long':\n      resolver._read = function (tap) { return self._read(tap); };\n  }\n};\n\nAbstractLongType.prototype.random = function () {\n  return this._fromJSON(LongType.prototype.random());\n};\n\n// Methods to be implemented by the user.\nAbstractLongType.prototype._fromBuffer = utils.abstractFunction;\nAbstractLongType.prototype._toBuffer = utils.abstractFunction;\nAbstractLongType.prototype._fromJSON = utils.abstractFunction;\nAbstractLongType.prototype._toJSON = utils.abstractFunction;\nAbstractLongType.prototype._isValid = utils.abstractFunction;\nAbstractLongType.prototype.compare = utils.abstractFunction;\n\n/** A record field. */\nfunction Field(schema, opts) {\n  var name = schema.name;\n  if (typeof name != 'string' || !isValidName(name)) {\n    throw new Error(f('invalid field name: %s', name));\n  }\n\n  this.name = name;\n  this.type = Type.forSchema(schema.type, opts);\n  this.aliases = schema.aliases || [];\n  this.doc = schema.doc !== undefined ? '' + schema.doc : undefined;\n\n  this._order = (function (order) {\n    switch (order) {\n      case 'ascending':\n        return 1;\n      case 'descending':\n        return -1;\n      case 'ignore':\n        return 0;\n      default:\n        throw new Error(f('invalid order: %j', order));\n    }\n  })(schema.order === undefined ? 'ascending' : schema.order);\n\n  var value = schema['default'];\n  if (value !== undefined) {\n    // We need to convert defaults back to a valid format (unions are\n    // disallowed in default definitions, only the first type of each union is\n    // allowed instead).\n    // http://apache-avro.679487.n3.nabble.com/field-union-default-in-Java-td1175327.html\n    var type = this.type;\n    var val = type._copy(value, {coerce: 2, wrap: 2});\n    // The clone call above will throw an error if the default is invalid.\n    if (isPrimitive(type.typeName) && type.typeName !== 'bytes') {\n      // These are immutable.\n      this.defaultValue = function () { return val; };\n    } else {\n      this.defaultValue = function () { return type._copy(val); };\n    }\n  }\n\n  Object.freeze(this);\n}\n\nField.prototype.defaultValue = function () {}; // Undefined default.\n\nObject.defineProperty(Field.prototype, 'order', {\n  enumerable: true,\n  get: function () {\n    return ['descending', 'ignore', 'ascending'][this._order + 1];\n  }\n});\n\nField.prototype.getAliases = function () { return this.aliases; };\n\nField.prototype.getDefault = Field.prototype.defaultValue;\n\nField.prototype.getName = function () { return this.name; };\n\nField.prototype.getOrder = function () { return this.order; };\n\nField.prototype.getType = function () { return this.type; };\n\n/**\n * Resolver to read a writer's schema as a new schema.\n *\n * @param readerType {Type} The type to convert to.\n */\nfunction Resolver(readerType) {\n  // Add all fields here so that all resolvers share the same hidden class.\n  this._readerType = readerType;\n  this._read = null;\n  this.itemsType = null;\n  this.size = 0;\n  this.symbols = null;\n  this.valuesType = null;\n}\n\nResolver.prototype._peek = Type.prototype._peek;\n\nResolver.prototype.inspect = function () { return '<Resolver>'; };\n\n/** Mutable hash container. */\nfunction Hash() {\n  this.str = undefined;\n}\n\n/**\n * Read a value from a tap.\n *\n * @param type {Type} The type to decode.\n * @param tap {Tap} The tap to read from. No checks are performed here.\n * @param resolver {Resolver} Optional resolver. It must match the input type.\n * @param lazy {Boolean} Skip trailing fields when using a resolver.\n */\nfunction readValue(type, tap, resolver, lazy) {\n  if (resolver) {\n    if (resolver._readerType !== type) {\n      throw new Error('invalid resolver');\n    }\n    return resolver._read(tap, lazy);\n  } else {\n    return type._read(tap);\n  }\n}\n\n/**\n * Remove namespace from a name.\n *\n * @param name {String} Full or short name.\n */\nfunction unqualify(name) {\n  var parts = name.split('.');\n  return parts[parts.length - 1];\n}\n\n/**\n * Verify and return fully qualified name.\n *\n * @param name {String} Full or short name. It can be prefixed with a dot to\n * force global namespace.\n * @param namespace {String} Optional namespace.\n */\nfunction qualify(name, namespace) {\n  if (~name.indexOf('.')) {\n    name = name.replace(/^\\./, ''); // Allow absolute referencing.\n  } else if (namespace) {\n    name = namespace + '.' + name;\n  }\n  name.split('.').forEach(function (part) {\n    if (!isValidName(part)) {\n      throw new Error(f('invalid name: %j', name));\n    }\n  });\n  var tail = unqualify(name);\n  // Primitives are always in the global namespace.\n  return isPrimitive(tail) ? tail : name;\n}\n\n/**\n * Get all aliases for a type (including its name).\n *\n * @param obj {Type|Object} Typically a type or a field. Its aliases property\n * must exist and be an array.\n */\nfunction getAliases(obj) {\n  var names = {};\n  if (obj.name) {\n    names[obj.name] = true;\n  }\n  var aliases = obj.aliases;\n  var i, l;\n  for (i = 0, l = aliases.length; i < l; i++) {\n    names[aliases[i]] = true;\n  }\n  return Object.keys(names);\n}\n\n/**\n * Check whether a type's name is a primitive.\n *\n * @param name {String} Type name (e.g. `'string'`, `'array'`).\n */\nfunction isPrimitive(typeName) {\n  // Since we use this module's own `TYPES` object, we can use `instanceof`.\n  var type = TYPES[typeName];\n  return type && type.prototype instanceof PrimitiveType;\n}\n\n/**\n * Return a type's class name from its Avro type name.\n *\n * We can't simply use `constructor.name` since it isn't supported in all\n * browsers.\n *\n * @param typeName {String} Type name.\n */\nfunction getClassName(typeName) {\n  if (typeName === 'error') {\n    typeName = 'record';\n  } else {\n    var match = /^([^:]+):(.*)$/.exec(typeName);\n    if (match) {\n      if (match[1] === 'union') {\n        typeName = match[2] + 'Union';\n      } else {\n        // Logical type.\n        typeName = match[1];\n      }\n    }\n  }\n  return utils.capitalize(typeName) + 'Type';\n}\n\n/**\n * Get the number of elements in an array block.\n *\n * @param tap {Tap} A tap positioned at the beginning of an array block.\n */\nfunction readArraySize(tap) {\n  var n = tap.readLong();\n  if (n < 0) {\n    n = -n;\n    tap.skipLong(); // Skip size.\n  }\n  return n;\n}\n\n/**\n * Check whether a long can be represented without precision loss.\n *\n * @param n {Number} The number.\n *\n * Two things to note:\n *\n * + We are not using the `Number` constants for compatibility with older\n *   browsers.\n * + We must remove one from each bound because of rounding errors.\n */\nfunction isSafeLong(n) {\n  return n >= -9007199254740990 && n <= 9007199254740990;\n}\n\n/**\n * Check whether an object is the JSON representation of a buffer.\n */\nfunction isJsonBuffer(obj) {\n  return obj && obj.type === 'Buffer' && Array.isArray(obj.data);\n}\n\n/**\n * Check whether a string is a valid Avro identifier.\n */\nfunction isValidName(str) { return NAME_PATTERN.test(str); }\n\n/**\n * Throw a somewhat helpful error on invalid object.\n *\n * @param path {Array} Passed from hook, but unused (because empty where this\n * function is used, since we aren't keeping track of it for effiency).\n * @param val {...} The object to reject.\n * @param type {Type} The type to check against.\n *\n * This method is mostly used from `_write` to signal an invalid object for a\n * given type. Note that this provides less information than calling `isValid`\n * with a hook since the path is not propagated (for efficiency reasons).\n */\nfunction throwInvalidError(val, type) {\n  throw new Error(f('invalid %s: %j', type, val));\n}\n\n/**\n * Get a type's bucket when included inside an unwrapped union.\n *\n * @param type {Type} Any type.\n */\nfunction getTypeBucket(type) {\n  var typeName = type.typeName;\n  switch (typeName) {\n    case 'double':\n    case 'float':\n    case 'int':\n    case 'long':\n      return 'number';\n    case 'bytes':\n    case 'fixed':\n      return 'buffer';\n    case 'enum':\n      return 'string';\n    case 'map':\n    case 'error':\n    case 'record':\n      return 'object';\n    default:\n      return typeName;\n  }\n}\n\n/**\n * Infer a value's bucket (see unwrapped unions for more details).\n *\n * @param val {...} Any value.\n */\nfunction getValueBucket(val) {\n  if (val === null) {\n    return 'null';\n  }\n  var bucket = typeof val;\n  if (bucket === 'object') {\n    // Could be bytes, fixed, array, map, or record.\n    if (Array.isArray(val)) {\n      return 'array';\n    } else if (Buffer.isBuffer(val)) {\n      return 'buffer';\n    }\n  }\n  return bucket;\n}\n\n/**\n * Check whether a collection of types leads to an ambiguous union.\n *\n * @param types {Array} Array of types.\n */\nfunction isAmbiguous(types) {\n  var buckets = {};\n  var i, l, bucket, type;\n  for (i = 0, l = types.length; i < l; i++) {\n    type = types[i];\n    if (!Type.isType(type, 'logical')) {\n      bucket = getTypeBucket(type);\n      if (buckets[bucket]) {\n        return true;\n      }\n      buckets[bucket] = true;\n    }\n  }\n  return false;\n}\n\n/**\n * Combine number types.\n *\n * Note that never have to create a new type here, we are guaranteed to be able\n * to reuse one of the input types as super-type.\n */\nfunction combineNumbers(types) {\n  var typeNames = ['int', 'long', 'float', 'double'];\n  var superIndex = -1;\n  var superType = null;\n  var i, l, type, index;\n  for (i = 0, l = types.length; i < l; i++) {\n    type = types[i];\n    index = typeNames.indexOf(type.typeName);\n    if (index > superIndex) {\n      superIndex = index;\n      superType = type;\n    }\n  }\n  return superType;\n}\n\n/**\n * Combine enums and strings.\n *\n * The order of the returned symbols is undefined and the returned enum is\n *\n */\nfunction combineStrings(types, opts) {\n  var symbols = {};\n  var i, l, type, typeSymbols;\n  for (i = 0, l = types.length; i < l; i++) {\n    type = types[i];\n    if (type.typeName === 'string') {\n      // If at least one of the types is a string, it will be the supertype.\n      return type;\n    }\n    typeSymbols = type.symbols;\n    var j, m;\n    for (j = 0, m = typeSymbols.length; j < m; j++) {\n      symbols[typeSymbols[j]] = true;\n    }\n  }\n  return Type.forSchema({type: 'enum', symbols: Object.keys(symbols)}, opts);\n}\n\n/**\n * Combine bytes and fixed.\n *\n * This function is optimized to avoid creating new types when possible: in\n * case of a size mismatch between fixed types, it will continue looking\n * through the array to find an existing bytes type (rather than exit early by\n * creating one eagerly).\n */\nfunction combineBuffers(types, opts) {\n  var size = -1;\n  var i, l, type;\n  for (i = 0, l = types.length; i < l; i++) {\n    type = types[i];\n    if (type.typeName === 'bytes') {\n      return type;\n    }\n    if (size === -1) {\n      size = type.size;\n    } else if (type.size !== size) {\n      // Don't create a bytes type right away, we might be able to reuse one\n      // later on in the types array. Just mark this for now.\n      size = -2;\n    }\n  }\n  return size < 0 ? Type.forSchema('bytes', opts) : types[0];\n}\n\n/**\n * Combine maps and records.\n *\n * Field defaults are kept when possible (i.e. when no coercion to a map\n * happens), with later definitions overriding previous ones.\n */\nfunction combineObjects(types, opts) {\n  var allTypes = []; // Field and value types.\n  var fieldTypes = {}; // Record field types grouped by field name.\n  var fieldDefaults = {};\n  var isValidRecord = true;\n\n  // Check whether the final type will be a map or a record.\n  var i, l, type, fields;\n  for (i = 0, l = types.length; i < l; i++) {\n    type = types[i];\n    if (type.typeName === 'map') {\n      isValidRecord = false;\n      allTypes.push(type.valuesType);\n    } else {\n      fields = type.fields;\n      var j, m, field, fieldDefault, fieldName, fieldType;\n      for (j = 0, m = fields.length; j < m; j++) {\n        field = fields[j];\n        fieldName = field.name;\n        fieldType = field.type;\n        allTypes.push(fieldType);\n        if (isValidRecord) {\n          if (!fieldTypes[fieldName]) {\n            fieldTypes[fieldName] = [];\n          }\n          fieldTypes[fieldName].push(fieldType);\n          fieldDefault = field.defaultValue();\n          if (fieldDefault !== undefined) {\n            // Later defaults will override any previous ones.\n            fieldDefaults[fieldName] = fieldDefault;\n          }\n        }\n      }\n    }\n  }\n\n  if (isValidRecord) {\n    // Check that no fields are missing and that we have the approriate\n    // defaults for those which are.\n    var fieldNames = Object.keys(fieldTypes);\n    for (i = 0, l = fieldNames.length; i < l; i++) {\n      fieldName = fieldNames[i];\n      if (\n        fieldTypes[fieldName].length < types.length &&\n        fieldDefaults[fieldName] === undefined\n      ) {\n        // At least one of the records is missing a field with no default.\n        if (opts && opts.strictDefaults) {\n          isValidRecord = false;\n        } else {\n          fieldTypes[fieldName].unshift(Type.forSchema('null', opts));\n          fieldDefaults[fieldName] = null;\n        }\n      }\n    }\n  }\n\n  var schema;\n  if (isValidRecord) {\n    schema = {\n      type: 'record',\n      fields: fieldNames.map(function (s) {\n        var fieldType = Type.forTypes(fieldTypes[s], opts);\n        var fieldDefault = fieldDefaults[s];\n        if (\n          fieldDefault !== undefined &&\n          ~fieldType.typeName.indexOf('union')\n        ) {\n          // Ensure that the default's corresponding type is first.\n          var unionTypes = fieldType.types.slice();\n          var i, l;\n          for (i = 0, l = unionTypes.length; i < l; i++) {\n            if (unionTypes[i].isValid(fieldDefault)) {\n              break;\n            }\n          }\n          if (i > 0) {\n            var unionType = unionTypes[0];\n            unionTypes[0] = unionTypes[i];\n            unionTypes[i] = unionType;\n            fieldType = Type.forSchema(unionTypes, opts);\n          }\n        }\n        return {\n          name: s,\n          type: fieldType,\n          'default': fieldDefaults[s]\n        };\n      })\n    };\n  } else {\n    schema = {\n      type: 'map',\n      values: Type.forTypes(allTypes, opts)\n    };\n  }\n  return Type.forSchema(schema, opts);\n}\n\n\nmodule.exports = {\n  Type: Type,\n  getTypeBucket: getTypeBucket,\n  getValueBucket: getValueBucket,\n  isPrimitive: isPrimitive,\n  isValidName: isValidName,\n  qualify: qualify,\n  builtins: (function () {\n    var types = {\n      LogicalType: LogicalType,\n      UnwrappedUnionType: UnwrappedUnionType,\n      WrappedUnionType: WrappedUnionType\n    };\n    var typeNames = Object.keys(TYPES);\n    var i, l, typeName;\n    for (i = 0, l = typeNames.length; i < l; i++) {\n      typeName = typeNames[i];\n      types[getClassName(typeName)] = TYPES[typeName];\n    }\n    return types;\n  })()\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}