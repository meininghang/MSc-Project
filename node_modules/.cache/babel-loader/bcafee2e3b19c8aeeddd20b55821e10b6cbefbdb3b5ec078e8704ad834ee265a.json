{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/web.url-search-params.delete.js\";\nimport \"core-js/modules/web.url-search-params.has.js\";\nimport \"core-js/modules/web.url-search-params.size.js\";\nimport BN from 'bignumber.js';\nimport { Buffer } from 'safe-buffer';\nimport baseX from 'base-x';\nconst BASE26_0 = ADDRESS_ALPHABET[0];\nconst base26 = baseX(ADDRESS_ALPHABET);\n/**\r\n * Convert to hexadecimal based on string (avatar color)\r\n * @param str\r\n * @returns {string}\r\n */\nexport function strToHexCharCode(str) {\n  const hexCharCode = [];\n  const chars = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\"];\n  for (let i = 0; i < str.length; i++) {\n    let bit = (str[i] & 0x0f0) >> 4;\n    hexCharCode.push(chars[bit]);\n    bit = str[i] & 0x0f;\n    hexCharCode.push(chars[bit]);\n  }\n  return hexCharCode.join(\"\");\n}\nexport function strToUtf8Bytes(str) {\n  const utf8 = [];\n  for (let ii = 0; ii < str.length; ii++) {\n    let charCode = str.charCodeAt(ii);\n    if (charCode < 0x80) utf8.push(charCode);else if (charCode < 0x800) {\n      utf8.push(0xc0 | charCode >> 6, 0x80 | charCode & 0x3f);\n    } else if (charCode < 0xd800 || charCode >= 0xe000) {\n      utf8.push(0xe0 | charCode >> 12, 0x80 | charCode >> 6 & 0x3f, 0x80 | charCode & 0x3f);\n    } else {\n      ii++;\n      charCode = 0x10000 + ((charCode & 0x3ff) << 10 | str.charCodeAt(ii) & 0x3ff);\n      utf8.push(0xf0 | charCode >> 18, 0x80 | charCode >> 12 & 0x3f, 0x80 | charCode >> 6 & 0x3f, 0x80 | charCode & 0x3f);\n    }\n  }\n  // Compatible with Chinese characters, the maximum value of the ASCII code table is 127, and values greater than 127 are special characters\n  for (let jj = 0; jj < utf8.length; jj++) {\n    const code = utf8[jj];\n    if (code > 127) {\n      utf8[jj] = code - 256;\n    }\n  }\n  return utf8;\n}\nexport function getFileSize(size) {\n  if (!size) return 0;\n  const num = 1024.0; //byte\n\n  if (size < num) return size + \"B\";\n  if (size < Math.pow(num, 2)) return (size / num).toFixed(2) + \"K\"; //kb\n  if (size < Math.pow(num, 3)) return (size / Math.pow(num, 2)).toFixed(2) + \"M\"; //M\n  if (size < Math.pow(num, 4)) return (size / Math.pow(num, 3)).toFixed(2) + \"G\"; //G\n  return (size / Math.pow(num, 4)).toFixed(2) + \"T\"; //T\n}\n\nexport async function exportOrderExcel(blob, fileName) {\n  let aLink = document.createElement(\"a\");\n  let href = window.URL.createObjectURL(blob); //Create a link to download\n  aLink.href = href;\n  aLink.download = fileName; //fileName+time\n  document.body.appendChild(aLink);\n  aLink.click(); //click to download\n  document.body.removeChild(aLink); //Remove the element after downloading\n  window.URL.revokeObjectURL(blob); //Release the blob object\n}\n\nexport const toBN = x => {\n  if (isNaN(Number(x))) return new BN(0);\n  if (x instanceof BN) return x;\n  if (typeof x === 'string') {\n    if (x.indexOf('0x') === 0 || x.indexOf('-0x') === 0) {\n      return new BN(x.replace('0x', ''), 16);\n    }\n  }\n  return new BN(x);\n};\n\n/**\r\n * Encode hex address to LemoChain address\r\n * @param {string|Buffer} data\r\n * @return {string}\r\n */\nexport function encodeAddress(data) {\n  if (isLemoAddress(data)) {\n    return data;\n  }\n  data = toBuffer(data);\n  let checkSum = 0;\n  for (let i = 0; i < data.length; i++) {\n    checkSum ^= data[i];\n  }\n  const fullPayload = Buffer.concat([data, Buffer.from([checkSum])]);\n  let encoded = base26.encode(fullPayload);\n  while (encoded.length < 36) {\n    encoded = BASE26_0 + encoded;\n  }\n  return ADDRESS_LOGO + encoded;\n}\n\n/**\r\n * Decode LemoChain address to hex address\r\n * @param {string} address\r\n * @return {string}\r\n */\nexport function decodeAddress(address) {\n  if (typeof address !== 'string') {\n    throw new Error(errors.InvalidAddressType(address));\n  }\n  const origAddr = address;\n  if (has0xPrefix(address)) {\n    if (new RegExp(`^0x[0-9a-f]{0,${ADDRESS_BYTE_LENGTH * 2}}$`, 'i').test(address)) {\n      return address;\n    } else {\n      throw new Error(errors.InvalidHexAddress(origAddr));\n    }\n  }\n  address = address.toUpperCase();\n  if (address.slice(0, 4) !== ADDRESS_LOGO.toUpperCase()) {\n    // no logo\n    throw new Error(errors.InvalidAddress(origAddr));\n  }\n  if (address.length < 4 + 2) {\n    // no checkSum\n    throw new Error(errors.InvalidAddressCheckSum(origAddr));\n  }\n  let fullPayload;\n  try {\n    fullPayload = base26.decode(address.slice(4));\n  } catch (e) {\n    throw new Error(errors.DecodeAddressError(address, e.message));\n  }\n  fullPayload = bufferTrimLeft(fullPayload);\n  const maxLenWithCheckSum = ADDRESS_BYTE_LENGTH + 1;\n  if (fullPayload.length > maxLenWithCheckSum) {\n    throw new Error(errors.InvalidAddressLength(origAddr));\n  }\n  const data = fullPayload.slice(0, fullPayload.length - 1);\n  const checkSum = fullPayload[fullPayload.length - 1] || 0;\n  let realCheckSum = 0;\n  for (let i = 0; i < data.length; i++) {\n    realCheckSum ^= data[i];\n  }\n  if (realCheckSum !== checkSum) {\n    throw new Error(errors.InvalidAddressCheckSum(origAddr));\n  }\n\n  // trim left 00\n  const hex = data.toString('hex').replace(/^(00)+/, '');\n  return `0x${hex}`;\n}","map":{"version":3,"names":["BN","Buffer","baseX","BASE26_0","ADDRESS_ALPHABET","base26","strToHexCharCode","str","hexCharCode","chars","i","length","bit","push","join","strToUtf8Bytes","utf8","ii","charCode","charCodeAt","jj","code","getFileSize","size","num","Math","pow","toFixed","exportOrderExcel","blob","fileName","aLink","document","createElement","href","window","URL","createObjectURL","download","body","appendChild","click","removeChild","revokeObjectURL","toBN","x","isNaN","Number","indexOf","replace","encodeAddress","data","isLemoAddress","toBuffer","checkSum","fullPayload","concat","from","encoded","encode","ADDRESS_LOGO","decodeAddress","address","Error","errors","InvalidAddressType","origAddr","has0xPrefix","RegExp","ADDRESS_BYTE_LENGTH","test","InvalidHexAddress","toUpperCase","slice","InvalidAddress","InvalidAddressCheckSum","decode","e","DecodeAddressError","message","bufferTrimLeft","maxLenWithCheckSum","InvalidAddressLength","realCheckSum","hex","toString"],"sources":["E:/Amanda-project/vue2-project/project-vue2/src/utils/util.js"],"sourcesContent":["import BN from 'bignumber.js'\r\nimport {Buffer} from 'safe-buffer'\r\nimport baseX from 'base-x'\r\n\r\nconst BASE26_0 = ADDRESS_ALPHABET[0]\r\nconst base26 = baseX(ADDRESS_ALPHABET)\r\n/**\r\n * Convert to hexadecimal based on string (avatar color)\r\n * @param str\r\n * @returns {string}\r\n */\r\nexport function strToHexCharCode(str) {\r\n    const hexCharCode = [];\r\n    const chars = [\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"];\r\n    for(let i = 0; i < str.length; i++) {\r\n        let bit = (str[i] & 0x0f0) >> 4;\r\n        hexCharCode.push(chars[bit]);\r\n        bit = str[i] & 0x0f;\r\n        hexCharCode.push(chars[bit]);\r\n    }\r\n    return hexCharCode.join(\"\");\r\n}\r\nexport function strToUtf8Bytes(str) {\r\n    const utf8 = [];\r\n    for (let ii = 0; ii < str.length; ii++) {\r\n        let charCode = str.charCodeAt(ii);\r\n        if (charCode < 0x80) utf8.push(charCode);\r\n        else if (charCode < 0x800) {\r\n            utf8.push(0xc0 | (charCode >> 6), 0x80 | (charCode & 0x3f));\r\n        } else if (charCode < 0xd800 || charCode >= 0xe000) {\r\n            utf8.push(0xe0 | (charCode >> 12), 0x80 | ((charCode >> 6) & 0x3f), 0x80 | (charCode & 0x3f));\r\n        } else {\r\n            ii++;\r\n            charCode = 0x10000 + (((charCode & 0x3ff) << 10) | (str.charCodeAt(ii) & 0x3ff));\r\n            utf8.push(\r\n                0xf0 | (charCode >> 18),\r\n                0x80 | ((charCode >> 12) & 0x3f),\r\n                0x80 | ((charCode >> 6) & 0x3f),\r\n                0x80 | (charCode & 0x3f),\r\n            );\r\n        }\r\n    }\r\n    // Compatible with Chinese characters, the maximum value of the ASCII code table is 127, and values greater than 127 are special characters\r\n    for(let jj=0;jj<utf8.length;jj++){\r\n        const code = utf8[jj];\r\n        if(code>127){\r\n            utf8[jj] = code - 256;\r\n        }\r\n    }\r\n    return utf8;\r\n}\r\nexport function getFileSize(size) {\r\n    if (!size) return 0\r\n\r\n    const num = 1024.0 //byte\r\n\r\n    if (size < num) return size + \"B\"\r\n    if (size < Math.pow(num, 2)) return (size / num).toFixed(2) + \"K\" //kb\r\n    if (size < Math.pow(num, 3)) return (size / Math.pow(num, 2)).toFixed(2) + \"M\" //M\r\n    if (size < Math.pow(num, 4)) return (size / Math.pow(num, 3)).toFixed(2) + \"G\" //G\r\n    return (size / Math.pow(num, 4)).toFixed(2) + \"T\" //T\r\n}\r\n\r\nexport async function exportOrderExcel(blob, fileName) {\r\n    let aLink = document.createElement(\"a\")\r\n    let href = window.URL.createObjectURL(blob) //Create a link to download\r\n    aLink.href = href\r\n    aLink.download = fileName //fileName+time\r\n    document.body.appendChild(aLink)\r\n    aLink.click() //click to download\r\n    document.body.removeChild(aLink) //Remove the element after downloading\r\n    window.URL.revokeObjectURL(blob) //Release the blob object\r\n}\r\n\r\nexport const toBN = (x) => {\r\n    if (isNaN(Number(x))) return new BN(0)\r\n    if (x instanceof BN) return x\r\n\r\n    if (typeof x === 'string') {\r\n        if (x.indexOf('0x') === 0 || x.indexOf('-0x') === 0) {\r\n            return new BN((x).replace('0x', ''), 16)\r\n        }\r\n    }\r\n    return new BN(x)\r\n}\r\n\r\n/**\r\n * Encode hex address to LemoChain address\r\n * @param {string|Buffer} data\r\n * @return {string}\r\n */\r\nexport function encodeAddress(data) {\r\n    if (isLemoAddress(data)) {\r\n        return data\r\n    }\r\n    data = toBuffer(data)\r\n\r\n    let checkSum = 0\r\n    for (let i = 0; i < data.length; i++) {\r\n        checkSum ^= data[i]\r\n    }\r\n\r\n    const fullPayload = Buffer.concat([data, Buffer.from([checkSum])])\r\n\r\n    let encoded = base26.encode(fullPayload)\r\n    while (encoded.length < 36) {\r\n        encoded = BASE26_0 + encoded\r\n    }\r\n\r\n    return ADDRESS_LOGO + encoded\r\n}\r\n\r\n/**\r\n * Decode LemoChain address to hex address\r\n * @param {string} address\r\n * @return {string}\r\n */\r\nexport function decodeAddress(address) {\r\n    if (typeof address !== 'string') {\r\n        throw new Error(errors.InvalidAddressType(address))\r\n    }\r\n\r\n    const origAddr = address\r\n    if (has0xPrefix(address)) {\r\n        if (new RegExp(`^0x[0-9a-f]{0,${ADDRESS_BYTE_LENGTH * 2}}$`, 'i').test(address)) {\r\n            return address\r\n        } else {\r\n            throw new Error(errors.InvalidHexAddress(origAddr))\r\n        }\r\n    }\r\n    address = address.toUpperCase()\r\n    if (address.slice(0, 4) !== ADDRESS_LOGO.toUpperCase()) {\r\n        // no logo\r\n        throw new Error(errors.InvalidAddress(origAddr))\r\n    }\r\n    if (address.length < 4 + 2) {\r\n        // no checkSum\r\n        throw new Error(errors.InvalidAddressCheckSum(origAddr))\r\n    }\r\n\r\n    let fullPayload\r\n    try {\r\n        fullPayload = base26.decode(address.slice(4))\r\n    } catch (e) {\r\n        throw new Error(errors.DecodeAddressError(address, e.message))\r\n    }\r\n    fullPayload = bufferTrimLeft(fullPayload)\r\n    const maxLenWithCheckSum = ADDRESS_BYTE_LENGTH + 1\r\n    if (fullPayload.length > maxLenWithCheckSum) {\r\n        throw new Error(errors.InvalidAddressLength(origAddr))\r\n    }\r\n    const data = fullPayload.slice(0, fullPayload.length - 1)\r\n    const checkSum = fullPayload[fullPayload.length - 1] || 0\r\n\r\n    let realCheckSum = 0\r\n    for (let i = 0; i < data.length; i++) {\r\n        realCheckSum ^= data[i]\r\n    }\r\n    if (realCheckSum !== checkSum) {\r\n        throw new Error(errors.InvalidAddressCheckSum(origAddr))\r\n    }\r\n\r\n    // trim left 00\r\n    const hex = data.toString('hex').replace(/^(00)+/, '')\r\n    return `0x${hex}`\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}