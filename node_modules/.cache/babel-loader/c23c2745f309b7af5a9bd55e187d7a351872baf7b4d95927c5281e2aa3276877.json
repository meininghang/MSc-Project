{"ast":null,"code":"var _ = require(\"../utils\")._;\nvar utils = require(\"../utils\");\nvar BigInteger = require(\"../libs/jsbn\");\nconst PRIVATE_OPENING_BOUNDARY = \"-----BEGIN OPENSSH PRIVATE KEY-----\";\nconst PRIVATE_CLOSING_BOUNDARY = \"-----END OPENSSH PRIVATE KEY-----\";\nmodule.exports = {\n  privateExport: function (key, options) {\n    const nbuf = key.n.toBuffer();\n    let ebuf = Buffer.alloc(4);\n    ebuf.writeUInt32BE(key.e, 0);\n    //Slice leading zeroes\n    while (ebuf[0] === 0) ebuf = ebuf.slice(1);\n    const dbuf = key.d.toBuffer();\n    const coeffbuf = key.coeff.toBuffer();\n    const pbuf = key.p.toBuffer();\n    const qbuf = key.q.toBuffer();\n    let commentbuf;\n    if (typeof key.sshcomment !== \"undefined\") {\n      commentbuf = Buffer.from(key.sshcomment);\n    } else {\n      commentbuf = Buffer.from([]);\n    }\n    const pubkeyLength = 11 +\n    // 32bit length, 'ssh-rsa'\n    4 + ebuf.byteLength + 4 + nbuf.byteLength;\n    const privateKeyLength = 8 +\n    //64bit unused checksum\n    11 +\n    // 32bit length, 'ssh-rsa'\n    4 + nbuf.byteLength + 4 + ebuf.byteLength + 4 + dbuf.byteLength + 4 + coeffbuf.byteLength + 4 + pbuf.byteLength + 4 + qbuf.byteLength + 4 + commentbuf.byteLength;\n    let length = 15 +\n    //openssh-key-v1,0x00,\n    16 +\n    // 2*(32bit length, 'none')\n    4 +\n    // 32bit length, empty string\n    4 +\n    // 32bit number of keys\n    4 +\n    // 32bit pubkey length\n    pubkeyLength + 4 +\n    //32bit private+checksum+comment+padding length\n    privateKeyLength;\n    const paddingLength = Math.ceil(privateKeyLength / 8) * 8 - privateKeyLength;\n    length += paddingLength;\n    const buf = Buffer.alloc(length);\n    const writer = {\n      buf: buf,\n      off: 0\n    };\n    buf.write(\"openssh-key-v1\", \"utf8\");\n    buf.writeUInt8(0, 14);\n    writer.off += 15;\n    writeOpenSSHKeyString(writer, Buffer.from(\"none\"));\n    writeOpenSSHKeyString(writer, Buffer.from(\"none\"));\n    writeOpenSSHKeyString(writer, Buffer.from(\"\"));\n    writer.off = writer.buf.writeUInt32BE(1, writer.off);\n    writer.off = writer.buf.writeUInt32BE(pubkeyLength, writer.off);\n    writeOpenSSHKeyString(writer, Buffer.from(\"ssh-rsa\"));\n    writeOpenSSHKeyString(writer, ebuf);\n    writeOpenSSHKeyString(writer, nbuf);\n    writer.off = writer.buf.writeUInt32BE(length - 47 - pubkeyLength, writer.off);\n    writer.off += 8;\n    writeOpenSSHKeyString(writer, Buffer.from(\"ssh-rsa\"));\n    writeOpenSSHKeyString(writer, nbuf);\n    writeOpenSSHKeyString(writer, ebuf);\n    writeOpenSSHKeyString(writer, dbuf);\n    writeOpenSSHKeyString(writer, coeffbuf);\n    writeOpenSSHKeyString(writer, pbuf);\n    writeOpenSSHKeyString(writer, qbuf);\n    writeOpenSSHKeyString(writer, commentbuf);\n    let pad = 0x01;\n    while (writer.off < length) {\n      writer.off = writer.buf.writeUInt8(pad++, writer.off);\n    }\n    if (options.type === \"der\") {\n      return writer.buf;\n    } else {\n      return PRIVATE_OPENING_BOUNDARY + \"\\n\" + utils.linebrk(buf.toString(\"base64\"), 70) + \"\\n\" + PRIVATE_CLOSING_BOUNDARY + \"\\n\";\n    }\n  },\n  privateImport: function (key, data, options) {\n    options = options || {};\n    var buffer;\n    if (options.type !== \"der\") {\n      if (Buffer.isBuffer(data)) {\n        data = data.toString(\"utf8\");\n      }\n      if (_.isString(data)) {\n        var pem = utils.trimSurroundingText(data, PRIVATE_OPENING_BOUNDARY, PRIVATE_CLOSING_BOUNDARY).replace(/\\s+|\\n\\r|\\n|\\r$/gm, \"\");\n        buffer = Buffer.from(pem, \"base64\");\n      } else {\n        throw Error(\"Unsupported key format\");\n      }\n    } else if (Buffer.isBuffer(data)) {\n      buffer = data;\n    } else {\n      throw Error(\"Unsupported key format\");\n    }\n    const reader = {\n      buf: buffer,\n      off: 0\n    };\n    if (buffer.slice(0, 14).toString(\"ascii\") !== \"openssh-key-v1\") throw \"Invalid file format.\";\n    reader.off += 15;\n\n    //ciphername\n    if (readOpenSSHKeyString(reader).toString(\"ascii\") !== \"none\") throw Error(\"Unsupported key type\");\n    //kdfname\n    if (readOpenSSHKeyString(reader).toString(\"ascii\") !== \"none\") throw Error(\"Unsupported key type\");\n    //kdf\n    if (readOpenSSHKeyString(reader).toString(\"ascii\") !== \"\") throw Error(\"Unsupported key type\");\n    //keynum\n    reader.off += 4;\n\n    //sshpublength\n    reader.off += 4;\n\n    //keytype\n    if (readOpenSSHKeyString(reader).toString(\"ascii\") !== \"ssh-rsa\") throw Error(\"Unsupported key type\");\n    readOpenSSHKeyString(reader);\n    readOpenSSHKeyString(reader);\n    reader.off += 12;\n    if (readOpenSSHKeyString(reader).toString(\"ascii\") !== \"ssh-rsa\") throw Error(\"Unsupported key type\");\n    const n = readOpenSSHKeyString(reader);\n    const e = readOpenSSHKeyString(reader);\n    const d = readOpenSSHKeyString(reader);\n    const coeff = readOpenSSHKeyString(reader);\n    const p = readOpenSSHKeyString(reader);\n    const q = readOpenSSHKeyString(reader);\n\n    //Calculate missing values\n    const dint = new BigInteger(d);\n    const qint = new BigInteger(q);\n    const pint = new BigInteger(p);\n    const dp = dint.mod(pint.subtract(BigInteger.ONE));\n    const dq = dint.mod(qint.subtract(BigInteger.ONE));\n    key.setPrivate(n,\n    // modulus\n    e,\n    // publicExponent\n    d,\n    // privateExponent\n    p,\n    // prime1\n    q,\n    // prime2\n    dp.toBuffer(),\n    // exponent1 -- d mod (p1)\n    dq.toBuffer(),\n    // exponent2 -- d mod (q-1)\n    coeff // coefficient -- (inverse of q) mod p\n    );\n\n    key.sshcomment = readOpenSSHKeyString(reader).toString(\"ascii\");\n  },\n  publicExport: function (key, options) {\n    let ebuf = Buffer.alloc(4);\n    ebuf.writeUInt32BE(key.e, 0);\n    //Slice leading zeroes\n    while (ebuf[0] === 0) ebuf = ebuf.slice(1);\n    const nbuf = key.n.toBuffer();\n    const buf = Buffer.alloc(ebuf.byteLength + 4 + nbuf.byteLength + 4 + \"ssh-rsa\".length + 4);\n    const writer = {\n      buf: buf,\n      off: 0\n    };\n    writeOpenSSHKeyString(writer, Buffer.from(\"ssh-rsa\"));\n    writeOpenSSHKeyString(writer, ebuf);\n    writeOpenSSHKeyString(writer, nbuf);\n    let comment = key.sshcomment || \"\";\n    if (options.type === \"der\") {\n      return writer.buf;\n    } else {\n      return \"ssh-rsa \" + buf.toString(\"base64\") + \" \" + comment + \"\\n\";\n    }\n  },\n  publicImport: function (key, data, options) {\n    options = options || {};\n    var buffer;\n    if (options.type !== \"der\") {\n      if (Buffer.isBuffer(data)) {\n        data = data.toString(\"utf8\");\n      }\n      if (_.isString(data)) {\n        if (data.substring(0, 8) !== \"ssh-rsa \") throw Error(\"Unsupported key format\");\n        let pemEnd = data.indexOf(\" \", 8);\n\n        //Handle keys with no comment\n        if (pemEnd === -1) {\n          pemEnd = data.length;\n        } else {\n          key.sshcomment = data.substring(pemEnd + 1).replace(/\\s+|\\n\\r|\\n|\\r$/gm, \"\");\n        }\n        const pem = data.substring(8, pemEnd).replace(/\\s+|\\n\\r|\\n|\\r$/gm, \"\");\n        buffer = Buffer.from(pem, \"base64\");\n      } else {\n        throw Error(\"Unsupported key format\");\n      }\n    } else if (Buffer.isBuffer(data)) {\n      buffer = data;\n    } else {\n      throw Error(\"Unsupported key format\");\n    }\n    const reader = {\n      buf: buffer,\n      off: 0\n    };\n    const type = readOpenSSHKeyString(reader).toString(\"ascii\");\n    if (type !== \"ssh-rsa\") throw Error(\"Invalid key type: \" + type);\n    const e = readOpenSSHKeyString(reader);\n    const n = readOpenSSHKeyString(reader);\n    key.setPublic(n, e);\n  },\n  /**\n   * Trying autodetect and import key\n   * @param key\n   * @param data\n   */\n  autoImport: function (key, data) {\n    // [\\S\\s]* matches zero or more of any character\n    if (/^[\\S\\s]*-----BEGIN OPENSSH PRIVATE KEY-----\\s*(?=(([A-Za-z0-9+/=]+\\s*)+))\\1-----END OPENSSH PRIVATE KEY-----[\\S\\s]*$/g.test(data)) {\n      module.exports.privateImport(key, data);\n      return true;\n    }\n    if (/^[\\S\\s]*ssh-rsa \\s*(?=(([A-Za-z0-9+/=]+\\s*)+))\\1[\\S\\s]*$/g.test(data)) {\n      module.exports.publicImport(key, data);\n      return true;\n    }\n    return false;\n  }\n};\nfunction readOpenSSHKeyString(reader) {\n  const len = reader.buf.readInt32BE(reader.off);\n  reader.off += 4;\n  const res = reader.buf.slice(reader.off, reader.off + len);\n  reader.off += len;\n  return res;\n}\nfunction writeOpenSSHKeyString(writer, data) {\n  writer.buf.writeInt32BE(data.byteLength, writer.off);\n  writer.off += 4;\n  writer.off += data.copy(writer.buf, writer.off);\n}","map":{"version":3,"names":["_","require","utils","BigInteger","PRIVATE_OPENING_BOUNDARY","PRIVATE_CLOSING_BOUNDARY","module","exports","privateExport","key","options","nbuf","n","toBuffer","ebuf","Buffer","alloc","writeUInt32BE","e","slice","dbuf","d","coeffbuf","coeff","pbuf","p","qbuf","q","commentbuf","sshcomment","from","pubkeyLength","byteLength","privateKeyLength","length","paddingLength","Math","ceil","buf","writer","off","write","writeUInt8","writeOpenSSHKeyString","pad","type","linebrk","toString","privateImport","data","buffer","isBuffer","isString","pem","trimSurroundingText","replace","Error","reader","readOpenSSHKeyString","dint","qint","pint","dp","mod","subtract","ONE","dq","setPrivate","publicExport","comment","publicImport","substring","pemEnd","indexOf","setPublic","autoImport","test","len","readInt32BE","res","writeInt32BE","copy"],"sources":["E:/Amanda-project/vue2-project/project-vue2/node_modules/node-rsa/src/formats/openssh.js"],"sourcesContent":["var _ = require(\"../utils\")._;\nvar utils = require(\"../utils\");\nvar BigInteger = require(\"../libs/jsbn\");\n\nconst PRIVATE_OPENING_BOUNDARY = \"-----BEGIN OPENSSH PRIVATE KEY-----\";\nconst PRIVATE_CLOSING_BOUNDARY = \"-----END OPENSSH PRIVATE KEY-----\";\n\nmodule.exports = {\n    privateExport: function (key, options) {\n        const nbuf = key.n.toBuffer();\n\n        let ebuf = Buffer.alloc(4)\n        ebuf.writeUInt32BE(key.e, 0);\n        //Slice leading zeroes\n        while (ebuf[0] === 0) ebuf = ebuf.slice(1);\n\n        const dbuf = key.d.toBuffer();\n        const coeffbuf = key.coeff.toBuffer();\n        const pbuf = key.p.toBuffer();\n        const qbuf = key.q.toBuffer();\n        let commentbuf;\n        if (typeof key.sshcomment !== \"undefined\") {\n            commentbuf = Buffer.from(key.sshcomment);\n        } else {\n            commentbuf = Buffer.from([]);\n        }\n\n        const pubkeyLength =\n            11 + // 32bit length, 'ssh-rsa'\n            4 + ebuf.byteLength +\n            4 + nbuf.byteLength;\n\n        const privateKeyLength =\n            8 + //64bit unused checksum\n            11 + // 32bit length, 'ssh-rsa'\n            4 + nbuf.byteLength +\n            4 + ebuf.byteLength +\n            4 + dbuf.byteLength +\n            4 + coeffbuf.byteLength +\n            4 + pbuf.byteLength +\n            4 + qbuf.byteLength +\n            4 + commentbuf.byteLength;\n\n        let length =\n            15 + //openssh-key-v1,0x00,\n            16 + // 2*(32bit length, 'none')\n            4 + // 32bit length, empty string\n            4 + // 32bit number of keys\n            4 + // 32bit pubkey length\n            pubkeyLength +\n            4 + //32bit private+checksum+comment+padding length\n            privateKeyLength;\n\n        const paddingLength = Math.ceil(privateKeyLength / 8) * 8 - privateKeyLength;\n        length += paddingLength;\n\n        const buf = Buffer.alloc(length);\n        const writer = {buf: buf, off: 0};\n        buf.write(\"openssh-key-v1\", \"utf8\");\n        buf.writeUInt8(0, 14);\n        writer.off += 15;\n\n        writeOpenSSHKeyString(writer, Buffer.from(\"none\"));\n        writeOpenSSHKeyString(writer, Buffer.from(\"none\"));\n        writeOpenSSHKeyString(writer, Buffer.from(\"\"));\n\n        writer.off = writer.buf.writeUInt32BE(1, writer.off);\n        writer.off = writer.buf.writeUInt32BE(pubkeyLength, writer.off);\n\n        writeOpenSSHKeyString(writer, Buffer.from(\"ssh-rsa\"));\n        writeOpenSSHKeyString(writer, ebuf);\n        writeOpenSSHKeyString(writer, nbuf);\n\n        writer.off = writer.buf.writeUInt32BE(\n            length - 47 - pubkeyLength,\n            writer.off\n        );\n        writer.off += 8;\n\n        writeOpenSSHKeyString(writer, Buffer.from(\"ssh-rsa\"));\n        writeOpenSSHKeyString(writer, nbuf);\n        writeOpenSSHKeyString(writer, ebuf);\n        writeOpenSSHKeyString(writer, dbuf);\n        writeOpenSSHKeyString(writer, coeffbuf);\n        writeOpenSSHKeyString(writer, pbuf);\n        writeOpenSSHKeyString(writer, qbuf);\n        writeOpenSSHKeyString(writer, commentbuf);\n\n        let pad = 0x01;\n        while (writer.off < length) {\n            writer.off = writer.buf.writeUInt8(pad++, writer.off);\n        }\n\n        if (options.type === \"der\") {\n            return writer.buf\n        } else {\n            return PRIVATE_OPENING_BOUNDARY + \"\\n\" + utils.linebrk(buf.toString(\"base64\"), 70) + \"\\n\" + PRIVATE_CLOSING_BOUNDARY + \"\\n\";\n        }\n    },\n\n    privateImport: function (key, data, options) {\n        options = options || {};\n        var buffer;\n\n        if (options.type !== \"der\") {\n            if (Buffer.isBuffer(data)) {\n                data = data.toString(\"utf8\");\n            }\n\n            if (_.isString(data)) {\n                var pem = utils.trimSurroundingText(data, PRIVATE_OPENING_BOUNDARY, PRIVATE_CLOSING_BOUNDARY)\n                    .replace(/\\s+|\\n\\r|\\n|\\r$/gm, \"\");\n                buffer = Buffer.from(pem, \"base64\");\n            } else {\n                throw Error(\"Unsupported key format\");\n            }\n        } else if (Buffer.isBuffer(data)) {\n            buffer = data;\n        } else {\n            throw Error(\"Unsupported key format\");\n        }\n\n        const reader = {buf: buffer, off: 0};\n\n        if (buffer.slice(0, 14).toString(\"ascii\") !== \"openssh-key-v1\")\n            throw \"Invalid file format.\";\n\n        reader.off += 15;\n\n        //ciphername\n        if (readOpenSSHKeyString(reader).toString(\"ascii\") !== \"none\")\n            throw Error(\"Unsupported key type\");\n        //kdfname\n        if (readOpenSSHKeyString(reader).toString(\"ascii\") !== \"none\")\n            throw Error(\"Unsupported key type\");\n        //kdf\n        if (readOpenSSHKeyString(reader).toString(\"ascii\") !== \"\")\n            throw Error(\"Unsupported key type\");\n        //keynum\n        reader.off += 4;\n\n        //sshpublength\n        reader.off += 4;\n\n        //keytype\n        if (readOpenSSHKeyString(reader).toString(\"ascii\") !== \"ssh-rsa\")\n            throw Error(\"Unsupported key type\");\n        readOpenSSHKeyString(reader);\n        readOpenSSHKeyString(reader);\n\n        reader.off += 12;\n        if (readOpenSSHKeyString(reader).toString(\"ascii\") !== \"ssh-rsa\")\n            throw Error(\"Unsupported key type\");\n\n        const n = readOpenSSHKeyString(reader);\n        const e = readOpenSSHKeyString(reader);\n        const d = readOpenSSHKeyString(reader);\n        const coeff = readOpenSSHKeyString(reader);\n        const p = readOpenSSHKeyString(reader);\n        const q = readOpenSSHKeyString(reader);\n\n        //Calculate missing values\n        const dint = new BigInteger(d);\n        const qint = new BigInteger(q);\n        const pint = new BigInteger(p);\n        const dp = dint.mod(pint.subtract(BigInteger.ONE));\n        const dq = dint.mod(qint.subtract(BigInteger.ONE));\n\n        key.setPrivate(\n            n,  // modulus\n            e,  // publicExponent\n            d,  // privateExponent\n            p,  // prime1\n            q,  // prime2\n            dp.toBuffer(),  // exponent1 -- d mod (p1)\n            dq.toBuffer(),  // exponent2 -- d mod (q-1)\n            coeff  // coefficient -- (inverse of q) mod p\n        );\n\n        key.sshcomment = readOpenSSHKeyString(reader).toString(\"ascii\");\n    },\n\n    publicExport: function (key, options) {\n        let ebuf = Buffer.alloc(4)\n        ebuf.writeUInt32BE(key.e, 0);\n        //Slice leading zeroes\n        while (ebuf[0] === 0) ebuf = ebuf.slice(1);\n        const nbuf = key.n.toBuffer();\n        const buf = Buffer.alloc(\n            ebuf.byteLength + 4 +\n            nbuf.byteLength + 4 +\n            \"ssh-rsa\".length + 4\n        );\n\n        const writer = {buf: buf, off: 0};\n        writeOpenSSHKeyString(writer, Buffer.from(\"ssh-rsa\"));\n        writeOpenSSHKeyString(writer, ebuf);\n        writeOpenSSHKeyString(writer, nbuf);\n\n        let comment = key.sshcomment || \"\";\n\n        if (options.type === \"der\") {\n            return writer.buf\n        } else {\n            return \"ssh-rsa \" + buf.toString(\"base64\") + \" \" + comment + \"\\n\";\n        }\n    },\n\n    publicImport: function (key, data, options) {\n        options = options || {};\n        var buffer;\n\n        if (options.type !== \"der\") {\n            if (Buffer.isBuffer(data)) {\n                data = data.toString(\"utf8\");\n            }\n\n            if (_.isString(data)) {\n                if (data.substring(0, 8) !== \"ssh-rsa \")\n                    throw Error(\"Unsupported key format\");\n                let pemEnd = data.indexOf(\" \", 8);\n\n                //Handle keys with no comment\n                if (pemEnd === -1) {\n                    pemEnd = data.length;\n                } else {\n                    key.sshcomment = data.substring(pemEnd + 1)\n                        .replace(/\\s+|\\n\\r|\\n|\\r$/gm, \"\");\n                }\n\n                const pem = data.substring(8, pemEnd)\n                    .replace(/\\s+|\\n\\r|\\n|\\r$/gm, \"\");\n                buffer = Buffer.from(pem, \"base64\");\n            } else {\n                throw Error(\"Unsupported key format\");\n            }\n        } else if (Buffer.isBuffer(data)) {\n            buffer = data;\n        } else {\n            throw Error(\"Unsupported key format\");\n        }\n\n        const reader = {buf: buffer, off: 0};\n\n        const type = readOpenSSHKeyString(reader).toString(\"ascii\");\n\n        if (type !== \"ssh-rsa\")\n            throw Error(\"Invalid key type: \" + type);\n\n        const e = readOpenSSHKeyString(reader);\n        const n = readOpenSSHKeyString(reader);\n\n        key.setPublic(\n            n,\n            e\n        );\n    },\n\n    /**\n     * Trying autodetect and import key\n     * @param key\n     * @param data\n     */\n    autoImport: function (key, data) {\n        // [\\S\\s]* matches zero or more of any character\n        if (/^[\\S\\s]*-----BEGIN OPENSSH PRIVATE KEY-----\\s*(?=(([A-Za-z0-9+/=]+\\s*)+))\\1-----END OPENSSH PRIVATE KEY-----[\\S\\s]*$/g.test(data)) {\n            module.exports.privateImport(key, data);\n            return true;\n        }\n\n        if (/^[\\S\\s]*ssh-rsa \\s*(?=(([A-Za-z0-9+/=]+\\s*)+))\\1[\\S\\s]*$/g.test(data)) {\n            module.exports.publicImport(key, data);\n            return true;\n        }\n\n        return false;\n    }\n};\n\nfunction readOpenSSHKeyString(reader) {\n    const len = reader.buf.readInt32BE(reader.off);\n    reader.off += 4;\n    const res = reader.buf.slice(reader.off, reader.off + len);\n    reader.off += len;\n    return res;\n}\n\nfunction writeOpenSSHKeyString(writer, data) {\n    writer.buf.writeInt32BE(data.byteLength, writer.off);\n    writer.off += 4;\n    writer.off += data.copy(writer.buf, writer.off);\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}