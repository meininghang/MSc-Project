{"ast":null,"code":"var ber = require('asn1').Ber;\nvar _ = require('../utils')._;\nvar PUBLIC_RSA_OID = '1.2.840.113549.1.1.1';\nvar utils = require('../utils');\nconst PRIVATE_OPENING_BOUNDARY = '-----BEGIN PRIVATE KEY-----';\nconst PRIVATE_CLOSING_BOUNDARY = '-----END PRIVATE KEY-----';\nconst PUBLIC_OPENING_BOUNDARY = '-----BEGIN PUBLIC KEY-----';\nconst PUBLIC_CLOSING_BOUNDARY = '-----END PUBLIC KEY-----';\nmodule.exports = {\n  privateExport: function (key, options) {\n    options = options || {};\n    var n = key.n.toBuffer();\n    var d = key.d.toBuffer();\n    var p = key.p.toBuffer();\n    var q = key.q.toBuffer();\n    var dmp1 = key.dmp1.toBuffer();\n    var dmq1 = key.dmq1.toBuffer();\n    var coeff = key.coeff.toBuffer();\n    var length = n.length + d.length + p.length + q.length + dmp1.length + dmq1.length + coeff.length + 512; // magic\n    var bodyWriter = new ber.Writer({\n      size: length\n    });\n    bodyWriter.startSequence();\n    bodyWriter.writeInt(0);\n    bodyWriter.writeBuffer(n, 2);\n    bodyWriter.writeInt(key.e);\n    bodyWriter.writeBuffer(d, 2);\n    bodyWriter.writeBuffer(p, 2);\n    bodyWriter.writeBuffer(q, 2);\n    bodyWriter.writeBuffer(dmp1, 2);\n    bodyWriter.writeBuffer(dmq1, 2);\n    bodyWriter.writeBuffer(coeff, 2);\n    bodyWriter.endSequence();\n    var writer = new ber.Writer({\n      size: length\n    });\n    writer.startSequence();\n    writer.writeInt(0);\n    writer.startSequence();\n    writer.writeOID(PUBLIC_RSA_OID);\n    writer.writeNull();\n    writer.endSequence();\n    writer.writeBuffer(bodyWriter.buffer, 4);\n    writer.endSequence();\n    if (options.type === 'der') {\n      return writer.buffer;\n    } else {\n      return PRIVATE_OPENING_BOUNDARY + '\\n' + utils.linebrk(writer.buffer.toString('base64'), 64) + '\\n' + PRIVATE_CLOSING_BOUNDARY;\n    }\n  },\n  privateImport: function (key, data, options) {\n    options = options || {};\n    var buffer;\n    if (options.type !== 'der') {\n      if (Buffer.isBuffer(data)) {\n        data = data.toString('utf8');\n      }\n      if (_.isString(data)) {\n        var pem = utils.trimSurroundingText(data, PRIVATE_OPENING_BOUNDARY, PRIVATE_CLOSING_BOUNDARY).replace('-----END PRIVATE KEY-----', '').replace(/\\s+|\\n\\r|\\n|\\r$/gm, '');\n        buffer = Buffer.from(pem, 'base64');\n      } else {\n        throw Error('Unsupported key format');\n      }\n    } else if (Buffer.isBuffer(data)) {\n      buffer = data;\n    } else {\n      throw Error('Unsupported key format');\n    }\n    var reader = new ber.Reader(buffer);\n    reader.readSequence();\n    reader.readInt(0);\n    var header = new ber.Reader(reader.readString(0x30, true));\n    if (header.readOID(0x06, true) !== PUBLIC_RSA_OID) {\n      throw Error('Invalid Public key format');\n    }\n    var body = new ber.Reader(reader.readString(0x04, true));\n    body.readSequence();\n    body.readString(2, true); // just zero\n    key.setPrivate(body.readString(2, true),\n    // modulus\n    body.readString(2, true),\n    // publicExponent\n    body.readString(2, true),\n    // privateExponent\n    body.readString(2, true),\n    // prime1\n    body.readString(2, true),\n    // prime2\n    body.readString(2, true),\n    // exponent1 -- d mod (p1)\n    body.readString(2, true),\n    // exponent2 -- d mod (q-1)\n    body.readString(2, true) // coefficient -- (inverse of q) mod p\n    );\n  },\n\n  publicExport: function (key, options) {\n    options = options || {};\n    var n = key.n.toBuffer();\n    var length = n.length + 512; // magic\n\n    var bodyWriter = new ber.Writer({\n      size: length\n    });\n    bodyWriter.writeByte(0);\n    bodyWriter.startSequence();\n    bodyWriter.writeBuffer(n, 2);\n    bodyWriter.writeInt(key.e);\n    bodyWriter.endSequence();\n    var writer = new ber.Writer({\n      size: length\n    });\n    writer.startSequence();\n    writer.startSequence();\n    writer.writeOID(PUBLIC_RSA_OID);\n    writer.writeNull();\n    writer.endSequence();\n    writer.writeBuffer(bodyWriter.buffer, 3);\n    writer.endSequence();\n    if (options.type === 'der') {\n      return writer.buffer;\n    } else {\n      return PUBLIC_OPENING_BOUNDARY + '\\n' + utils.linebrk(writer.buffer.toString('base64'), 64) + '\\n' + PUBLIC_CLOSING_BOUNDARY;\n    }\n  },\n  publicImport: function (key, data, options) {\n    options = options || {};\n    var buffer;\n    if (options.type !== 'der') {\n      if (Buffer.isBuffer(data)) {\n        data = data.toString('utf8');\n      }\n      if (_.isString(data)) {\n        var pem = utils.trimSurroundingText(data, PUBLIC_OPENING_BOUNDARY, PUBLIC_CLOSING_BOUNDARY).replace(/\\s+|\\n\\r|\\n|\\r$/gm, '');\n        buffer = Buffer.from(pem, 'base64');\n      }\n    } else if (Buffer.isBuffer(data)) {\n      buffer = data;\n    } else {\n      throw Error('Unsupported key format');\n    }\n    var reader = new ber.Reader(buffer);\n    reader.readSequence();\n    var header = new ber.Reader(reader.readString(0x30, true));\n    if (header.readOID(0x06, true) !== PUBLIC_RSA_OID) {\n      throw Error('Invalid Public key format');\n    }\n    var body = new ber.Reader(reader.readString(0x03, true));\n    body.readByte();\n    body.readSequence();\n    key.setPublic(body.readString(0x02, true),\n    // modulus\n    body.readString(0x02, true) // publicExponent\n    );\n  },\n\n  /**\n   * Trying autodetect and import key\n   * @param key\n   * @param data\n   */\n  autoImport: function (key, data) {\n    if (/^[\\S\\s]*-----BEGIN PRIVATE KEY-----\\s*(?=(([A-Za-z0-9+/=]+\\s*)+))\\1-----END PRIVATE KEY-----[\\S\\s]*$/g.test(data)) {\n      module.exports.privateImport(key, data);\n      return true;\n    }\n    if (/^[\\S\\s]*-----BEGIN PUBLIC KEY-----\\s*(?=(([A-Za-z0-9+/=]+\\s*)+))\\1-----END PUBLIC KEY-----[\\S\\s]*$/g.test(data)) {\n      module.exports.publicImport(key, data);\n      return true;\n    }\n    return false;\n  }\n};","map":{"version":3,"names":["ber","require","Ber","_","PUBLIC_RSA_OID","utils","PRIVATE_OPENING_BOUNDARY","PRIVATE_CLOSING_BOUNDARY","PUBLIC_OPENING_BOUNDARY","PUBLIC_CLOSING_BOUNDARY","module","exports","privateExport","key","options","n","toBuffer","d","p","q","dmp1","dmq1","coeff","length","bodyWriter","Writer","size","startSequence","writeInt","writeBuffer","e","endSequence","writer","writeOID","writeNull","buffer","type","linebrk","toString","privateImport","data","Buffer","isBuffer","isString","pem","trimSurroundingText","replace","from","Error","reader","Reader","readSequence","readInt","header","readString","readOID","body","setPrivate","publicExport","writeByte","publicImport","readByte","setPublic","autoImport","test"],"sources":["E:/Amanda-project/vue2-project/project-vue2/node_modules/node-rsa/src/formats/pkcs8.js"],"sourcesContent":["var ber = require('asn1').Ber;\nvar _ = require('../utils')._;\nvar PUBLIC_RSA_OID = '1.2.840.113549.1.1.1';\nvar utils = require('../utils');\n\nconst PRIVATE_OPENING_BOUNDARY = '-----BEGIN PRIVATE KEY-----';\nconst PRIVATE_CLOSING_BOUNDARY = '-----END PRIVATE KEY-----';\n\nconst PUBLIC_OPENING_BOUNDARY = '-----BEGIN PUBLIC KEY-----';\nconst PUBLIC_CLOSING_BOUNDARY = '-----END PUBLIC KEY-----';\n\nmodule.exports = {\n    privateExport: function (key, options) {\n        options = options || {};\n\n        var n = key.n.toBuffer();\n        var d = key.d.toBuffer();\n        var p = key.p.toBuffer();\n        var q = key.q.toBuffer();\n        var dmp1 = key.dmp1.toBuffer();\n        var dmq1 = key.dmq1.toBuffer();\n        var coeff = key.coeff.toBuffer();\n\n        var length = n.length + d.length + p.length + q.length + dmp1.length + dmq1.length + coeff.length + 512; // magic\n        var bodyWriter = new ber.Writer({size: length});\n\n        bodyWriter.startSequence();\n        bodyWriter.writeInt(0);\n        bodyWriter.writeBuffer(n, 2);\n        bodyWriter.writeInt(key.e);\n        bodyWriter.writeBuffer(d, 2);\n        bodyWriter.writeBuffer(p, 2);\n        bodyWriter.writeBuffer(q, 2);\n        bodyWriter.writeBuffer(dmp1, 2);\n        bodyWriter.writeBuffer(dmq1, 2);\n        bodyWriter.writeBuffer(coeff, 2);\n        bodyWriter.endSequence();\n\n        var writer = new ber.Writer({size: length});\n        writer.startSequence();\n        writer.writeInt(0);\n        writer.startSequence();\n        writer.writeOID(PUBLIC_RSA_OID);\n        writer.writeNull();\n        writer.endSequence();\n        writer.writeBuffer(bodyWriter.buffer, 4);\n        writer.endSequence();\n\n        if (options.type === 'der') {\n            return writer.buffer;\n        } else {\n            return PRIVATE_OPENING_BOUNDARY + '\\n' + utils.linebrk(writer.buffer.toString('base64'), 64) + '\\n' + PRIVATE_CLOSING_BOUNDARY;\n        }\n    },\n\n    privateImport: function (key, data, options) {\n        options = options || {};\n        var buffer;\n\n        if (options.type !== 'der') {\n            if (Buffer.isBuffer(data)) {\n                data = data.toString('utf8');\n            }\n\n            if (_.isString(data)) {\n                var pem = utils.trimSurroundingText(data, PRIVATE_OPENING_BOUNDARY, PRIVATE_CLOSING_BOUNDARY)\n                    .replace('-----END PRIVATE KEY-----', '')\n                    .replace(/\\s+|\\n\\r|\\n|\\r$/gm, '');\n                buffer = Buffer.from(pem, 'base64');\n            } else {\n                throw Error('Unsupported key format');\n            }\n        } else if (Buffer.isBuffer(data)) {\n            buffer = data;\n        } else {\n            throw Error('Unsupported key format');\n        }\n\n        var reader = new ber.Reader(buffer);\n        reader.readSequence();\n        reader.readInt(0);\n        var header = new ber.Reader(reader.readString(0x30, true));\n\n        if (header.readOID(0x06, true) !== PUBLIC_RSA_OID) {\n            throw Error('Invalid Public key format');\n        }\n\n        var body = new ber.Reader(reader.readString(0x04, true));\n        body.readSequence();\n        body.readString(2, true); // just zero\n        key.setPrivate(\n            body.readString(2, true),  // modulus\n            body.readString(2, true),  // publicExponent\n            body.readString(2, true),  // privateExponent\n            body.readString(2, true),  // prime1\n            body.readString(2, true),  // prime2\n            body.readString(2, true),  // exponent1 -- d mod (p1)\n            body.readString(2, true),  // exponent2 -- d mod (q-1)\n            body.readString(2, true)   // coefficient -- (inverse of q) mod p\n        );\n    },\n\n    publicExport: function (key, options) {\n        options = options || {};\n\n        var n = key.n.toBuffer();\n        var length = n.length + 512; // magic\n\n        var bodyWriter = new ber.Writer({size: length});\n        bodyWriter.writeByte(0);\n        bodyWriter.startSequence();\n        bodyWriter.writeBuffer(n, 2);\n        bodyWriter.writeInt(key.e);\n        bodyWriter.endSequence();\n\n        var writer = new ber.Writer({size: length});\n        writer.startSequence();\n        writer.startSequence();\n        writer.writeOID(PUBLIC_RSA_OID);\n        writer.writeNull();\n        writer.endSequence();\n        writer.writeBuffer(bodyWriter.buffer, 3);\n        writer.endSequence();\n\n        if (options.type === 'der') {\n            return writer.buffer;\n        } else {\n            return PUBLIC_OPENING_BOUNDARY + '\\n' + utils.linebrk(writer.buffer.toString('base64'), 64) + '\\n' + PUBLIC_CLOSING_BOUNDARY;\n        }\n    },\n\n    publicImport: function (key, data, options) {\n        options = options || {};\n        var buffer;\n\n        if (options.type !== 'der') {\n            if (Buffer.isBuffer(data)) {\n                data = data.toString('utf8');\n            }\n\n            if (_.isString(data)) {\n                var pem = utils.trimSurroundingText(data, PUBLIC_OPENING_BOUNDARY, PUBLIC_CLOSING_BOUNDARY)\n                    .replace(/\\s+|\\n\\r|\\n|\\r$/gm, '');\n                buffer = Buffer.from(pem, 'base64');\n            }\n        } else if (Buffer.isBuffer(data)) {\n            buffer = data;\n        } else {\n            throw Error('Unsupported key format');\n        }\n\n        var reader = new ber.Reader(buffer);\n        reader.readSequence();\n        var header = new ber.Reader(reader.readString(0x30, true));\n\n        if (header.readOID(0x06, true) !== PUBLIC_RSA_OID) {\n            throw Error('Invalid Public key format');\n        }\n\n        var body = new ber.Reader(reader.readString(0x03, true));\n        body.readByte();\n        body.readSequence();\n        key.setPublic(\n            body.readString(0x02, true), // modulus\n            body.readString(0x02, true)  // publicExponent\n        );\n    },\n\n    /**\n     * Trying autodetect and import key\n     * @param key\n     * @param data\n     */\n    autoImport: function (key, data) {\n        if (/^[\\S\\s]*-----BEGIN PRIVATE KEY-----\\s*(?=(([A-Za-z0-9+/=]+\\s*)+))\\1-----END PRIVATE KEY-----[\\S\\s]*$/g.test(data)) {\n            module.exports.privateImport(key, data);\n            return true;\n        }\n\n        if (/^[\\S\\s]*-----BEGIN PUBLIC KEY-----\\s*(?=(([A-Za-z0-9+/=]+\\s*)+))\\1-----END PUBLIC KEY-----[\\S\\s]*$/g.test(data)) {\n            module.exports.publicImport(key, data);\n            return true;\n        }\n\n        return false;\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}