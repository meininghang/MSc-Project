{"ast":null,"code":"/* jshint node: true */\n\n// TODO: Make long comparison impervious to precision loss.\n// TODO: Optimize binary comparison methods.\n\n'use strict';\n\n/** Various utilities used across this library. */\nrequire(\"core-js/modules/es.array.push.js\");\nvar crypto = require('crypto');\nvar util = require('util');\n\n// Shared buffer pool for all taps.\nvar POOL = new BufferPool(4096);\n\n/**\n * Create a new empty buffer.\n *\n * @param size {Number} The buffer's size.\n */\nfunction newBuffer(size) {\n  if (typeof Buffer.alloc == 'function') {\n    return Buffer.alloc(size);\n  } else {\n    return new Buffer(size);\n  }\n}\n\n/**\n * Create a new buffer with the input contents.\n *\n * @param data {Array|String} The buffer's data.\n * @param enc {String} Encoding, used if data is a string.\n */\nfunction bufferFrom(data, enc) {\n  if (typeof Buffer.from == 'function') {\n    return Buffer.from(data, enc);\n  } else {\n    return new Buffer(data, enc);\n  }\n}\n\n/**\n * Uppercase the first letter of a string.\n *\n * @param s {String} The string.\n */\nfunction capitalize(s) {\n  return s.charAt(0).toUpperCase() + s.slice(1);\n}\n\n/**\n * Compare two numbers.\n *\n * @param n1 {Number} The first one.\n * @param n2 {Number} The second one.\n */\nfunction compare(n1, n2) {\n  return n1 === n2 ? 0 : n1 < n2 ? -1 : 1;\n}\n\n/**\n * Get option or default if undefined.\n *\n * @param opts {Object} Options.\n * @param key {String} Name of the option.\n * @param def {...} Default value.\n *\n * This is useful mostly for true-ish defaults and false-ish values (where the\n * usual `||` idiom breaks down).\n */\nfunction getOption(opts, key, def) {\n  var value = opts[key];\n  return value === undefined ? def : value;\n}\n\n/**\n * Compute a string's hash.\n *\n * @param str {String} The string to hash.\n * @param algorithm {String} The algorithm used. Defaults to MD5.\n */\nfunction getHash(str, algorithm) {\n  algorithm = algorithm || 'md5';\n  var hash = crypto.createHash(algorithm);\n  hash.end(str);\n  return hash.read();\n}\n\n/**\n * Find index of value in array.\n *\n * @param arr {Array} Can also be a false-ish value.\n * @param v {Object} Value to find.\n *\n * Returns -1 if not found, -2 if found multiple times.\n */\nfunction singleIndexOf(arr, v) {\n  var pos = -1;\n  var i, l;\n  if (!arr) {\n    return -1;\n  }\n  for (i = 0, l = arr.length; i < l; i++) {\n    if (arr[i] === v) {\n      if (pos >= 0) {\n        return -2;\n      }\n      pos = i;\n    }\n  }\n  return pos;\n}\n\n/**\n * Convert array to map.\n *\n * @param arr {Array} Elements.\n * @param fn {Function} Function returning an element's key.\n */\nfunction toMap(arr, fn) {\n  var obj = {};\n  var i, elem;\n  for (i = 0; i < arr.length; i++) {\n    elem = arr[i];\n    obj[fn(elem)] = elem;\n  }\n  return obj;\n}\n\n/**\n * Convert map to array of values (polyfill for `Object.values`).\n *\n * @param obj {Object} Map.\n */\nfunction objectValues(obj) {\n  return Object.keys(obj).map(function (key) {\n    return obj[key];\n  });\n}\n\n/**\n * Check whether an array has duplicates.\n *\n * @param arr {Array} The array.\n * @param fn {Function} Optional function to apply to each element.\n */\nfunction hasDuplicates(arr, fn) {\n  var obj = {};\n  var i, l, elem;\n  for (i = 0, l = arr.length; i < l; i++) {\n    elem = arr[i];\n    if (fn) {\n      elem = fn(elem);\n    }\n    if (obj[elem]) {\n      return true;\n    }\n    obj[elem] = true;\n  }\n  return false;\n}\n\n/**\n * Copy properties from one object to another.\n *\n * @param src {Object} The source object.\n * @param dst {Object} The destination object.\n * @param overwrite {Boolean} Whether to overwrite existing destination\n * properties. Defaults to false.\n */\nfunction copyOwnProperties(src, dst, overwrite) {\n  var names = Object.getOwnPropertyNames(src);\n  var i, l, name;\n  for (i = 0, l = names.length; i < l; i++) {\n    name = names[i];\n    if (!dst.hasOwnProperty(name) || overwrite) {\n      var descriptor = Object.getOwnPropertyDescriptor(src, name);\n      Object.defineProperty(dst, name, descriptor);\n    }\n  }\n  return dst;\n}\n\n/**\n * Returns offset in the string of the end of JSON object (-1 if past the end).\n *\n * To keep the implementation simple, this function isn't a JSON validator. It\n * will gladly return a result for invalid JSON (which is OK since that will be\n * promptly rejected by the JSON parser). What matters is that it is guaranteed\n * to return the correct end when presented with valid JSON.\n *\n * @param str {String} Input string containing serialized JSON..\n * @param pos {Number} Starting position.\n */\nfunction jsonEnd(str, pos) {\n  pos = pos | 0;\n\n  // Handle the case of a simple literal separately.\n  var c = str.charAt(pos++);\n  if (/[\\d-]/.test(c)) {\n    while (/[eE\\d.+-]/.test(str.charAt(pos))) {\n      pos++;\n    }\n    return pos;\n  } else if (/true|null/.test(str.slice(pos - 1, pos + 3))) {\n    return pos + 3;\n  } else if (/false/.test(str.slice(pos - 1, pos + 4))) {\n    return pos + 4;\n  }\n\n  // String, object, or array.\n  var depth = 0;\n  var literal = false;\n  do {\n    switch (c) {\n      case '{':\n      case '[':\n        if (!literal) {\n          depth++;\n        }\n        break;\n      case '}':\n      case ']':\n        if (!literal && ! --depth) {\n          return pos;\n        }\n        break;\n      case '\"':\n        literal = !literal;\n        if (!depth && !literal) {\n          return pos;\n        }\n        break;\n      case '\\\\':\n        pos++;\n      // Skip the next character.\n    }\n  } while (c = str.charAt(pos++));\n  return -1;\n}\n\n/** \"Abstract\" function to help with \"subclassing\". */\nfunction abstractFunction() {\n  throw new Error('abstract');\n}\n\n/** Batch-deprecate \"getters\" from an object's prototype. */\nfunction addDeprecatedGetters(obj, props) {\n  var proto = obj.prototype;\n  var i, l, prop, getter;\n  for (i = 0, l = props.length; i < l; i++) {\n    prop = props[i];\n    getter = 'get' + capitalize(prop);\n    proto[getter] = util.deprecate(createGetter(prop), 'use `.' + prop + '` instead of `.' + getter + '()`');\n  }\n  function createGetter(prop) {\n    return function () {\n      var delegate = this[prop];\n      return typeof delegate == 'function' ? delegate.apply(this, arguments) : delegate;\n    };\n  }\n}\n\n/**\n * Simple buffer pool to avoid allocating many small buffers.\n *\n * This provides significant speedups in recent versions of node (6+).\n */\nfunction BufferPool(len) {\n  this._len = len | 0;\n  this._pos = 0;\n  this._slab = newBuffer(this._len);\n}\nBufferPool.prototype.alloc = function (len) {\n  var maxLen = this._len;\n  if (len > maxLen) {\n    return newBuffer(len);\n  }\n  if (this._pos + len > maxLen) {\n    this._slab = newBuffer(maxLen);\n    this._pos = 0;\n  }\n  return this._slab.slice(this._pos, this._pos += len);\n};\n\n/**\n * Generator of random things.\n *\n * Inspired by: http://stackoverflow.com/a/424445/1062617\n */\nfunction Lcg(seed) {\n  var a = 1103515245;\n  var c = 12345;\n  var m = Math.pow(2, 31);\n  var state = Math.floor(seed || Math.random() * (m - 1));\n  this._max = m;\n  this._nextInt = function () {\n    return state = (a * state + c) % m;\n  };\n}\nLcg.prototype.nextBoolean = function () {\n  // jshint -W018\n  return !!(this._nextInt() % 2);\n};\nLcg.prototype.nextInt = function (start, end) {\n  if (end === undefined) {\n    end = start;\n    start = 0;\n  }\n  end = end === undefined ? this._max : end;\n  return start + Math.floor(this.nextFloat() * (end - start));\n};\nLcg.prototype.nextFloat = function (start, end) {\n  if (end === undefined) {\n    end = start;\n    start = 0;\n  }\n  end = end === undefined ? 1 : end;\n  return start + (end - start) * this._nextInt() / this._max;\n};\nLcg.prototype.nextString = function (len, flags) {\n  len |= 0;\n  flags = flags || 'aA';\n  var mask = '';\n  if (flags.indexOf('a') > -1) {\n    mask += 'abcdefghijklmnopqrstuvwxyz';\n  }\n  if (flags.indexOf('A') > -1) {\n    mask += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  }\n  if (flags.indexOf('#') > -1) {\n    mask += '0123456789';\n  }\n  if (flags.indexOf('!') > -1) {\n    mask += '~`!@#$%^&*()_+-={}[]:\";\\'<>?,./|\\\\';\n  }\n  var result = [];\n  for (var i = 0; i < len; i++) {\n    result.push(this.choice(mask));\n  }\n  return result.join('');\n};\nLcg.prototype.nextBuffer = function (len) {\n  var arr = [];\n  var i;\n  for (i = 0; i < len; i++) {\n    arr.push(this.nextInt(256));\n  }\n  return bufferFrom(arr);\n};\nLcg.prototype.choice = function (arr) {\n  var len = arr.length;\n  if (!len) {\n    throw new Error('choosing from empty array');\n  }\n  return arr[this.nextInt(len)];\n};\n\n/**\n * Ordered queue which returns items consecutively.\n *\n * This is actually a heap by index, with the added requirements that elements\n * can only be retrieved consecutively.\n */\nfunction OrderedQueue() {\n  this._index = 0;\n  this._items = [];\n}\nOrderedQueue.prototype.push = function (item) {\n  var items = this._items;\n  var i = items.length | 0;\n  var j;\n  items.push(item);\n  while (i > 0 && items[i].index < items[j = i - 1 >> 1].index) {\n    item = items[i];\n    items[i] = items[j];\n    items[j] = item;\n    i = j;\n  }\n};\nOrderedQueue.prototype.pop = function () {\n  var items = this._items;\n  var len = items.length - 1 | 0;\n  var first = items[0];\n  if (!first || first.index > this._index) {\n    return null;\n  }\n  this._index++;\n  if (!len) {\n    items.pop();\n    return first;\n  }\n  items[0] = items.pop();\n  var mid = len >> 1;\n  var i = 0;\n  var i1, i2, j, item, c, c1, c2;\n  while (i < mid) {\n    item = items[i];\n    i1 = (i << 1) + 1;\n    i2 = i + 1 << 1;\n    c1 = items[i1];\n    c2 = items[i2];\n    if (!c2 || c1.index <= c2.index) {\n      c = c1;\n      j = i1;\n    } else {\n      c = c2;\n      j = i2;\n    }\n    if (c.index >= item.index) {\n      break;\n    }\n    items[j] = item;\n    items[i] = c;\n    i = j;\n  }\n  return first;\n};\n\n/**\n * A tap is a buffer which remembers what has been already read.\n *\n * It is optimized for performance, at the cost of failing silently when\n * overflowing the buffer. This is a purposeful trade-off given the expected\n * rarity of this case and the large performance hit necessary to enforce\n * validity. See `isValid` below for more information.\n */\nfunction Tap(buf, pos) {\n  this.buf = buf;\n  this.pos = pos | 0;\n  if (this.pos < 0) {\n    throw new Error('negative offset');\n  }\n}\n\n/**\n * Check that the tap is in a valid state.\n *\n * For efficiency reasons, none of the methods below will fail if an overflow\n * occurs (either read, skip, or write). For this reason, it is up to the\n * caller to always check that the read, skip, or write was valid by calling\n * this method.\n */\nTap.prototype.isValid = function () {\n  return this.pos <= this.buf.length;\n};\n\n// Read, skip, write methods.\n//\n// These should fail silently when the buffer overflows. Note this is only\n// required to be true when the functions are decoding valid objects. For\n// example errors will still be thrown if a bad count is read, leading to a\n// negative position offset (which will typically cause a failure in\n// `readFixed`).\n\nTap.prototype.readBoolean = function () {\n  return !!this.buf[this.pos++];\n};\nTap.prototype.skipBoolean = function () {\n  this.pos++;\n};\nTap.prototype.writeBoolean = function (b) {\n  this.buf[this.pos++] = !!b;\n};\nTap.prototype.readInt = Tap.prototype.readLong = function () {\n  var n = 0;\n  var k = 0;\n  var buf = this.buf;\n  var b, h, f, fk;\n  do {\n    b = buf[this.pos++];\n    h = b & 0x80;\n    n |= (b & 0x7f) << k;\n    k += 7;\n  } while (h && k < 28);\n  if (h) {\n    // Switch to float arithmetic, otherwise we might overflow.\n    f = n;\n    fk = 268435456; // 2 ** 28.\n    do {\n      b = buf[this.pos++];\n      f += (b & 0x7f) * fk;\n      fk *= 128;\n    } while (b & 0x80);\n    return (f % 2 ? -(f + 1) : f) / 2;\n  }\n  return n >> 1 ^ -(n & 1);\n};\nTap.prototype.skipInt = Tap.prototype.skipLong = function () {\n  var buf = this.buf;\n  while (buf[this.pos++] & 0x80) {}\n};\nTap.prototype.writeInt = Tap.prototype.writeLong = function (n) {\n  var buf = this.buf;\n  var f, m;\n  if (n >= -1073741824 && n < 1073741824) {\n    // Won't overflow, we can use integer arithmetic.\n    m = n >= 0 ? n << 1 : ~n << 1 | 1;\n    do {\n      buf[this.pos] = m & 0x7f;\n      m >>= 7;\n    } while (m && (buf[this.pos++] |= 0x80));\n  } else {\n    // We have to use slower floating arithmetic.\n    f = n >= 0 ? n * 2 : -n * 2 - 1;\n    do {\n      buf[this.pos] = f & 0x7f;\n      f /= 128;\n    } while (f >= 1 && (buf[this.pos++] |= 0x80));\n  }\n  this.pos++;\n};\nTap.prototype.readFloat = function () {\n  var buf = this.buf;\n  var pos = this.pos;\n  this.pos += 4;\n  if (this.pos > buf.length) {\n    return;\n  }\n  return this.buf.readFloatLE(pos);\n};\nTap.prototype.skipFloat = function () {\n  this.pos += 4;\n};\nTap.prototype.writeFloat = function (f) {\n  var buf = this.buf;\n  var pos = this.pos;\n  this.pos += 4;\n  if (this.pos > buf.length) {\n    return;\n  }\n  return this.buf.writeFloatLE(f, pos);\n};\nTap.prototype.readDouble = function () {\n  var buf = this.buf;\n  var pos = this.pos;\n  this.pos += 8;\n  if (this.pos > buf.length) {\n    return;\n  }\n  return this.buf.readDoubleLE(pos);\n};\nTap.prototype.skipDouble = function () {\n  this.pos += 8;\n};\nTap.prototype.writeDouble = function (d) {\n  var buf = this.buf;\n  var pos = this.pos;\n  this.pos += 8;\n  if (this.pos > buf.length) {\n    return;\n  }\n  return this.buf.writeDoubleLE(d, pos);\n};\nTap.prototype.readFixed = function (len) {\n  var pos = this.pos;\n  this.pos += len;\n  if (this.pos > this.buf.length) {\n    return;\n  }\n  var fixed = POOL.alloc(len);\n  this.buf.copy(fixed, 0, pos, pos + len);\n  return fixed;\n};\nTap.prototype.skipFixed = function (len) {\n  this.pos += len;\n};\nTap.prototype.writeFixed = function (buf, len) {\n  len = len || buf.length;\n  var pos = this.pos;\n  this.pos += len;\n  if (this.pos > this.buf.length) {\n    return;\n  }\n  buf.copy(this.buf, pos, 0, len);\n};\nTap.prototype.readBytes = function () {\n  return this.readFixed(this.readLong());\n};\nTap.prototype.skipBytes = function () {\n  var len = this.readLong();\n  this.pos += len;\n};\nTap.prototype.writeBytes = function (buf) {\n  var len = buf.length;\n  this.writeLong(len);\n  this.writeFixed(buf, len);\n};\n\n/* istanbul ignore else */\nif (typeof Buffer.prototype.utf8Slice == 'function') {\n  // Use this optimized function when available.\n  Tap.prototype.readString = function () {\n    var len = this.readLong();\n    var pos = this.pos;\n    var buf = this.buf;\n    this.pos += len;\n    if (this.pos > buf.length) {\n      return;\n    }\n    return this.buf.utf8Slice(pos, pos + len);\n  };\n} else {\n  Tap.prototype.readString = function () {\n    var len = this.readLong();\n    var pos = this.pos;\n    var buf = this.buf;\n    this.pos += len;\n    if (this.pos > buf.length) {\n      return;\n    }\n    return this.buf.slice(pos, pos + len).toString();\n  };\n}\nTap.prototype.skipString = function () {\n  var len = this.readLong();\n  this.pos += len;\n};\nTap.prototype.writeString = function (s) {\n  var len = Buffer.byteLength(s);\n  var buf = this.buf;\n  this.writeLong(len);\n  var pos = this.pos;\n  this.pos += len;\n  if (this.pos > buf.length) {\n    return;\n  }\n  if (len > 64) {\n    this._writeUtf8(s, len);\n  } else {\n    var i, l, c1, c2;\n    for (i = 0, l = len; i < l; i++) {\n      c1 = s.charCodeAt(i);\n      if (c1 < 0x80) {\n        buf[pos++] = c1;\n      } else if (c1 < 0x800) {\n        buf[pos++] = c1 >> 6 | 0xc0;\n        buf[pos++] = c1 & 0x3f | 0x80;\n      } else if ((c1 & 0xfc00) === 0xd800 && ((c2 = s.charCodeAt(i + 1)) & 0xfc00) === 0xdc00) {\n        c1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff);\n        i++;\n        buf[pos++] = c1 >> 18 | 0xf0;\n        buf[pos++] = c1 >> 12 & 0x3f | 0x80;\n        buf[pos++] = c1 >> 6 & 0x3f | 0x80;\n        buf[pos++] = c1 & 0x3f | 0x80;\n      } else {\n        buf[pos++] = c1 >> 12 | 0xe0;\n        buf[pos++] = c1 >> 6 & 0x3f | 0x80;\n        buf[pos++] = c1 & 0x3f | 0x80;\n      }\n    }\n  }\n};\n\n/* istanbul ignore else */\nif (typeof Buffer.prototype.utf8Write == 'function') {\n  Tap.prototype._writeUtf8 = function (str, len) {\n    this.buf.utf8Write(str, this.pos - len, len);\n  };\n} else {\n  // `utf8Write` isn't available in the browser.\n  Tap.prototype._writeUtf8 = function (str, len) {\n    this.buf.write(str, this.pos - len, len, 'utf8');\n  };\n}\n\n/* istanbul ignore else */\nif (typeof Buffer.prototype.latin1Write == 'function') {\n  // `binaryWrite` has been renamed to `latin1Write` in Node v6.4.0, see\n  // https://github.com/nodejs/node/pull/7111. Note that the `'binary'`\n  // encoding argument still works however.\n  Tap.prototype.writeBinary = function (str, len) {\n    var pos = this.pos;\n    this.pos += len;\n    if (this.pos > this.buf.length) {\n      return;\n    }\n    this.buf.latin1Write(str, pos, len);\n  };\n} else if (typeof Buffer.prototype.binaryWrite == 'function') {\n  Tap.prototype.writeBinary = function (str, len) {\n    var pos = this.pos;\n    this.pos += len;\n    if (this.pos > this.buf.length) {\n      return;\n    }\n    this.buf.binaryWrite(str, pos, len);\n  };\n} else {\n  // Slowest implementation.\n  Tap.prototype.writeBinary = function (s, len) {\n    var pos = this.pos;\n    this.pos += len;\n    if (this.pos > this.buf.length) {\n      return;\n    }\n    this.buf.write(s, pos, len, 'binary');\n  };\n}\n\n// Binary comparison methods.\n//\n// These are not guaranteed to consume the objects they are comparing when\n// returning a non-zero result (allowing for performance benefits), so no other\n// operations should be done on either tap after a compare returns a non-zero\n// value. Also, these methods do not have the same silent failure requirement\n// as read, skip, and write since they are assumed to be called on valid\n// buffers.\n\nTap.prototype.matchBoolean = function (tap) {\n  return this.buf[this.pos++] - tap.buf[tap.pos++];\n};\nTap.prototype.matchInt = Tap.prototype.matchLong = function (tap) {\n  var n1 = this.readLong();\n  var n2 = tap.readLong();\n  return n1 === n2 ? 0 : n1 < n2 ? -1 : 1;\n};\nTap.prototype.matchFloat = function (tap) {\n  var n1 = this.readFloat();\n  var n2 = tap.readFloat();\n  return n1 === n2 ? 0 : n1 < n2 ? -1 : 1;\n};\nTap.prototype.matchDouble = function (tap) {\n  var n1 = this.readDouble();\n  var n2 = tap.readDouble();\n  return n1 === n2 ? 0 : n1 < n2 ? -1 : 1;\n};\nTap.prototype.matchFixed = function (tap, len) {\n  return this.readFixed(len).compare(tap.readFixed(len));\n};\nTap.prototype.matchBytes = Tap.prototype.matchString = function (tap) {\n  var l1 = this.readLong();\n  var p1 = this.pos;\n  this.pos += l1;\n  var l2 = tap.readLong();\n  var p2 = tap.pos;\n  tap.pos += l2;\n  var b1 = this.buf.slice(p1, this.pos);\n  var b2 = tap.buf.slice(p2, tap.pos);\n  return b1.compare(b2);\n};\n\n// Functions for supporting custom long classes.\n//\n// The two following methods allow the long implementations to not have to\n// worry about Avro's zigzag encoding, we directly expose longs as unpacked.\n\nTap.prototype.unpackLongBytes = function () {\n  var res = newBuffer(8);\n  var n = 0;\n  var i = 0; // Byte index in target buffer.\n  var j = 6; // Bit offset in current target buffer byte.\n  var buf = this.buf;\n  var b, neg;\n  b = buf[this.pos++];\n  neg = b & 1;\n  res.fill(0);\n  n |= (b & 0x7f) >> 1;\n  while (b & 0x80) {\n    b = buf[this.pos++];\n    n |= (b & 0x7f) << j;\n    j += 7;\n    if (j >= 8) {\n      // Flush byte.\n      j -= 8;\n      res[i++] = n;\n      n >>= 8;\n    }\n  }\n  res[i] = n;\n  if (neg) {\n    invert(res, 8);\n  }\n  return res;\n};\nTap.prototype.packLongBytes = function (buf) {\n  var neg = (buf[7] & 0x80) >> 7;\n  var res = this.buf;\n  var j = 1;\n  var k = 0;\n  var m = 3;\n  var n;\n  if (neg) {\n    invert(buf, 8);\n    n = 1;\n  } else {\n    n = 0;\n  }\n  var parts = [buf.readUIntLE(0, 3), buf.readUIntLE(3, 3), buf.readUIntLE(6, 2)];\n  // Not reading more than 24 bits because we need to be able to combine the\n  // \"carry\" bits from the previous part and JavaScript only supports bitwise\n  // operations on 32 bit integers.\n  while (m && !parts[--m]) {} // Skip trailing 0s.\n\n  // Leading parts (if any), we never bail early here since we need the\n  // continuation bit to be set.\n  while (k < m) {\n    n |= parts[k++] << j;\n    j += 24;\n    while (j > 7) {\n      res[this.pos++] = n & 0x7f | 0x80;\n      n >>= 7;\n      j -= 7;\n    }\n  }\n\n  // Final part, similar to normal packing aside from the initial offset.\n  n |= parts[m] << j;\n  do {\n    res[this.pos] = n & 0x7f;\n    n >>= 7;\n  } while (n && (res[this.pos++] |= 0x80));\n  this.pos++;\n\n  // Restore original buffer (could make this optional?).\n  if (neg) {\n    invert(buf, 8);\n  }\n};\n\n// Helpers.\n\n/**\n * Invert all bits in a buffer.\n *\n * @param buf {Buffer} Non-empty buffer to invert.\n * @param len {Number} Buffer length (must be positive).\n */\nfunction invert(buf, len) {\n  while (len--) {\n    buf[len] = ~buf[len];\n  }\n}\nmodule.exports = {\n  abstractFunction: abstractFunction,\n  addDeprecatedGetters: addDeprecatedGetters,\n  bufferFrom: bufferFrom,\n  capitalize: capitalize,\n  copyOwnProperties: copyOwnProperties,\n  getHash: getHash,\n  compare: compare,\n  getOption: getOption,\n  jsonEnd: jsonEnd,\n  newBuffer: newBuffer,\n  objectValues: objectValues,\n  toMap: toMap,\n  singleIndexOf: singleIndexOf,\n  hasDuplicates: hasDuplicates,\n  Lcg: Lcg,\n  OrderedQueue: OrderedQueue,\n  Tap: Tap\n};","map":{"version":3,"names":["require","crypto","util","POOL","BufferPool","newBuffer","size","Buffer","alloc","bufferFrom","data","enc","from","capitalize","s","charAt","toUpperCase","slice","compare","n1","n2","getOption","opts","key","def","value","undefined","getHash","str","algorithm","hash","createHash","end","read","singleIndexOf","arr","v","pos","i","l","length","toMap","fn","obj","elem","objectValues","Object","keys","map","hasDuplicates","copyOwnProperties","src","dst","overwrite","names","getOwnPropertyNames","name","hasOwnProperty","descriptor","getOwnPropertyDescriptor","defineProperty","jsonEnd","c","test","depth","literal","abstractFunction","Error","addDeprecatedGetters","props","proto","prototype","prop","getter","deprecate","createGetter","delegate","apply","arguments","len","_len","_pos","_slab","maxLen","Lcg","seed","a","m","Math","pow","state","floor","random","_max","_nextInt","nextBoolean","nextInt","start","nextFloat","nextString","flags","mask","indexOf","result","push","choice","join","nextBuffer","OrderedQueue","_index","_items","item","items","j","index","pop","first","mid","i1","i2","c1","c2","Tap","buf","isValid","readBoolean","skipBoolean","writeBoolean","b","readInt","readLong","n","k","h","f","fk","skipInt","skipLong","writeInt","writeLong","readFloat","readFloatLE","skipFloat","writeFloat","writeFloatLE","readDouble","readDoubleLE","skipDouble","writeDouble","d","writeDoubleLE","readFixed","fixed","copy","skipFixed","writeFixed","readBytes","skipBytes","writeBytes","utf8Slice","readString","toString","skipString","writeString","byteLength","_writeUtf8","charCodeAt","utf8Write","write","latin1Write","writeBinary","binaryWrite","matchBoolean","tap","matchInt","matchLong","matchFloat","matchDouble","matchFixed","matchBytes","matchString","l1","p1","l2","p2","b1","b2","unpackLongBytes","res","neg","fill","invert","packLongBytes","parts","readUIntLE","module","exports"],"sources":["E:/Amanda-project/vue2-project/project-vue2/node_modules/avsc/lib/utils.js"],"sourcesContent":["/* jshint node: true */\n\n// TODO: Make long comparison impervious to precision loss.\n// TODO: Optimize binary comparison methods.\n\n'use strict';\n\n/** Various utilities used across this library. */\n\nvar crypto = require('crypto');\nvar util = require('util');\n\n// Shared buffer pool for all taps.\nvar POOL = new BufferPool(4096);\n\n/**\n * Create a new empty buffer.\n *\n * @param size {Number} The buffer's size.\n */\nfunction newBuffer(size) {\n  if (typeof Buffer.alloc == 'function') {\n    return Buffer.alloc(size);\n  } else {\n    return new Buffer(size);\n  }\n}\n\n/**\n * Create a new buffer with the input contents.\n *\n * @param data {Array|String} The buffer's data.\n * @param enc {String} Encoding, used if data is a string.\n */\nfunction bufferFrom(data, enc) {\n  if (typeof Buffer.from == 'function') {\n    return Buffer.from(data, enc);\n  } else {\n    return new Buffer(data, enc);\n  }\n}\n\n/**\n * Uppercase the first letter of a string.\n *\n * @param s {String} The string.\n */\nfunction capitalize(s) { return s.charAt(0).toUpperCase() + s.slice(1); }\n\n/**\n * Compare two numbers.\n *\n * @param n1 {Number} The first one.\n * @param n2 {Number} The second one.\n */\nfunction compare(n1, n2) { return n1 === n2 ? 0 : (n1 < n2 ? -1 : 1); }\n\n/**\n * Get option or default if undefined.\n *\n * @param opts {Object} Options.\n * @param key {String} Name of the option.\n * @param def {...} Default value.\n *\n * This is useful mostly for true-ish defaults and false-ish values (where the\n * usual `||` idiom breaks down).\n */\nfunction getOption(opts, key, def) {\n  var value = opts[key];\n  return value === undefined ? def : value;\n}\n\n/**\n * Compute a string's hash.\n *\n * @param str {String} The string to hash.\n * @param algorithm {String} The algorithm used. Defaults to MD5.\n */\nfunction getHash(str, algorithm) {\n  algorithm = algorithm || 'md5';\n  var hash = crypto.createHash(algorithm);\n  hash.end(str);\n  return hash.read();\n}\n\n/**\n * Find index of value in array.\n *\n * @param arr {Array} Can also be a false-ish value.\n * @param v {Object} Value to find.\n *\n * Returns -1 if not found, -2 if found multiple times.\n */\nfunction singleIndexOf(arr, v) {\n  var pos = -1;\n  var i, l;\n  if (!arr) {\n    return -1;\n  }\n  for (i = 0, l = arr.length; i < l; i++) {\n    if (arr[i] === v) {\n      if (pos >= 0) {\n        return -2;\n      }\n      pos = i;\n    }\n  }\n  return pos;\n}\n\n/**\n * Convert array to map.\n *\n * @param arr {Array} Elements.\n * @param fn {Function} Function returning an element's key.\n */\nfunction toMap(arr, fn) {\n  var obj = {};\n  var i, elem;\n  for (i = 0; i < arr.length; i++) {\n    elem = arr[i];\n    obj[fn(elem)] = elem;\n  }\n  return obj;\n}\n\n/**\n * Convert map to array of values (polyfill for `Object.values`).\n *\n * @param obj {Object} Map.\n */\nfunction objectValues(obj) {\n  return Object.keys(obj).map(function (key) { return obj[key]; });\n}\n\n/**\n * Check whether an array has duplicates.\n *\n * @param arr {Array} The array.\n * @param fn {Function} Optional function to apply to each element.\n */\nfunction hasDuplicates(arr, fn) {\n  var obj = {};\n  var i, l, elem;\n  for (i = 0, l = arr.length; i < l; i++) {\n    elem = arr[i];\n    if (fn) {\n      elem = fn(elem);\n    }\n    if (obj[elem]) {\n      return true;\n    }\n    obj[elem] = true;\n  }\n  return false;\n}\n\n/**\n * Copy properties from one object to another.\n *\n * @param src {Object} The source object.\n * @param dst {Object} The destination object.\n * @param overwrite {Boolean} Whether to overwrite existing destination\n * properties. Defaults to false.\n */\nfunction copyOwnProperties(src, dst, overwrite) {\n  var names = Object.getOwnPropertyNames(src);\n  var i, l, name;\n  for (i = 0, l = names.length; i < l; i++) {\n    name = names[i];\n    if (!dst.hasOwnProperty(name) || overwrite) {\n      var descriptor = Object.getOwnPropertyDescriptor(src, name);\n      Object.defineProperty(dst, name, descriptor);\n    }\n  }\n  return dst;\n}\n\n/**\n * Returns offset in the string of the end of JSON object (-1 if past the end).\n *\n * To keep the implementation simple, this function isn't a JSON validator. It\n * will gladly return a result for invalid JSON (which is OK since that will be\n * promptly rejected by the JSON parser). What matters is that it is guaranteed\n * to return the correct end when presented with valid JSON.\n *\n * @param str {String} Input string containing serialized JSON..\n * @param pos {Number} Starting position.\n */\nfunction jsonEnd(str, pos) {\n  pos = pos | 0;\n\n  // Handle the case of a simple literal separately.\n  var c = str.charAt(pos++);\n  if (/[\\d-]/.test(c)) {\n    while (/[eE\\d.+-]/.test(str.charAt(pos))) {\n      pos++;\n    }\n    return pos;\n  } else if (/true|null/.test(str.slice(pos - 1, pos + 3))) {\n    return pos + 3;\n  } else if (/false/.test(str.slice(pos - 1, pos + 4))) {\n    return pos + 4;\n  }\n\n  // String, object, or array.\n  var depth = 0;\n  var literal = false;\n  do {\n    switch (c) {\n    case '{':\n    case '[':\n      if (!literal) { depth++; }\n      break;\n    case '}':\n    case ']':\n      if (!literal && !--depth) {\n        return pos;\n      }\n      break;\n    case '\"':\n      literal = !literal;\n      if (!depth && !literal) {\n        return pos;\n      }\n      break;\n    case '\\\\':\n      pos++; // Skip the next character.\n    }\n  } while ((c = str.charAt(pos++)));\n\n  return -1;\n}\n\n/** \"Abstract\" function to help with \"subclassing\". */\nfunction abstractFunction() { throw new Error('abstract'); }\n\n/** Batch-deprecate \"getters\" from an object's prototype. */\nfunction addDeprecatedGetters(obj, props) {\n  var proto = obj.prototype;\n  var i, l, prop, getter;\n  for (i = 0, l = props.length; i < l; i++) {\n    prop = props[i];\n    getter = 'get' + capitalize(prop);\n    proto[getter] = util.deprecate(\n      createGetter(prop),\n      'use `.' + prop + '` instead of `.' + getter + '()`'\n    );\n  }\n\n  function createGetter(prop) {\n    return function () {\n      var delegate = this[prop];\n      return typeof delegate == 'function' ?\n        delegate.apply(this, arguments) :\n        delegate;\n    };\n  }\n}\n\n/**\n * Simple buffer pool to avoid allocating many small buffers.\n *\n * This provides significant speedups in recent versions of node (6+).\n */\nfunction BufferPool(len) {\n  this._len = len | 0;\n  this._pos = 0;\n  this._slab = newBuffer(this._len);\n}\n\nBufferPool.prototype.alloc = function (len) {\n  var maxLen = this._len;\n  if (len > maxLen) {\n    return newBuffer(len);\n  }\n  if (this._pos + len > maxLen) {\n    this._slab = newBuffer(maxLen);\n    this._pos = 0;\n  }\n  return this._slab.slice(this._pos, this._pos += len);\n};\n\n/**\n * Generator of random things.\n *\n * Inspired by: http://stackoverflow.com/a/424445/1062617\n */\nfunction Lcg(seed) {\n  var a = 1103515245;\n  var c = 12345;\n  var m = Math.pow(2, 31);\n  var state = Math.floor(seed || Math.random() * (m - 1));\n\n  this._max = m;\n  this._nextInt = function () { return state = (a * state + c) % m; };\n}\n\nLcg.prototype.nextBoolean = function () {\n  // jshint -W018\n  return !!(this._nextInt() % 2);\n};\n\nLcg.prototype.nextInt = function (start, end) {\n  if (end === undefined) {\n    end = start;\n    start = 0;\n  }\n  end = end === undefined ? this._max : end;\n  return start + Math.floor(this.nextFloat() * (end - start));\n};\n\nLcg.prototype.nextFloat = function (start, end) {\n  if (end === undefined) {\n    end = start;\n    start = 0;\n  }\n  end = end === undefined ? 1 : end;\n  return start + (end - start) * this._nextInt() / this._max;\n};\n\nLcg.prototype.nextString = function(len, flags) {\n  len |= 0;\n  flags = flags || 'aA';\n  var mask = '';\n  if (flags.indexOf('a') > -1) {\n    mask += 'abcdefghijklmnopqrstuvwxyz';\n  }\n  if (flags.indexOf('A') > -1) {\n    mask += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  }\n  if (flags.indexOf('#') > -1) {\n    mask += '0123456789';\n  }\n  if (flags.indexOf('!') > -1) {\n    mask += '~`!@#$%^&*()_+-={}[]:\";\\'<>?,./|\\\\';\n  }\n  var result = [];\n  for (var i = 0; i < len; i++) {\n    result.push(this.choice(mask));\n  }\n  return result.join('');\n};\n\nLcg.prototype.nextBuffer = function (len) {\n  var arr = [];\n  var i;\n  for (i = 0; i < len; i++) {\n    arr.push(this.nextInt(256));\n  }\n  return bufferFrom(arr);\n};\n\nLcg.prototype.choice = function (arr) {\n  var len = arr.length;\n  if (!len) {\n    throw new Error('choosing from empty array');\n  }\n  return arr[this.nextInt(len)];\n};\n\n/**\n * Ordered queue which returns items consecutively.\n *\n * This is actually a heap by index, with the added requirements that elements\n * can only be retrieved consecutively.\n */\nfunction OrderedQueue() {\n  this._index = 0;\n  this._items = [];\n}\n\nOrderedQueue.prototype.push = function (item) {\n  var items = this._items;\n  var i = items.length | 0;\n  var j;\n  items.push(item);\n  while (i > 0 && items[i].index < items[j = ((i - 1) >> 1)].index) {\n    item = items[i];\n    items[i] = items[j];\n    items[j] = item;\n    i = j;\n  }\n};\n\nOrderedQueue.prototype.pop = function () {\n  var items = this._items;\n  var len = (items.length - 1) | 0;\n  var first = items[0];\n  if (!first || first.index > this._index) {\n    return null;\n  }\n  this._index++;\n  if (!len) {\n    items.pop();\n    return first;\n  }\n  items[0] = items.pop();\n  var mid = len >> 1;\n  var i = 0;\n  var i1, i2, j, item, c, c1, c2;\n  while (i < mid) {\n    item = items[i];\n    i1 = (i << 1) + 1;\n    i2 = (i + 1) << 1;\n    c1 = items[i1];\n    c2 = items[i2];\n    if (!c2 || c1.index <= c2.index) {\n      c = c1;\n      j = i1;\n    } else {\n      c = c2;\n      j = i2;\n    }\n    if (c.index >= item.index) {\n      break;\n    }\n    items[j] = item;\n    items[i] = c;\n    i = j;\n  }\n  return first;\n};\n\n/**\n * A tap is a buffer which remembers what has been already read.\n *\n * It is optimized for performance, at the cost of failing silently when\n * overflowing the buffer. This is a purposeful trade-off given the expected\n * rarity of this case and the large performance hit necessary to enforce\n * validity. See `isValid` below for more information.\n */\nfunction Tap(buf, pos) {\n  this.buf = buf;\n  this.pos = pos | 0;\n  if (this.pos < 0) {\n    throw new Error('negative offset');\n  }\n}\n\n/**\n * Check that the tap is in a valid state.\n *\n * For efficiency reasons, none of the methods below will fail if an overflow\n * occurs (either read, skip, or write). For this reason, it is up to the\n * caller to always check that the read, skip, or write was valid by calling\n * this method.\n */\nTap.prototype.isValid = function () { return this.pos <= this.buf.length; };\n\n// Read, skip, write methods.\n//\n// These should fail silently when the buffer overflows. Note this is only\n// required to be true when the functions are decoding valid objects. For\n// example errors will still be thrown if a bad count is read, leading to a\n// negative position offset (which will typically cause a failure in\n// `readFixed`).\n\nTap.prototype.readBoolean = function () { return !!this.buf[this.pos++]; };\n\nTap.prototype.skipBoolean = function () { this.pos++; };\n\nTap.prototype.writeBoolean = function (b) { this.buf[this.pos++] = !!b; };\n\nTap.prototype.readInt = Tap.prototype.readLong = function () {\n  var n = 0;\n  var k = 0;\n  var buf = this.buf;\n  var b, h, f, fk;\n\n  do {\n    b = buf[this.pos++];\n    h = b & 0x80;\n    n |= (b & 0x7f) << k;\n    k += 7;\n  } while (h && k < 28);\n\n  if (h) {\n    // Switch to float arithmetic, otherwise we might overflow.\n    f = n;\n    fk = 268435456; // 2 ** 28.\n    do {\n      b = buf[this.pos++];\n      f += (b & 0x7f) * fk;\n      fk *= 128;\n    } while (b & 0x80);\n    return (f % 2 ? -(f + 1) : f) / 2;\n  }\n\n  return (n >> 1) ^ -(n & 1);\n};\n\nTap.prototype.skipInt = Tap.prototype.skipLong = function () {\n  var buf = this.buf;\n  while (buf[this.pos++] & 0x80) {}\n};\n\nTap.prototype.writeInt = Tap.prototype.writeLong = function (n) {\n  var buf = this.buf;\n  var f, m;\n\n  if (n >= -1073741824 && n < 1073741824) {\n    // Won't overflow, we can use integer arithmetic.\n    m = n >= 0 ? n << 1 : (~n << 1) | 1;\n    do {\n      buf[this.pos] = m & 0x7f;\n      m >>= 7;\n    } while (m && (buf[this.pos++] |= 0x80));\n  } else {\n    // We have to use slower floating arithmetic.\n    f = n >= 0 ? n * 2 : (-n * 2) - 1;\n    do {\n      buf[this.pos] = f & 0x7f;\n      f /= 128;\n    } while (f >= 1 && (buf[this.pos++] |= 0x80));\n  }\n  this.pos++;\n};\n\nTap.prototype.readFloat = function () {\n  var buf = this.buf;\n  var pos = this.pos;\n  this.pos += 4;\n  if (this.pos > buf.length) {\n    return;\n  }\n  return this.buf.readFloatLE(pos);\n};\n\nTap.prototype.skipFloat = function () { this.pos += 4; };\n\nTap.prototype.writeFloat = function (f) {\n  var buf = this.buf;\n  var pos = this.pos;\n  this.pos += 4;\n  if (this.pos > buf.length) {\n    return;\n  }\n  return this.buf.writeFloatLE(f, pos);\n};\n\nTap.prototype.readDouble = function () {\n  var buf = this.buf;\n  var pos = this.pos;\n  this.pos += 8;\n  if (this.pos > buf.length) {\n    return;\n  }\n  return this.buf.readDoubleLE(pos);\n};\n\nTap.prototype.skipDouble = function () { this.pos += 8; };\n\nTap.prototype.writeDouble = function (d) {\n  var buf = this.buf;\n  var pos = this.pos;\n  this.pos += 8;\n  if (this.pos > buf.length) {\n    return;\n  }\n  return this.buf.writeDoubleLE(d, pos);\n};\n\nTap.prototype.readFixed = function (len) {\n  var pos = this.pos;\n  this.pos += len;\n  if (this.pos > this.buf.length) {\n    return;\n  }\n  var fixed = POOL.alloc(len);\n  this.buf.copy(fixed, 0, pos, pos + len);\n  return fixed;\n};\n\nTap.prototype.skipFixed = function (len) { this.pos += len; };\n\nTap.prototype.writeFixed = function (buf, len) {\n  len = len || buf.length;\n  var pos = this.pos;\n  this.pos += len;\n  if (this.pos > this.buf.length) {\n    return;\n  }\n  buf.copy(this.buf, pos, 0, len);\n};\n\nTap.prototype.readBytes = function () {\n  return this.readFixed(this.readLong());\n};\n\nTap.prototype.skipBytes = function () {\n  var len = this.readLong();\n  this.pos += len;\n};\n\nTap.prototype.writeBytes = function (buf) {\n  var len = buf.length;\n  this.writeLong(len);\n  this.writeFixed(buf, len);\n};\n\n/* istanbul ignore else */\nif (typeof Buffer.prototype.utf8Slice == 'function') {\n  // Use this optimized function when available.\n  Tap.prototype.readString = function () {\n    var len = this.readLong();\n    var pos = this.pos;\n    var buf = this.buf;\n    this.pos += len;\n    if (this.pos > buf.length) {\n      return;\n    }\n    return this.buf.utf8Slice(pos, pos + len);\n  };\n} else {\n  Tap.prototype.readString = function () {\n    var len = this.readLong();\n    var pos = this.pos;\n    var buf = this.buf;\n    this.pos += len;\n    if (this.pos > buf.length) {\n      return;\n    }\n    return this.buf.slice(pos, pos + len).toString();\n  };\n}\n\nTap.prototype.skipString = function () {\n  var len = this.readLong();\n  this.pos += len;\n};\n\nTap.prototype.writeString = function (s) {\n  var len = Buffer.byteLength(s);\n  var buf = this.buf;\n  this.writeLong(len);\n  var pos = this.pos;\n  this.pos += len;\n  if (this.pos > buf.length) {\n    return;\n  }\n  if (len > 64) {\n    this._writeUtf8(s, len);\n  } else {\n    var i, l, c1, c2;\n    for (i = 0, l = len; i < l; i++) {\n      c1 = s.charCodeAt(i);\n      if (c1 < 0x80) {\n        buf[pos++] = c1;\n      } else if (c1 < 0x800) {\n        buf[pos++] = c1 >> 6 | 0xc0;\n        buf[pos++] = c1 & 0x3f | 0x80;\n      } else if (\n        (c1 & 0xfc00) === 0xd800 &&\n        ((c2 = s.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n      ) {\n        c1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff);\n        i++;\n        buf[pos++] = c1 >> 18 | 0xf0;\n        buf[pos++] = c1 >> 12 & 0x3f | 0x80;\n        buf[pos++] = c1 >> 6 & 0x3f | 0x80;\n        buf[pos++] = c1 & 0x3f | 0x80;\n      } else {\n        buf[pos++] = c1 >> 12 | 0xe0;\n        buf[pos++] = c1 >> 6 & 0x3f | 0x80;\n        buf[pos++] = c1 & 0x3f | 0x80;\n      }\n    }\n  }\n};\n\n/* istanbul ignore else */\nif (typeof Buffer.prototype.utf8Write == 'function') {\n  Tap.prototype._writeUtf8 = function (str, len) {\n    this.buf.utf8Write(str, this.pos - len, len);\n  };\n} else {\n  // `utf8Write` isn't available in the browser.\n  Tap.prototype._writeUtf8 = function (str, len) {\n    this.buf.write(str, this.pos - len, len, 'utf8');\n  };\n}\n\n/* istanbul ignore else */\nif (typeof Buffer.prototype.latin1Write == 'function') {\n  // `binaryWrite` has been renamed to `latin1Write` in Node v6.4.0, see\n  // https://github.com/nodejs/node/pull/7111. Note that the `'binary'`\n  // encoding argument still works however.\n  Tap.prototype.writeBinary = function (str, len) {\n    var pos = this.pos;\n    this.pos += len;\n    if (this.pos > this.buf.length) {\n      return;\n    }\n    this.buf.latin1Write(str, pos, len);\n  };\n} else if (typeof Buffer.prototype.binaryWrite == 'function') {\n  Tap.prototype.writeBinary = function (str, len) {\n    var pos = this.pos;\n    this.pos += len;\n    if (this.pos > this.buf.length) {\n      return;\n    }\n    this.buf.binaryWrite(str, pos, len);\n  };\n} else {\n  // Slowest implementation.\n  Tap.prototype.writeBinary = function (s, len) {\n    var pos = this.pos;\n    this.pos += len;\n    if (this.pos > this.buf.length) {\n      return;\n    }\n    this.buf.write(s, pos, len, 'binary');\n  };\n}\n\n// Binary comparison methods.\n//\n// These are not guaranteed to consume the objects they are comparing when\n// returning a non-zero result (allowing for performance benefits), so no other\n// operations should be done on either tap after a compare returns a non-zero\n// value. Also, these methods do not have the same silent failure requirement\n// as read, skip, and write since they are assumed to be called on valid\n// buffers.\n\nTap.prototype.matchBoolean = function (tap) {\n  return this.buf[this.pos++] - tap.buf[tap.pos++];\n};\n\nTap.prototype.matchInt = Tap.prototype.matchLong = function (tap) {\n  var n1 = this.readLong();\n  var n2 = tap.readLong();\n  return n1 === n2 ? 0 : (n1 < n2 ? -1 : 1);\n};\n\nTap.prototype.matchFloat = function (tap) {\n  var n1 = this.readFloat();\n  var n2 = tap.readFloat();\n  return n1 === n2 ? 0 : (n1 < n2 ? -1 : 1);\n};\n\nTap.prototype.matchDouble = function (tap) {\n  var n1 = this.readDouble();\n  var n2 = tap.readDouble();\n  return n1 === n2 ? 0 : (n1 < n2 ? -1 : 1);\n};\n\nTap.prototype.matchFixed = function (tap, len) {\n  return this.readFixed(len).compare(tap.readFixed(len));\n};\n\nTap.prototype.matchBytes = Tap.prototype.matchString = function (tap) {\n  var l1 = this.readLong();\n  var p1 = this.pos;\n  this.pos += l1;\n  var l2 = tap.readLong();\n  var p2 = tap.pos;\n  tap.pos += l2;\n  var b1 = this.buf.slice(p1, this.pos);\n  var b2 = tap.buf.slice(p2, tap.pos);\n  return b1.compare(b2);\n};\n\n// Functions for supporting custom long classes.\n//\n// The two following methods allow the long implementations to not have to\n// worry about Avro's zigzag encoding, we directly expose longs as unpacked.\n\nTap.prototype.unpackLongBytes = function () {\n  var res = newBuffer(8);\n  var n = 0;\n  var i = 0; // Byte index in target buffer.\n  var j = 6; // Bit offset in current target buffer byte.\n  var buf = this.buf;\n  var b, neg;\n\n  b = buf[this.pos++];\n  neg = b & 1;\n  res.fill(0);\n\n  n |= (b & 0x7f) >> 1;\n  while (b & 0x80) {\n    b = buf[this.pos++];\n    n |= (b & 0x7f) << j;\n    j += 7;\n    if (j >= 8) {\n      // Flush byte.\n      j -= 8;\n      res[i++] = n;\n      n >>= 8;\n    }\n  }\n  res[i] = n;\n\n  if (neg) {\n    invert(res, 8);\n  }\n\n  return res;\n};\n\nTap.prototype.packLongBytes = function (buf) {\n  var neg = (buf[7] & 0x80) >> 7;\n  var res = this.buf;\n  var j = 1;\n  var k = 0;\n  var m = 3;\n  var n;\n\n  if (neg) {\n    invert(buf, 8);\n    n = 1;\n  } else {\n    n = 0;\n  }\n\n  var parts = [\n    buf.readUIntLE(0, 3),\n    buf.readUIntLE(3, 3),\n    buf.readUIntLE(6, 2)\n  ];\n  // Not reading more than 24 bits because we need to be able to combine the\n  // \"carry\" bits from the previous part and JavaScript only supports bitwise\n  // operations on 32 bit integers.\n  while (m && !parts[--m]) {} // Skip trailing 0s.\n\n  // Leading parts (if any), we never bail early here since we need the\n  // continuation bit to be set.\n  while (k < m) {\n    n |= parts[k++] << j;\n    j += 24;\n    while (j > 7) {\n      res[this.pos++] = (n & 0x7f) | 0x80;\n      n >>= 7;\n      j -= 7;\n    }\n  }\n\n  // Final part, similar to normal packing aside from the initial offset.\n  n |= parts[m] << j;\n  do {\n    res[this.pos] = n & 0x7f;\n    n >>= 7;\n  } while (n && (res[this.pos++] |= 0x80));\n  this.pos++;\n\n  // Restore original buffer (could make this optional?).\n  if (neg) {\n    invert(buf, 8);\n  }\n};\n\n// Helpers.\n\n/**\n * Invert all bits in a buffer.\n *\n * @param buf {Buffer} Non-empty buffer to invert.\n * @param len {Number} Buffer length (must be positive).\n */\nfunction invert(buf, len) {\n  while (len--) {\n    buf[len] = ~buf[len];\n  }\n}\n\n\nmodule.exports = {\n  abstractFunction: abstractFunction,\n  addDeprecatedGetters: addDeprecatedGetters,\n  bufferFrom: bufferFrom,\n  capitalize: capitalize,\n  copyOwnProperties: copyOwnProperties,\n  getHash: getHash,\n  compare: compare,\n  getOption: getOption,\n  jsonEnd: jsonEnd,\n  newBuffer: newBuffer,\n  objectValues: objectValues,\n  toMap: toMap,\n  singleIndexOf: singleIndexOf,\n  hasDuplicates: hasDuplicates,\n  Lcg: Lcg,\n  OrderedQueue: OrderedQueue,\n  Tap: Tap\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}