"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.uploadFolderAndPay = exports.batchPayOrders = exports.uploadFolder = void 0;
const dist_1 = __importDefault(require("@supercharge/promise-pool/dist"));
const mime_types_1 = __importDefault(require("mime-types"));
const manifest_1 = require("./manifest");
const path_1 = __importDefault(require("path"));
const ethereumSigner_1 = __importDefault(require("arseeding-arbundles/src/signing/chains/ethereumSigner"));
const fs_1 = require("fs");
const submitOrder_1 = require("./submitOrder");
const payOrder_1 = require("./payOrder");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
async function concurrentUploader(cfg, files, concurrency = 10) {
    const errors = [];
    const results = await dist_1.default
        .for(files)
        .withConcurrency(concurrency > 50 ? 50 : concurrency)
        .handleError(async (error, _) => {
        errors.push(error);
    })
        .process(async (file, i, _) => {
        try {
            const ord = await upload(file, cfg);
            const relpath = path_1.default.relative(cfg.path, file);
            return { relpath, ord };
        }
        catch (e) {
            throw file;
        }
    });
    return { errors, results: results.results };
}
// submit item for the file and not pay, return the order
async function upload(file, cfg) {
    const data = (0, fs_1.readFileSync)(file);
    const ops = {
        tags: [
            { name: 'ManifestFile', value: file },
            { name: 'Content-Type', value: mime_types_1.default.lookup(file).toString() }
        ]
    };
    return await (0, submitOrder_1.createAndSubmitItem)(data, ops, cfg);
}
// uploadFolder return all orders need to pay
async function uploadFolder(path, privKey, arseedUrl, currency, indexFile, apiKey) {
    const cfg = {
        signer: new ethereumSigner_1.default(privKey),
        arseedUrl: arseedUrl,
        currency: currency,
        path: path,
        apiKey: apiKey
    };
    const files = await (0, manifest_1.checkPaths)(path);
    const ords = [];
    const { errors, results } = await concurrentUploader(cfg, files, files.length);
    let totFee = 0;
    const items = new Map();
    // serial upload timeout files again
    if (errors.length > 0) {
        const sleep = async (ms) => await new Promise(r => setTimeout(r, ms));
        for (const [_, file] of errors.entries()) {
            try {
                const ord = await upload(file, cfg);
                ords.push(ord);
                totFee += +ord.fee;
                const relPath = path_1.default.relative(cfg.path, file);
                items.set(relPath, ord.itemId);
                await sleep(1500); // it's for upload all folder as much as possible, maybe set sleep longer
            }
            catch (e) {
                console.log('aaaaa', e);
                throw 'upload folder fail because network, try again later; err: ' + e;
            }
        }
    }
    let decimals = 0;
    for (const [_, obj] of results.entries()) {
        items.set(obj.relpath, obj.ord.itemId);
        ords.push(obj.ord);
        totFee += +obj.ord.fee;
    }
    const mani = (0, manifest_1.generateManifest)({ items, indexFile });
    const maniStr = JSON.stringify(mani);
    // upload manifest
    const data = Buffer.from(maniStr);
    const ops = {
        tags: [
            { name: 'Content-Type', value: 'application/x.arweave-manifest+json' }
        ]
    };
    const ord = await (0, submitOrder_1.createAndSubmitItem)(data, ops, cfg);
    totFee += +ord.fee;
    decimals = ord.decimals;
    const maniId = ord.itemId;
    const fee = new bignumber_js_1.default(totFee).dividedBy(new bignumber_js_1.default(10).pow(decimals.toString())).toString();
    ords.push(ord);
    return { ords, fee, maniId };
}
exports.uploadFolder = uploadFolder;
async function batchPayOrders(ords, privKey) {
    const everPay = (0, payOrder_1.newEverpayByEcc)(privKey);
    const res = [];
    for (let i = 0; i < ords.length; i += 500) {
        let lastIndex;
        if ((i + 1) * 500 < ords.length) {
            lastIndex = (i + 1) * 500;
        }
        else {
            lastIndex = ords.length;
        }
        const partOrds = ords.slice(i, lastIndex);
        try {
            const everHash = await (0, payOrder_1.payOrders)(everPay, partOrds);
            res.push(everHash);
        }
        catch (e) {
            throw e;
        }
    }
    return res;
}
exports.batchPayOrders = batchPayOrders;
async function uploadFolderAndPay(path, privKey, url, currency, indexFile) {
    const { ords, fee, maniId } = await uploadFolder(path, privKey, url, currency);
    const everHash = await batchPayOrders(ords, privKey);
    return { fee, maniId, everHash };
}
exports.uploadFolderAndPay = uploadFolderAndPay;
