"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkArPermissions = void 0;
const arweave_1 = __importDefault(require("arweave"));
const isString_1 = __importDefault(require("lodash/isString"));
const types_1 = require("../types");
const util_1 = require("../utils/util");
const options = {
    host: 'arweave.net',
    port: 443,
    protocol: 'https',
    timeout: 20000,
    logging: false // Enable network request logging
};
// TODO: to fix arConnect return result and interface
var ERRORS;
(function (ERRORS) {
    ERRORS["PLEASE_INSTALL_ARCONNECT"] = "PLEASE_INSTALL_ARCONNECT";
    ERRORS["ACCESS_ADDRESS_PERMISSION_NEEDED"] = "ACCESS_ADDRESS_PERMISSION_NEEDED";
    ERRORS["ACCESS_PUBLIC_KEY_PERMISSION_NEEDED"] = "ACCESS_PUBLIC_KEY_PERMISSION_NEEDED";
    ERRORS["SIGNATURE_PERMISSION_NEEDED"] = "NEED_SIGNATURE_PERMISSION";
    ERRORS["SIGN_TRANSACTION_PERMISSION_NEEDED"] = "SIGN_TRANSACTION_PERMISSION_NEEDED";
    ERRORS["SIGNATURE_FAILED"] = "SIGNATURE_FAILED";
    ERRORS["TRANSACTION_POST_ERROR"] = "TRANSACTION_POST_ERROR";
    ERRORS["ACCESS_PUBLIC_KEY_FAILED"] = "ACCESS_PUBLIC_KEY_FAILED";
})(ERRORS || (ERRORS = {}));
const checkArPermissions = async (permissions) => {
    let existingPermissions = [];
    permissions = isString_1.default(permissions) ? [permissions] : permissions;
    try {
        existingPermissions = await window.arweaveWallet.getPermissions();
    }
    catch {
        throw new Error(ERRORS.PLEASE_INSTALL_ARCONNECT);
    }
    if (permissions.length === 0) {
        return;
    }
    if (permissions.some(permission => {
        return !existingPermissions.includes(permission);
    })) {
        await window.arweaveWallet.connect(permissions);
    }
};
exports.checkArPermissions = checkArPermissions;
const signMessageAsync = async (arJWK, address, everHash) => {
    const arweave = arweave_1.default.init(options);
    const everHashBuffer = Buffer.from(everHash.slice(2), 'hex');
    let arOwner = '';
    let signatureB64url = '';
    // web
    if (arJWK === 'use_wallet') {
        try {
            await exports.checkArPermissions('ACCESS_PUBLIC_KEY');
        }
        catch {
            throw new Error(ERRORS.ACCESS_PUBLIC_KEY_PERMISSION_NEEDED);
        }
        try {
            // TODO: wait arweave-js update arconnect.d.ts
            arOwner = await window.arweaveWallet.getActivePublicKey();
        }
        catch {
            throw new Error(ERRORS.ACCESS_PUBLIC_KEY_FAILED);
        }
        try {
            await exports.checkArPermissions('SIGNATURE');
        }
        catch {
            throw new Error(ERRORS.SIGNATURE_PERMISSION_NEEDED);
        }
        const algorithm = {
            name: 'RSA-PSS',
            saltLength: 32
        };
        try {
            // TODO: wait arweave-js update arconnect.d.ts
            const signature = await window.arweaveWallet.signature(everHashBuffer, algorithm);
            const buf = new Uint8Array(Object.values(signature));
            signatureB64url = arweave_1.default.utils.bufferTob64Url(buf);
        }
        catch {
            throw new Error(ERRORS.SIGNATURE_FAILED);
        }
        // node
    }
    else {
        const buf = await arweave.crypto.sign(arJWK, everHashBuffer, {
            saltLength: 32
        });
        arOwner = arJWK.n;
        signatureB64url = arweave_1.default.utils.bufferTob64Url(buf);
    }
    return `${signatureB64url},${arOwner}`;
};
const transferAsync = async (arJWK, chainType, { symbol, token, from, to, value }) => {
    const arweave = arweave_1.default.init(options);
    let transactionTransfer;
    if (symbol.toUpperCase() === 'AR') {
        transactionTransfer = await arweave.createTransaction({
            target: to,
            quantity: value.toString()
        }, arJWK);
        // PST Token
    }
    else {
        const tokenID = util_1.getTokenAddrByChainType(token, types_1.ChainType.arweave);
        transactionTransfer = await arweave.createTransaction({
            data: (Math.random() * 10000).toFixed()
        }, arJWK);
        transactionTransfer.addTag('App-Name', 'SmartWeaveAction');
        transactionTransfer.addTag('App-Version', '0.3.0');
        transactionTransfer.addTag('Contract', tokenID);
        transactionTransfer.addTag('Input', JSON.stringify({
            function: 'transfer',
            qty: value.toNumber(),
            target: to
        }));
    }
    if (arJWK === 'use_wallet') {
        try {
            const existingPermissions = await window.arweaveWallet.getPermissions();
            if (!existingPermissions.includes('SIGN_TRANSACTION')) {
                await window.arweaveWallet.connect(['SIGN_TRANSACTION']);
            }
        }
        catch (_a) {
            // Permission is already granted
        }
        const signedTransaction = await window.arweaveWallet.sign(transactionTransfer);
        // TODO: Temp fix arConnect modify reward
        transactionTransfer.reward = signedTransaction.reward;
        transactionTransfer.setSignature({
            id: signedTransaction.id,
            owner: signedTransaction.owner,
            tags: signedTransaction.tags,
            signature: signedTransaction.signature
        });
    }
    else {
        // 直接给原来 transaction 赋值了 signature 值
        await arweave.transactions.sign(transactionTransfer, arJWK);
    }
    const responseTransfer = await arweave.transactions.post(transactionTransfer);
    if (responseTransfer.status === 200) {
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        if (responseTransfer.data.error) {
            throw new Error(responseTransfer.data.error);
        }
        return transactionTransfer;
    }
    throw new Error(ERRORS.TRANSACTION_POST_ERROR);
};
exports.default = {
    signMessageAsync,
    transferAsync
};
