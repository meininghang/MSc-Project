{"version":3,"file":"dev/index.bundle.js","mappings":"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","sources":["webpack://AxiosCacheInterceptor/webpack/universalModuleDefinition","webpack://AxiosCacheInterceptor/webpack/bootstrap","webpack://AxiosCacheInterceptor/webpack/runtime/define property getters","webpack://AxiosCacheInterceptor/webpack/runtime/hasOwnProperty shorthand","webpack://AxiosCacheInterceptor/webpack/runtime/make namespace object","webpack://AxiosCacheInterceptor/./node_modules/cache-parser/dist/index.mjs","webpack://AxiosCacheInterceptor/./src/header/headers.ts","webpack://AxiosCacheInterceptor/./src/header/interpreter.ts","webpack://AxiosCacheInterceptor/./node_modules/fast-defer/dist/index.mjs","webpack://AxiosCacheInterceptor/./src/interceptors/util.ts","webpack://AxiosCacheInterceptor/./src/interceptors/request.ts","webpack://AxiosCacheInterceptor/./src/util/cache-predicate.ts","webpack://AxiosCacheInterceptor/./src/util/update-cache.ts","webpack://AxiosCacheInterceptor/./src/interceptors/response.ts","webpack://AxiosCacheInterceptor/./src/storage/build.ts","webpack://AxiosCacheInterceptor/./src/storage/memory.ts","webpack://AxiosCacheInterceptor/./node_modules/object-code/dist/index.mjs","webpack://AxiosCacheInterceptor/./src/util/key-generator.ts","webpack://AxiosCacheInterceptor/./src/cache/create.ts","webpack://AxiosCacheInterceptor/./src/storage/web-api.ts","webpack://AxiosCacheInterceptor/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"AxiosCacheInterceptor\"] = factory();\n\telse\n\t\troot[\"AxiosCacheInterceptor\"] = factory();\n})(typeof self !== 'undefined' ? self : this, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var e=Symbol(\"cache-parser\");function a(e){return(\"string\"==typeof e||\"number\"==typeof e)&&(e=Number(e))>=0&&e<Infinity}function r(e){return!0===e||\"number\"==typeof e||\"string\"==typeof e&&\"false\"!==e}var t=Number;function s(s){var n=Object.defineProperty({},e,{enumerable:!1,value:1});if(!s||\"string\"!=typeof s)return n;var i=function(e){var a={},r=e.toLowerCase().replace(/\\s+/g,\"\").split(\",\");for(var t in r){var s,n=r[t].split(\"=\",2);a[n[0]]=null==(s=n[1])||s}return a}(s),u=i[\"max-age\"],l=i[\"max-stale\"],o=i[\"min-fresh\"],m=i[\"s-maxage\"],p=i[\"stale-if-error\"],h=i[\"stale-while-revalidate\"];return r(i.immutable)&&(n.immutable=!0),a(u)&&(n.maxAge=t(u)),a(l)&&(n.maxStale=t(l)),a(o)&&(n.minFresh=t(o)),r(i[\"must-revalidate\"])&&(n.mustRevalidate=!0),r(i[\"must-understand\"])&&(n.mustUnderstand=!0),r(i[\"no-cache\"])&&(n.noCache=!0),r(i[\"no-store\"])&&(n.noStore=!0),r(i[\"no-transform\"])&&(n.noTransform=!0),r(i[\"only-if-cached\"])&&(n.onlyIfCached=!0),r(i.private)&&(n.private=!0),r(i[\"proxy-revalidate\"])&&(n.proxyRevalidate=!0),r(i.public)&&(n.public=!0),a(m)&&(n.sMaxAge=t(m)),a(p)&&(n.staleIfError=t(p)),a(h)&&(n.staleWhileRevalidate=t(h)),n}function n(e){if(!e||\"object\"!=typeof e)return[];var t=[];return r(e.immutable)&&t.push(\"immutable\"),a(e.maxAge)&&t.push(\"max-age=\"+e.maxAge),a(e.maxStale)&&t.push(\"max-stale=\"+e.maxStale),a(e.minFresh)&&t.push(\"min-fresh=\"+e.minFresh),r(e.mustRevalidate)&&t.push(\"must-revalidate\"),r(e.mustUnderstand)&&t.push(\"must-understand\"),r(e.noCache)&&t.push(\"no-cache\"),r(e.noStore)&&t.push(\"no-store\"),r(e.noTransform)&&t.push(\"no-transform\"),r(e.onlyIfCached)&&t.push(\"only-if-cached\"),r(e.private)&&t.push(\"private\"),r(e.proxyRevalidate)&&t.push(\"proxy-revalidate\"),r(e.public)&&t.push(\"public\"),a(e.sMaxAge)&&t.push(\"s-maxage=\"+e.sMaxAge),a(e.staleIfError)&&t.push(\"stale-if-error=\"+e.staleIfError),a(e.staleWhileRevalidate)&&t.push(\"stale-while-revalidate=\"+e.staleWhileRevalidate),t}function i(a){return!!a&&!!a[e]}export{i as isCacheControl,s as parse,n as tokenize};\n//# sourceMappingURL=index.mjs.map\n","export const Header = Object.freeze({\n    /**\n     * ```txt\n     * If-Modified-Since: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT\n     * ```\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Modified-Since\n     */\n    IfModifiedSince: 'if-modified-since',\n    /**\n     * ```txt\n     * Last-Modified: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT\n     * ```\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Last-Modified\n     */\n    LastModified: 'last-modified',\n    /**\n     * ```txt\n     * If-None-Match: \"<etag_value>\"\n     * If-None-Match: \"<etag_value>\", \"<etag_value>\", …\n     * If-None-Match: *\n     * ```\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match\n     */\n    IfNoneMatch: 'if-none-match',\n    /**\n     * ```txt\n     * Cache-Control: max-age=604800\n     * ```\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control\n     */\n    CacheControl: 'cache-control',\n    /**\n     * ```txt\n     * ETag: W / '<etag_value>';\n     * ETag: '<etag_value>';\n     * ```\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag\n     */\n    ETag: 'etag',\n    /**\n     * ```txt\n     * Expires: <http-date>\n     * ```\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expires\n     */\n    Expires: 'expires',\n    /**\n     * ```txt\n     * Age: <delta-seconds>\n     * ```\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Age\n     */\n    Age: 'age',\n    /**\n     * Used internally as metadata to mark the cache item as revalidatable and enabling\n     * stale cache state Contains a string of ASCII characters that can be used as ETag for\n     * `If-Match` header Provided by user using `cache.etag` value.\n     *\n     * ```txt\n     * X-Axios-Cache-Etag: \"<etag_value>\"\n     * ```\n     */\n    XAxiosCacheEtag: 'x-axios-cache-etag',\n    /**\n     * Used internally as metadata to mark the cache item as revalidatable and enabling\n     * stale cache state may contain `'use-cache-timestamp'` if `cache.modifiedSince` is\n     * `true`, otherwise will contain a date from `cache.modifiedSince`. If a date is\n     * provided, it can be used for `If-Modified-Since` header, otherwise the cache\n     * timestamp can be used for `If-Modified-Since` header.\n     *\n     * ```txt\n     * X-Axios-Cache-Last-Modified: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT\n     * X-Axios-Cache-Last-Modified: use-cache-timestamp\n     * ```\n     */\n    XAxiosCacheLastModified: 'x-axios-cache-last-modified',\n    /**\n     * Used internally as metadata to mark the cache item able to be used if the server\n     * returns an error. The stale-if-error response directive indicates that the cache can\n     * reuse a stale response when any error occurs.\n     *\n     * ```txt\n     * XAxiosCacheStaleIfError: <seconds>\n     * ```\n     */\n    XAxiosCacheStaleIfError: 'x-axios-cache-stale-if-error'\n});\n","import { parse } from 'cache-parser';\nimport { Header } from './headers';\nexport const defaultHeaderInterpreter = (headers) => {\n    if (!headers)\n        return 'not enough headers';\n    const cacheControl = headers[Header.CacheControl];\n    if (cacheControl) {\n        const { noCache, noStore, mustRevalidate, maxAge, immutable } = parse(String(cacheControl));\n        // Header told that this response should not be cached.\n        if (noCache || noStore) {\n            return 'dont cache';\n        }\n        if (immutable) {\n            // 1 year is sufficient, as Infinity may cause problems with certain storages.\n            // It might not be the best way, but a year is better than none.\n            return 1000 * 60 * 60 * 24 * 365;\n        }\n        // Already out of date, for cache can be saved, but must be requested again\n        if (mustRevalidate) {\n            return 0;\n        }\n        if (maxAge !== undefined) {\n            const age = headers[Header.Age];\n            if (!age) {\n                return maxAge * 1000;\n            }\n            return (maxAge - Number(age)) * 1000;\n        }\n    }\n    const expires = headers[Header.Expires];\n    if (expires) {\n        const milliseconds = Date.parse(String(expires)) - Date.now();\n        return milliseconds >= 0 ? milliseconds : 'dont cache';\n    }\n    return 'not enough headers';\n};\n","var r=Symbol();function e(){var e,n,o=new Promise(function(r,o){e=r,n=o});return o.resolve=e,o.reject=n,o[r]=1,o}function n(e){return!!e&&!!e[r]}export{e as deferred,n as isDeferred};\n//# sourceMappingURL=index.mjs.map\n","import { Header } from '../header/headers';\n/**\n * Creates a new validateStatus function that will use the one already used and also\n * accept status code 304.\n */\nexport function createValidateStatus(oldValidate) {\n    return oldValidate\n        ? (status) => oldValidate(status) || status === 304\n        : (status) => (status >= 200 && status < 300) || status === 304;\n}\n/** Checks if the given method is in the methods array */\nexport function isMethodIn(requestMethod = 'get', methodList = []) {\n    requestMethod = requestMethod.toLowerCase();\n    return methodList.some((method) => method === requestMethod);\n}\n/**\n * This function updates the cache when the request is stale. So, the next request to the\n * server will be made with proper header / settings.\n */\nexport function updateStaleRequest(cache, config) {\n    var _a;\n    config.headers || (config.headers = {});\n    const { etag, modifiedSince } = config.cache;\n    if (etag) {\n        const etagValue = etag === true ? (_a = cache.data) === null || _a === void 0 ? void 0 : _a.headers[Header.ETag] : etag;\n        etagValue && (config.headers[Header.IfNoneMatch] = etagValue);\n    }\n    if (modifiedSince) {\n        config.headers[Header.IfModifiedSince] =\n            modifiedSince === true\n                ? // If last-modified is not present, use the createdAt timestamp\n                    cache.data.headers[Header.LastModified] ||\n                        new Date(cache.createdAt).toUTCString()\n                : modifiedSince.toUTCString();\n    }\n}\n/**\n * Creates the new date to the cache by the provided response. Also handles possible 304\n * Not Modified by updating response properties.\n */\nexport function createCacheResponse(response, previousCache) {\n    if (response.status === 304 && previousCache) {\n        // Set the cache information into the response object\n        response.cached = true;\n        response.data = previousCache.data;\n        response.status = previousCache.status;\n        response.statusText = previousCache.statusText;\n        // Update possible new headers\n        response.headers = Object.assign(Object.assign({}, previousCache.headers), response.headers);\n        // return the old cache\n        return previousCache;\n    }\n    // New Response\n    return {\n        data: response.data,\n        status: response.status,\n        statusText: response.statusText,\n        headers: response.headers\n    };\n}\n","import { deferred } from 'fast-defer';\nimport { createValidateStatus, isMethodIn, updateStaleRequest } from './util';\nexport function defaultRequestInterceptor(axios) {\n    const onFulfilled = async (config) => {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        const key = (config.id = axios.generateKey(config));\n        if (config.cache === false) {\n            if (__ACI_DEV__) {\n                (_a = axios.debug) === null || _a === void 0 ? void 0 : _a.call(axios, {\n                    msg: 'Ignoring cache because config.cache === false',\n                    data: config\n                });\n            }\n            return config;\n        }\n        // merge defaults with per request configuration\n        config.cache = Object.assign(Object.assign({}, axios.defaults.cache), config.cache);\n        if (!isMethodIn(config.method, config.cache.methods)) {\n            if (__ACI_DEV__) {\n                (_b = axios.debug) === null || _b === void 0 ? void 0 : _b.call(axios, {\n                    msg: `Ignored because method (${config.method}) is not in cache.methods (${config.cache.methods})`\n                });\n            }\n            return config;\n        }\n        // Assumes that the storage handled staled responses\n        let cache = await axios.storage.get(key, config);\n        const overrideCache = config.cache.override;\n        // Not cached, continue the request, and mark it as fetching\n        ignoreAndRequest: if (cache.state === 'empty' ||\n            cache.state === 'stale' ||\n            overrideCache) {\n            /**\n             * This checks for simultaneous access to a new key. The js event loop jumps on the\n             * first await statement, so the second (asynchronous call) request may have already\n             * started executing.\n             */\n            if (axios.waiting[key] && !overrideCache) {\n                cache = (await axios.storage.get(key, config));\n                /**\n                 * This check is required when a request has it own cache deleted manually, lets\n                 * say by a `axios.storage.delete(key)` and has a concurrent loading request.\n                 * Because in this case, the cache will be empty and may still has a pending key\n                 * on waiting map.\n                 */\n                //@ts-expect-error read above\n                if (cache.state !== 'empty') {\n                    if (__ACI_DEV__) {\n                        (_c = axios.debug) === null || _c === void 0 ? void 0 : _c.call(axios, {\n                            id: key,\n                            msg: 'Waiting list had an deferred for this key, waiting for it to finish'\n                        });\n                    }\n                    break ignoreAndRequest;\n                }\n            }\n            // Create a deferred to resolve other requests for the same key when it's completed\n            axios.waiting[key] = deferred();\n            /**\n             * Add a default reject handler to catch when the request is aborted without others\n             * waiting for it.\n             */\n            (_d = axios.waiting[key]) === null || _d === void 0 ? void 0 : _d.catch(() => undefined);\n            await axios.storage.set(key, {\n                state: 'loading',\n                previous: overrideCache\n                    ? // Simply determine if the request is stale or not\n                        // based if it had previous data or not\n                        cache.data\n                            ? 'stale'\n                            : 'empty'\n                    : // Typescript doesn't know that cache.state here can only be 'empty' or 'stale'\n                        cache.state,\n                // Eslint complains a lot :)\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-explicit-any\n                data: cache.data,\n                // If the cache is empty and asked to override it, use the current timestamp\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                createdAt: \n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                overrideCache && !cache.createdAt ? Date.now() : cache.createdAt\n            }, config);\n            if (cache.state === 'stale') {\n                updateStaleRequest(cache, config);\n                if (__ACI_DEV__) {\n                    (_e = axios.debug) === null || _e === void 0 ? void 0 : _e.call(axios, {\n                        id: key,\n                        msg: 'Updated stale request'\n                    });\n                }\n            }\n            config.validateStatus = createValidateStatus(config.validateStatus);\n            if (__ACI_DEV__) {\n                (_f = axios.debug) === null || _f === void 0 ? void 0 : _f.call(axios, {\n                    id: key,\n                    msg: 'Sending request, waiting for response',\n                    data: {\n                        overrideCache,\n                        state: cache.state\n                    }\n                });\n            }\n            return config;\n        }\n        let cachedResponse;\n        if (cache.state === 'loading') {\n            const deferred = axios.waiting[key];\n            // Just in case, the deferred doesn't exists.\n            /* istanbul ignore if 'really hard to test' */\n            if (!deferred) {\n                await axios.storage.remove(key, config);\n                return config;\n            }\n            if (__ACI_DEV__) {\n                (_g = axios.debug) === null || _g === void 0 ? void 0 : _g.call(axios, {\n                    id: key,\n                    msg: 'Detected concurrent request, waiting for it to finish'\n                });\n            }\n            try {\n                cachedResponse = await deferred;\n            }\n            catch (err) {\n                if (__ACI_DEV__) {\n                    (_h = axios.debug) === null || _h === void 0 ? void 0 : _h.call(axios, {\n                        id: key,\n                        msg: 'Deferred rejected, requesting again',\n                        data: err\n                    });\n                }\n                // The deferred is rejected when the request that we are waiting rejected cache.\n                return config;\n            }\n        }\n        else {\n            cachedResponse = cache.data;\n        }\n        // Even though the response interceptor receives this one from here,\n        // it has been configured to ignore cached responses = true\n        config.adapter = () => Promise.resolve({\n            config,\n            data: cachedResponse.data,\n            headers: cachedResponse.headers,\n            status: cachedResponse.status,\n            statusText: cachedResponse.statusText,\n            cached: true,\n            id: key\n        });\n        if (__ACI_DEV__) {\n            (_j = axios.debug) === null || _j === void 0 ? void 0 : _j.call(axios, {\n                id: key,\n                msg: 'Returning cached response'\n            });\n        }\n        return config;\n    };\n    return {\n        onFulfilled,\n        apply: () => axios.interceptors.request.use(onFulfilled)\n    };\n}\n","/** Tests an response against a {@link CachePredicateObject}. */\nexport async function testCachePredicate(response, predicate) {\n    var _a;\n    if (typeof predicate === 'function') {\n        return predicate(response);\n    }\n    const { statusCheck, responseMatch, containsHeaders } = predicate;\n    if ((statusCheck && !(await statusCheck(response.status))) ||\n        (responseMatch && !(await responseMatch(response)))) {\n        return false;\n    }\n    if (containsHeaders) {\n        for (const [header, predicate] of Object.entries(containsHeaders)) {\n            if (!(await predicate(\n            // Axios response headers are in lowercase, but check both just in case.\n            (_a = response.headers[header.toLowerCase()]) !== null && _a !== void 0 ? _a : response.headers[header]))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n","/** Function to update all caches, from CacheProperties.update, with the new data. */\nexport async function updateCache(storage, data, cacheUpdater) {\n    // Global cache update function.\n    if (typeof cacheUpdater === `function`) {\n        return cacheUpdater(data);\n    }\n    for (const [cacheKey, updater] of Object.entries(cacheUpdater)) {\n        if (updater === 'delete') {\n            await storage.remove(cacheKey, data.config);\n            continue;\n        }\n        const value = await storage.get(cacheKey, data.config);\n        if (value.state === 'loading') {\n            continue;\n        }\n        const newValue = await updater(value, data);\n        if (newValue === 'delete') {\n            await storage.remove(cacheKey, data.config);\n            continue;\n        }\n        if (newValue !== 'ignore') {\n            await storage.set(cacheKey, newValue, data.config);\n        }\n    }\n}\n","import { Header } from '../header/headers';\nimport { testCachePredicate } from '../util/cache-predicate';\nimport { updateCache } from '../util/update-cache';\nimport { createCacheResponse } from './util';\nexport function defaultResponseInterceptor(axios) {\n    /**\n     * Rejects cache for an response response.\n     *\n     * Also update the waiting list for this key by rejecting it.\n     */\n    const rejectResponse = async (responseId, config) => {\n        var _a;\n        // Update the cache to empty to prevent infinite loading state\n        await axios.storage.remove(responseId, config);\n        // Reject the deferred if present\n        (_a = axios.waiting[responseId]) === null || _a === void 0 ? void 0 : _a.reject();\n        delete axios.waiting[responseId];\n    };\n    const onFulfilled = async (response) => {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n        var _l;\n        const id = (response.id = (_a = (_l = response.config).id) !== null && _a !== void 0 ? _a : (_l.id = axios.generateKey(response.config)));\n        (_b = response.cached) !== null && _b !== void 0 ? _b : (response.cached = false);\n        // Response is already cached\n        if (response.cached) {\n            if (__ACI_DEV__) {\n                (_c = axios.debug) === null || _c === void 0 ? void 0 : _c.call(axios, {\n                    id,\n                    msg: 'Returned cached response'\n                });\n            }\n            return response;\n        }\n        // Request interceptor merges defaults with per request configuration\n        const cacheConfig = response.config.cache;\n        // Skip cache: either false or weird behavior\n        // config.cache should always exists, at least from global config merge.\n        if (!cacheConfig) {\n            if (__ACI_DEV__) {\n                (_d = axios.debug) === null || _d === void 0 ? void 0 : _d.call(axios, {\n                    id,\n                    msg: 'Response with config.cache falsy',\n                    data: response\n                });\n            }\n            return Object.assign(Object.assign({}, response), { cached: false });\n        }\n        const config = response.config;\n        const cache = await axios.storage.get(id, config);\n        // Update other entries before updating himself\n        if (cacheConfig === null || cacheConfig === void 0 ? void 0 : cacheConfig.update) {\n            await updateCache(axios.storage, response, cacheConfig.update);\n        }\n        if (\n        // If the request interceptor had a problem or it wasn't cached\n        cache.state !== 'loading') {\n            if (__ACI_DEV__) {\n                (_e = axios.debug) === null || _e === void 0 ? void 0 : _e.call(axios, {\n                    id,\n                    msg: \"Response not cached and storage isn't loading\",\n                    data: { cache, response }\n                });\n            }\n            return response;\n        }\n        // Config told that this response should be cached.\n        if (\n        // For 'loading' values (previous: stale), this check already ran in the past.\n        !cache.data &&\n            !(await testCachePredicate(response, cacheConfig.cachePredicate))) {\n            await rejectResponse(id, config);\n            if (__ACI_DEV__) {\n                (_f = axios.debug) === null || _f === void 0 ? void 0 : _f.call(axios, {\n                    id,\n                    msg: 'Cache predicate rejected this response'\n                });\n            }\n            return response;\n        }\n        // Avoid remnant headers from remote server to break implementation\n        for (const header of Object.keys(response.headers)) {\n            if (header.startsWith('x-axios-cache')) {\n                delete response.headers[header];\n            }\n        }\n        if (cacheConfig.etag && cacheConfig.etag !== true) {\n            response.headers[Header.XAxiosCacheEtag] = cacheConfig.etag;\n        }\n        if (cacheConfig.modifiedSince) {\n            response.headers[Header.XAxiosCacheLastModified] =\n                cacheConfig.modifiedSince === true\n                    ? 'use-cache-timestamp'\n                    : cacheConfig.modifiedSince.toUTCString();\n        }\n        let ttl = cacheConfig.ttl || -1; // always set from global config\n        if (cacheConfig === null || cacheConfig === void 0 ? void 0 : cacheConfig.interpretHeader) {\n            const expirationTime = axios.headerInterpreter(response.headers);\n            // Cache should not be used\n            if (expirationTime === 'dont cache') {\n                await rejectResponse(id, config);\n                if (__ACI_DEV__) {\n                    (_g = axios.debug) === null || _g === void 0 ? void 0 : _g.call(axios, {\n                        id,\n                        msg: `Cache header interpreted as 'dont cache'`,\n                        data: { cache, response, expirationTime }\n                    });\n                }\n                return response;\n            }\n            ttl = expirationTime === 'not enough headers' ? ttl : expirationTime;\n        }\n        const data = createCacheResponse(response, cache.data);\n        if (typeof ttl === 'function') {\n            ttl = await ttl(response);\n        }\n        if (cacheConfig.staleIfError) {\n            response.headers[Header.XAxiosCacheStaleIfError] = String(ttl);\n        }\n        if (__ACI_DEV__) {\n            (_h = axios.debug) === null || _h === void 0 ? void 0 : _h.call(axios, {\n                id,\n                msg: 'Useful response configuration found',\n                data: { cacheConfig, cacheResponse: data }\n            });\n        }\n        const newCache = {\n            state: 'cached',\n            ttl,\n            createdAt: Date.now(),\n            data\n        };\n        // Resolve all other requests waiting for this response\n        const waiting = axios.waiting[id];\n        if (waiting) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            waiting.resolve(newCache.data);\n            delete axios.waiting[id];\n            if (__ACI_DEV__) {\n                (_j = axios.debug) === null || _j === void 0 ? void 0 : _j.call(axios, {\n                    id,\n                    msg: 'Found waiting deferred(s) and resolved them'\n                });\n            }\n        }\n        // Define this key as cache on the storage\n        await axios.storage.set(id, newCache, config);\n        if (__ACI_DEV__) {\n            (_k = axios.debug) === null || _k === void 0 ? void 0 : _k.call(axios, {\n                id,\n                msg: 'Response cached',\n                data: { cache: newCache, response }\n            });\n        }\n        // Return the response with cached as false, because it was not cached at all\n        return response;\n    };\n    const onRejected = async (error) => {\n        var _a, _b, _c, _d, _e, _f;\n        const config = error.config;\n        // config.cache should always exists, at least from global config merge.\n        if (!(config === null || config === void 0 ? void 0 : config.cache) || !config.id) {\n            if (__ACI_DEV__) {\n                (_a = axios.debug) === null || _a === void 0 ? void 0 : _a.call(axios, {\n                    msg: 'Web request returned an error but cache handling is not enabled',\n                    data: { error }\n                });\n            }\n            throw error;\n        }\n        const cache = await axios.storage.get(config.id, config);\n        const cacheConfig = config.cache;\n        if (\n        // This will only not be loading if the interceptor broke\n        cache.state !== 'loading' ||\n            cache.previous !== 'stale') {\n            await rejectResponse(config.id, config);\n            if (__ACI_DEV__) {\n                (_b = axios.debug) === null || _b === void 0 ? void 0 : _b.call(axios, {\n                    msg: 'Caught an error in the request interceptor',\n                    data: { error, config }\n                });\n            }\n            throw error;\n        }\n        if (cacheConfig === null || cacheConfig === void 0 ? void 0 : cacheConfig.staleIfError) {\n            const staleIfError = typeof cacheConfig.staleIfError === 'function'\n                ? await cacheConfig.staleIfError(error.response, cache, error)\n                : cacheConfig.staleIfError;\n            if (__ACI_DEV__) {\n                (_c = axios.debug) === null || _c === void 0 ? void 0 : _c.call(axios, {\n                    msg: 'Found cache if stale config for rejected response',\n                    data: { error, config, staleIfError }\n                });\n            }\n            if (staleIfError === true ||\n                // staleIfError is the number of seconds that stale is allowed to be used\n                (typeof staleIfError === 'number' && cache.createdAt + staleIfError > Date.now())) {\n                // Resolve all other requests waiting for this response\n                (_d = axios.waiting[config.id]) === null || _d === void 0 ? void 0 : _d.resolve(cache.data);\n                delete axios.waiting[config.id];\n                // re-mark the cache as stale\n                await axios.storage.set(config.id, {\n                    state: 'stale',\n                    createdAt: Date.now(),\n                    data: cache.data\n                }, config);\n                if (__ACI_DEV__) {\n                    (_e = axios.debug) === null || _e === void 0 ? void 0 : _e.call(axios, {\n                        msg: 'staleIfError resolved this response with cached data',\n                        data: { error, config, cache }\n                    });\n                }\n                return {\n                    cached: true,\n                    config,\n                    id: config.id,\n                    data: cache.data.data,\n                    headers: cache.data.headers,\n                    status: cache.data.status,\n                    statusText: cache.data.statusText\n                };\n            }\n        }\n        if (__ACI_DEV__) {\n            (_f = axios.debug) === null || _f === void 0 ? void 0 : _f.call(axios, {\n                msg: 'Received an unknown error that could not be handled',\n                data: { error, config }\n            });\n        }\n        throw error;\n    };\n    return {\n        onFulfilled,\n        onRejected,\n        apply: () => axios.interceptors.response.use(onFulfilled, onRejected)\n    };\n}\n","import { Header } from '../header/headers';\n/** Returns true if the provided object was created from {@link buildStorage} function. */\nexport const isStorage = (obj) => !!obj && !!obj['is-storage'];\n/** Returns true if this storage is expired, but it has sufficient properties to stale. */\nexport function canStale(value) {\n    const headers = value.data.headers;\n    return (Header.ETag in headers ||\n        Header.LastModified in headers ||\n        Header.XAxiosCacheEtag in headers ||\n        Header.XAxiosCacheStaleIfError in headers ||\n        Header.XAxiosCacheLastModified in headers);\n}\n/** Checks if the provided cache is expired. You should also check if the cache {@link canStale} */\nexport function isExpired(value) {\n    return value.createdAt + value.ttl <= Date.now();\n}\n/**\n * Builds a custom storage.\n *\n * **Note**: You can only create an custom storage with this function.\n *\n * @example\n *\n * ```js\n * const myStorage = buildStorage({\n *   find: () => {...},\n *   set: () => {...},\n *   remove: () => {...}\n * });\n *\n * const axios = setupCache(axios, { storage: myStorage });\n * ```\n */\nexport function buildStorage({ set, find, remove }) {\n    return {\n        //@ts-expect-error - we don't want to expose thi\n        ['is-storage']: 1,\n        set,\n        remove,\n        get: async (key, config) => {\n            const value = await find(key, config);\n            if (!value) {\n                return { state: 'empty' };\n            }\n            if (\n            // Not cached or fresh value\n            value.state !== 'cached' ||\n                !isExpired(value)) {\n                return value;\n            }\n            if (canStale(value)) {\n                const stale = {\n                    state: 'stale',\n                    createdAt: value.createdAt,\n                    data: value.data\n                };\n                await set(key, stale, config);\n                return stale;\n            }\n            await remove(key, config);\n            return { state: 'empty' };\n        }\n    };\n}\n","import { buildStorage } from './build';\n/**\n * Creates a simple in-memory storage. This means that if you need to persist data between\n * page or server reloads, this will not help.\n *\n * This is the storage used by default.\n *\n * If you need to modify it's data, you can do by the `data` property.\n *\n * @example\n *\n * ```js\n * const memoryStorage = buildMemoryStorage();\n *\n * setupCache(axios, { storage: memoryStorage });\n *\n * // Simple example to force delete the request cache\n *\n * const { id } = axios.get('url');\n *\n * delete memoryStorage.data[id];\n * ```\n *\n * @param {boolean} cloneData If the data returned by `find()` should be cloned to avoid\n *   mutating the original data outside the `set()` method.\n */\nexport function buildMemoryStorage(cloneData = false) {\n    const storage = buildStorage({\n        set: (key, value) => {\n            storage.data[key] = value;\n        },\n        remove: (key) => {\n            delete storage.data[key];\n        },\n        find: (key) => {\n            const value = storage.data[key];\n            if (cloneData && value !== undefined) {\n                /* istanbul ignore if 'only available on super recent browsers' */\n                if (typeof structuredClone === 'function') {\n                    return structuredClone(value);\n                }\n                return JSON.parse(JSON.stringify(value));\n            }\n            return value;\n        }\n    });\n    storage.data = Object.create(null);\n    return storage;\n}\n","function r(t){var n=typeof t;if(t&&\"object\"===n&&!(t instanceof Date||t instanceof RegExp)){for(var e=Array.isArray(t)?[]:{},o=Object.keys(t).sort(function(r,t){return r>t?1:-1}),i=o.length;i--;){var a=o[i];e[a]=r(t[a])}return String(t.constructor)+JSON.stringify(e,o)}return n+String(t)}function t(t){t=r(t);for(var n=5381,e=0;e<t.length;)n=33*n^t.charCodeAt(e++);return n}export{t as hash,r as serialize};\n//# sourceMappingURL=index.mjs.map\n","import { hash } from 'object-code';\n// Remove first and last '/' char, if present\nconst SLASHES_REGEX = /^\\/|\\/$/g;\n/**\n * Builds an generator that receives a {@link CacheRequestConfig} and returns a value\n * hashed by {@link hash}.\n *\n * The value is hashed into a signed integer when the returned value from the provided\n * generator is not a `string` or a `number`.\n *\n * You can return any type of data structure.\n *\n * @example\n *\n * ```js\n * // This generator will return a hash code.\n * // The code will only be the same if url, method and data are the same.\n * const generator = buildKeyGenerator(({ url, method, data }) => ({\n *   url,\n *   method,\n *   data\n * }));\n * ```\n */\nexport function buildKeyGenerator(generator) {\n    return (request) => {\n        if (request.id) {\n            return request.id;\n        }\n        const key = generator(request);\n        if (typeof key === 'string' || typeof key === 'number') {\n            return `${key}`;\n        }\n        return `${hash(key)}`;\n    };\n}\nexport const defaultKeyGenerator = buildKeyGenerator(({ baseURL = '', url = '', method = 'get', params, data }) => {\n    // Remove trailing slashes to avoid generating different keys for the \"same\" final url.\n    baseURL && (baseURL = baseURL.replace(SLASHES_REGEX, ''));\n    url && (url = url.replace(SLASHES_REGEX, ''));\n    // lowercase method\n    method && (method = method.toLowerCase());\n    return {\n        url: baseURL + (baseURL && url ? '/' : '') + url,\n        params: params,\n        method,\n        data\n    };\n});\n","import { defaultHeaderInterpreter } from '../header/interpreter';\nimport { defaultRequestInterceptor } from '../interceptors/request';\nimport { defaultResponseInterceptor } from '../interceptors/response';\nimport { isStorage } from '../storage/build';\nimport { buildMemoryStorage } from '../storage/memory';\nimport { defaultKeyGenerator } from '../util/key-generator';\n/**\n * Apply the caching interceptors for a already created axios instance.\n *\n * @example\n *\n * ```ts\n * import Axios from 'axios';\n * import { setupCache, AxiosCacheInstance } from 'axios-cache-interceptor';\n *\n * // instance will have our custom typings from the return of this function\n * const instance = setupCache(\n *   Axios.create({\n *     // Axios options\n *   }),\n *   {\n *     // Axios-cache-interceptor options\n *   }\n * );\n *\n * // OR\n *\n * const instance = axios.create({\n *   // Axios options\n * }) as AxiosCacheInstance;\n *\n * // As this functions returns the same axios instance but only with\n * // different typings, you can ignore the function return.\n * setupCache(instance, {\n *   // Axios-cache-interceptor options\n * });\n * ```\n *\n * @param axios The already created axios instance\n * @param config The config for the caching interceptors\n * @returns The same instance with extended typescript types.\n */\nexport function setupCache(axios, options = {}) {\n    var _a, _b, _c, _d, _e;\n    const axiosCache = axios;\n    axiosCache.storage = options.storage || buildMemoryStorage();\n    if (!isStorage(axiosCache.storage)) {\n        throw new Error('Use buildStorage() function');\n    }\n    axiosCache.waiting = options.waiting || {};\n    axiosCache.generateKey = options.generateKey || defaultKeyGenerator;\n    axiosCache.headerInterpreter = options.headerInterpreter || defaultHeaderInterpreter;\n    axiosCache.requestInterceptor =\n        options.requestInterceptor || defaultRequestInterceptor(axiosCache);\n    axiosCache.responseInterceptor =\n        options.responseInterceptor || defaultResponseInterceptor(axiosCache);\n    axiosCache.debug = options.debug;\n    // CacheRequestConfig values\n    axiosCache.defaults.cache = {\n        update: options.update || {},\n        ttl: (_a = options.ttl) !== null && _a !== void 0 ? _a : 1000 * 60 * 5,\n        methods: options.methods || ['get'],\n        cachePredicate: options.cachePredicate || {\n            statusCheck: (status) => status >= 200 && status < 400\n        },\n        etag: (_b = options.etag) !== null && _b !== void 0 ? _b : true,\n        // This option is going to be ignored by servers when ETag is enabled\n        // Checks strict equality to false to avoid undefined-ish values\n        modifiedSince: (_c = options.modifiedSince) !== null && _c !== void 0 ? _c : options.etag === false,\n        interpretHeader: (_d = options.interpretHeader) !== null && _d !== void 0 ? _d : true,\n        staleIfError: (_e = options.staleIfError) !== null && _e !== void 0 ? _e : true,\n        override: false\n    };\n    // Apply interceptors\n    axiosCache.requestInterceptor.apply();\n    axiosCache.responseInterceptor.apply();\n    return axiosCache;\n}\n","import { buildStorage, canStale, isExpired } from './build';\n/**\n * Creates a simple storage. You can persist his data by using `sessionStorage` or\n * `localStorage` with it.\n *\n * **ImplNote**: Without polyfill, this storage only works on browser environments.\n *\n * @example\n *\n * ```js\n * const fromLocalStorage = buildWebStorage(localStorage);\n * const fromSessionStorage = buildWebStorage(sessionStorage);\n *\n * const myStorage = new Storage();\n * const fromMyStorage = buildWebStorage(myStorage);\n * ```\n *\n * @param storage The type of web storage to use. localStorage or sessionStorage.\n * @param prefix The prefix to index the storage. Useful to prevent collision between\n *   multiple places using the same storage.\n */\nexport function buildWebStorage(storage, prefix = '') {\n    return buildStorage({\n        find: (key) => {\n            const json = storage.getItem(prefix + key);\n            return json ? JSON.parse(json) : undefined;\n        },\n        remove: (key) => {\n            storage.removeItem(prefix + key);\n        },\n        set: (key, value) => {\n            const save = () => storage.setItem(prefix + key, JSON.stringify(value));\n            try {\n                return save();\n            }\n            catch (error) {\n                const allValues = Object.entries(storage)\n                    .filter((item) => item[0].startsWith(prefix))\n                    .map((item) => [item[0], JSON.parse(item[1])]);\n                // Remove all expired values\n                for (const value of allValues) {\n                    if (value[1].state === 'cached' && isExpired(value[1]) && !canStale(value[1])) {\n                        storage.removeItem(value[0]);\n                    }\n                }\n                // Try save again after removing expired values\n                try {\n                    return save();\n                }\n                catch (_a) {\n                    // Storage still full, try removing the oldest value until it can be saved\n                    // Descending sort by createdAt\n                    const sortedItems = allValues.sort((a, b) => (a[1].createdAt || 0) - (b[1].createdAt || 0));\n                    for (const item of sortedItems) {\n                        storage.removeItem(item[0]);\n                        try {\n                            return save();\n                        }\n                        catch (_b) {\n                            // This key didn't free all the required space\n                        }\n                    }\n                }\n                // Clear the cache for the specified key\n                storage.removeItem(prefix + key);\n            }\n        }\n    });\n}\n","export * from './cache/axios';\nexport * from './cache/cache';\nexport * from './cache/create';\nexport * from './header/headers';\nexport * from './header/interpreter';\nexport * from './header/types';\nexport * from './interceptors/build';\nexport * from './interceptors/request';\nexport * from './interceptors/response';\nexport * from './interceptors/util';\nexport * from './storage/build';\nexport * from './storage/memory';\nexport * from './storage/types';\nexport * from './storage/web-api';\nexport * from './util/cache-predicate';\nexport * from './util/key-generator';\nexport * from './util/types';\nexport * from './util/update-cache';\nif (__ACI_DEV__) {\n    console.error('You are using a development build. Make sure to use the correct build in production\\nhttps://axios-cache-interceptor.js.org/#/pages/installing\\n\\n');\n}\n"],"names":["root","factory","exports","module","define","amd","self","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","e","a","Number","Infinity","r","t","Header","freeze","IfModifiedSince","LastModified","IfNoneMatch","CacheControl","ETag","Expires","Age","XAxiosCacheEtag","XAxiosCacheLastModified","XAxiosCacheStaleIfError","defaultHeaderInterpreter","headers","cacheControl","noCache","noStore","mustRevalidate","maxAge","immutable","s","n","i","toLowerCase","replace","split","u","l","m","p","h","maxStale","minFresh","mustUnderstand","noTransform","onlyIfCached","private","proxyRevalidate","public","sMaxAge","staleIfError","staleWhileRevalidate","String","undefined","age","expires","milliseconds","Date","parse","now","createValidateStatus","oldValidate","status","isMethodIn","requestMethod","methodList","some","method","updateStaleRequest","cache","config","_a","etag","modifiedSince","etagValue","data","createdAt","toUTCString","createCacheResponse","response","previousCache","cached","statusText","assign","defaultRequestInterceptor","axios","onFulfilled","async","_b","_c","_d","_e","_f","_g","_h","_j","id","generateKey","debug","msg","defaults","methods","storage","overrideCache","override","ignoreAndRequest","state","waiting","Promise","resolve","reject","catch","set","previous","validateStatus","cachedResponse","deferred","remove","err","adapter","apply","interceptors","request","use","testCachePredicate","predicate","statusCheck","responseMatch","containsHeaders","header","entries","updateCache","cacheUpdater","cacheKey","updater","newValue","defaultResponseInterceptor","rejectResponse","responseId","_k","_l","cacheConfig","update","cachePredicate","keys","startsWith","ttl","interpretHeader","expirationTime","headerInterpreter","cacheResponse","newCache","onRejected","error","isStorage","canStale","isExpired","buildStorage","find","stale","buildMemoryStorage","cloneData","structuredClone","JSON","stringify","create","RegExp","Array","isArray","sort","length","constructor","charCodeAt","SLASHES_REGEX","buildKeyGenerator","generator","defaultKeyGenerator","baseURL","url","params","setupCache","options","axiosCache","Error","requestInterceptor","responseInterceptor","buildWebStorage","prefix","json","getItem","removeItem","save","setItem","allValues","filter","item","map","sortedItems","b","console"],"sourceRoot":""}