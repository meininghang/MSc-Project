var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/Crypto.ts
var Crypto_exports = {};
__export(Crypto_exports, {
  default: () => Crypto
});
module.exports = __toCommonJS(Crypto_exports);
var import_cipher = require("./util/cipher");
var import_MindLake = require("./MindLake");
var import_uuid = require("uuid");
var import_result = __toESM(require("./util/result"));
var Crypto = class {
  constructor(sdk) {
    this.service = sdk.service;
    this.web3 = sdk.web3;
    this.sdk = sdk;
  }
  /**
   * encrypt method
   * @param tableName
   * @param columnName
   * @param data
   * @param schema
   */
  async encrypt(data, tableNameColumnName) {
    try {
      import_MindLake.MindLake.checkLogin();
      this.sdk.checkRegistered();
      const walletAddress = await this.web3.getWalletAccount();
      let encType;
      let ccEntry;
      if (typeof tableNameColumnName === "string") {
        const [tableName, columnName] = tableNameColumnName.split(".");
        encType = await this.service.execute({ bizType: 107, tableName, column: columnName });
        ccEntry = await this._getOrGenDek(
          tableName,
          columnName,
          walletAddress
        );
      } else {
        encType = tableNameColumnName;
        const { ctxId, algorithm, encryptedDek } = await this.service.execute({ bizType: 108 });
        const mekBuffer = await this.web3.getMekBytes();
        const [_, decryptedDek] = import_cipher.CipherHelper.decryptDekToBase64(mekBuffer, encryptedDek);
        ccEntry = { ctxId, algorithm, decryptedDek };
      }
      if (encType > 4) {
        encType += 1;
      }
      const encodeDataBuffer = import_cipher.CipherHelper.encodeDataByType(data, encType);
      const header = this._genCryptoHeader(ccEntry.ctxId, encType);
      const checkCode = this._genCheckCode(encodeDataBuffer, 1);
      const data_to_enc = Buffer.concat([
        encodeDataBuffer,
        Buffer.from(checkCode)
      ]);
      let encrypted_data;
      const iv = import_cipher.CipherHelper.randomBytes();
      if (ccEntry.algorithm === 3) {
        encrypted_data = import_cipher.CipherHelper.aesEncrypt(ccEntry.decryptedDek, iv, data_to_enc);
      }
      if (!encrypted_data) {
        throw new Error("aesEncrypt error");
      }
      const buf = Buffer.concat([header, iv, encrypted_data]);
      const temp = buf.slice(1);
      const checkCode2 = this._genCheckCode(temp, 1);
      const result = Buffer.concat([checkCode2, temp]);
      return import_result.default.success(`\\x${Buffer.from(result).toString("hex")}`);
    } catch (e) {
      console.error(e);
      return import_result.default.fail(e);
    }
  }
  /**
   *
   * @param hex
   */
  async decrypt(hex) {
    try {
      import_MindLake.MindLake.checkLogin();
      this.sdk.checkRegistered();
      const mek = await this.web3.getMekBytes();
      const encryptData = hex.replace("\\x", "");
      const encryptDataBuffer = Buffer.from(encryptData, "hex");
      const header = this._extractCryptoHeader(encryptDataBuffer);
      const cxtId = this._extractCtxId(header);
      const { encryptedDek, algorithm } = await this.service.execute({
        bizType: 111,
        ctxId: String(cxtId)
      });
      const [_, dek] = import_cipher.CipherHelper.decryptDekToBase64(mek, encryptedDek);
      const afterEncType = this._extractEncType(header);
      const idx = (header[1] & 7) + 2;
      const iv = encryptDataBuffer.slice(idx, idx + 16);
      const cipherBlob = encryptDataBuffer.slice(idx + 16);
      const plainBlob = import_cipher.CipherHelper.aesDecrypt(dek, iv, cipherBlob);
      const encodeResult = plainBlob.subarray(0, -1);
      const checkCode = plainBlob.slice(-1);
      const checkCode2 = this._genCheckCode(encodeResult, 1);
      if (checkCode[0] != checkCode2[0]) {
        throw new Error("Check code is not correct");
      }
      const decryptData = import_cipher.CipherHelper.decodeDataByType(
        Uint8Array.from(encodeResult),
        afterEncType
      );
      return import_result.default.success(decryptData);
    } catch (e) {
      console.error(e);
      return import_result.default.fail(e);
    }
  }
  /**
   * get dek
   * @param schema
   * @param table
   * @param column
   * @param walletAddress
   * @private
   */
  async _getOrGenDek(table, column, walletAddress) {
    const mekBuffer = await this.web3.getMekBytes();
    let cc = await this._queryCCEntryByName(
      table,
      column,
      walletAddress
    ).catch((e) => {
    });
    if (!cc) {
      cc = await this._genCCEntryFromLocal(table, column);
    }
    const { ctxId, dekId, encryptedDek, algorithm } = cc;
    const [, decryptedDek] = import_cipher.CipherHelper.decryptDekToBase64(
      mekBuffer,
      encryptedDek
    );
    return { ctxId, decryptedDek, algorithm };
  }
  async _queryCCEntryByName(table, column, walletAddress) {
    return await this.service.execute({
      bizType: 108,
      table,
      column,
      walletAddress
    });
  }
  async _genCCEntryFromLocal(table, column) {
    const dekId = await this.service.execute({
      bizType: 109,
      mekId: this.sdk.mekId
    });
    const dek = import_cipher.CipherHelper.randomBytes();
    const mek = await this.web3.getMekBytes();
    return this._genSQLInsertDek(
      this.sdk.mekId,
      dekId,
      mek,
      dek,
      3,
      table,
      column
    );
  }
  async _genSQLInsertDek(mekId, dekId, mek, dek, alg = 3, table, column) {
    var _a;
    const dekCipherStr = import_cipher.CipherHelper.encryptDekToBase64(mek, dekId, dek);
    const grpIdStr = (0, import_uuid.v4)();
    const uuidStringWithoutHyphen = grpIdStr.replace(/-/g, "");
    const _gripId = Buffer.from(
      ((_a = uuidStringWithoutHyphen.match(/.{1,2}/g)) == null ? void 0 : _a.map((byte) => parseInt(byte, 16))) || []
    );
    const gAuthStr = import_cipher.CipherHelper.digest_gAuth(mek, _gripId, dekId);
    return this.service.execute({
      bizType: 110,
      table,
      column,
      schema: "public",
      mekId,
      dekId,
      dekCipherStr,
      grpIdStr,
      groupAuthStr: gAuthStr
    });
  }
  _genCryptoHeader(ctxId, encType) {
    let head = Buffer.from("0000", "hex");
    let tmp_value = head[1];
    tmp_value = tmp_value & 4294967047;
    tmp_value = tmp_value | encType << 3;
    head[1] = tmp_value;
    let tmp = ctxId;
    while (tmp != 0) {
      head = Buffer.concat([head, Buffer.alloc(1).fill(tmp & 255)]);
      tmp >>= 8;
    }
    const ctxLen = head.length - 2;
    let tmp_val = head[1];
    tmp_val = tmp_val & 4294967288 | ctxLen & 7;
    head[1] = tmp_val;
    return head;
  }
  _extractCryptoHeader(data) {
    let header = [];
    let index = 0;
    for (let i = 0; i < 1; i++) {
      header.push(data[index]);
      index++;
    }
    if (index !== 1) {
      throw new Error("Invalid header index");
    }
    header.push(data[index]);
    index++;
    const rng = header[1] & 7;
    for (let i = 0; i < rng; i++) {
      header.push(data[index]);
      index++;
    }
    return Buffer.from(header);
  }
  _extractEncType(header) {
    const tmp_value = header[1];
    const type_value = (tmp_value & 248) >> 3;
    return type_value;
  }
  _extractCtxId(header) {
    const ctxIdLen = header[1] & 7;
    if (header.length !== ctxIdLen + 2) {
      throw new Error("Invalid header length");
    }
    let ctxId = 0;
    for (let i = 0; i < ctxIdLen; i++) {
      const index = header.length - 1 - i;
      ctxId = ctxId << 8 | header[index] & 255;
    }
    return ctxId;
  }
  _genCheckCode(encodeData, resultSize) {
    let tmpCode = new Uint8Array(resultSize);
    for (let i = 0; i < encodeData.length; i++) {
      let n = i % resultSize;
      tmpCode[n] ^= encodeData[i];
    }
    return Buffer.from(tmpCode);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
