var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/MindLake.ts
var MindLake_exports = {};
__export(MindLake_exports, {
  MindLake: () => MindLake
});
module.exports = __toCommonJS(MindLake_exports);
var import_request = require("./request");
var import_constant = require("./util/constant");
var import_cipher = require("./util/cipher");
var import_web3 = require("./util/web3");
var import_util = require("./util/util");
var import_Crypto = __toESM(require("./Crypto"));
var import_DataLake = __toESM(require("./DataLake"));
var import_bcl = require("./util/bcl");
var import_types = require("./types");
var import_Permission = __toESM(require("./Permission"));
var import_result = __toESM(require("./util/result"));
var import_package = __toESM(require("../package.json"));
var _MindLake = class {
  constructor(appKey, nodeUrl) {
    /**
     * mind db is init
     */
    this.isRegistered = false;
    localStorage.setItem(import_constant.APP_KEY, appKey);
    this.service = new import_request.Service(nodeUrl);
    this.web3 = new import_web3.Web3Interact();
  }
  static async getInstance(appKey, nodeUrl) {
    if (this.instance === void 0) {
      this.instance = new _MindLake(appKey, nodeUrl);
      await this.instance.web3.checkConnection();
      await this.instance._getServerInfo();
      this.instance.crypto = new import_Crypto.default(this.instance);
      this.instance.dataLake = new import_DataLake.default(this.instance);
      this.instance.permission = new import_Permission.default(this.instance);
    }
    return this.instance;
  }
  /**
   *connect db
   */
  async connect() {
    try {
      const walletAddress = await this.web3.getWalletAccount();
      const nonce = await this.service.execute({
        bizType: 203,
        walletAddress
      });
      const signature = await this.web3.personalSignature(nonce);
      const res = await this.service.execute({
        bizType: 201,
        walletAddress,
        signature
      });
      if (res && res.token) {
        localStorage.setItem(import_constant.TOKEN_KEY, res.token);
        await this._init();
        _MindLake.isConnected = true;
        return import_result.default.success(true);
      }
      return import_result.default.fail(false);
    } catch (e) {
      console.error(e);
      localStorage.removeItem(import_constant.TOKEN_KEY);
      return import_result.default.fail(e);
    }
  }
  /**
   * disconnect db
   */
  async disConnect() {
    try {
      await this.service.execute({ bizType: 202 });
      return import_result.default.success(true);
    } catch (e) {
      console.error(e);
      return import_result.default.fail(e);
    }
  }
  /**
   * getEnclaveInfo
   */
  async _getServerInfo() {
    const info = await this.service.execute({
      bizType: 120
    }).catch((e) => console.error(e));
    if (info) {
      _MindLake.isConnected = true;
      this.publicKey = info.publicKey;
      this.isRegistered = info.isRegistered && info.isMekProvision && info.isSelfBcl;
      this.mekId = info.mekId;
      if (this.isRegistered && this.mekId) {
        await this._getAccount();
      }
    }
  }
  async _init() {
    await this._getServerInfo();
    const provisionRes = await this._mekProvision();
    if (!provisionRes) {
      throw new Error("Provision failed");
    }
    if (!this.isRegistered) {
      const { privateKeyPem, publicKeyPem } = await this.web3.getPkPem();
      const registerPukId = await this._registerCertificate(
        publicKeyPem,
        privateKeyPem
      );
      if (!registerPukId) {
        throw new Error("Register key pair failed");
      }
      this.registerPukId = registerPukId;
      const sn = await this._issueBclForSelf(privateKeyPem);
      if (!sn) {
        throw new Error("Grant for self failed");
      }
      this.isRegistered = true;
    }
  }
  /**
   * mek provision
   * @private
   */
  async _mekProvision() {
    if (!this.publicKey) {
      throw new Error("Provision failed: The public key is not empty");
    }
    const pubKey = this.publicKey.replace("\\n", "\n");
    const ephemeralKey = import_cipher.CipherHelper.randomBytes();
    const sealedEphemeralKey = import_cipher.CipherHelper.rsaEncrypt(
      pubKey,
      ephemeralKey
    );
    const sealedEphemeralKeyLenBytes = new Buffer([
      sealedEphemeralKey.length & 255,
      sealedEphemeralKey.length >> 8 & 255
    ]);
    const iv = import_cipher.CipherHelper.randomBytes();
    const envelope_json = await this._genEnvelope();
    const envelope_enc = import_cipher.CipherHelper.aesEncrypt(
      ephemeralKey,
      iv,
      envelope_json
    );
    const big_envelope = Buffer.concat([
      sealedEphemeralKeyLenBytes,
      sealedEphemeralKey,
      iv,
      envelope_enc
    ]);
    const big_envelopeBase64 = Buffer.from(big_envelope).toString("base64");
    return await this.service.execute({
      bizType: 102,
      databasePublicKey: this.publicKey,
      envelope: big_envelopeBase64
    });
  }
  /**
   * registerCertificate pukId
   * @private
   */
  async _registerCertificate(publicKeyPem, privateKeyPem) {
    const mekId = this.mekId;
    const mek = await this.web3.getMekBytes();
    const pukId = import_cipher.CipherHelper.sha256Hash(publicKeyPem);
    const toBeSignedBytes = Buffer.concat([
      Buffer.from(import_util.Util.structPackq(mekId)),
      Buffer.from(pukId, "latin1")
      //important
    ]);
    const rsaSign = Buffer.concat([
      Buffer.from("01", "hex"),
      import_cipher.CipherHelper.rsaSign(privateKeyPem, toBeSignedBytes)
    ]);
    const private_sig = rsaSign.toString("base64");
    const mekSign = Buffer.concat([
      Buffer.from("00", "hex"),
      import_cipher.CipherHelper.hmacHash(mek, toBeSignedBytes)
    ]);
    const mek_sign = mekSign.toString("base64");
    const res = await this.service.execute({
      bizType: 104,
      mekId,
      pukId,
      publicKey: publicKeyPem,
      privateSig: private_sig,
      mekSig: mek_sign
    });
    if (res) {
      return pukId;
    }
  }
  /**
   * issueBclForSelf
   * @param privateKeyPem
   * @private
   */
  async _issueBclForSelf(privateKeyPem) {
    const bcl = new import_bcl.Bcl(this.service);
    await bcl.createBclBody(this.registerPukId, this.registerPukId, "");
    const defaultGroup = await this.service.execute({ bizType: 108 });
    if (!defaultGroup || !defaultGroup.groupId) {
      throw new Error("Get default group error");
    }
    const selfDekGroup = {
      groupid: defaultGroup.groupId,
      min: 1,
      max: 1e3
    };
    bcl.addDekGroup(selfDekGroup, selfDekGroup);
    return await bcl.issueBcl(privateKeyPem, 106);
  }
  async _genEnvelope() {
    const mek = await this.web3.getMekBytes();
    let envelope = {};
    const base64Mek = Buffer.from(mek).toString("base64");
    envelope["mek"] = base64Mek;
    envelope["expire"] = 0;
    let envelope_json = JSON.stringify(envelope).replace(" ", "");
    return envelope_json;
  }
  async _getAccount() {
    const registerPukId = await this.service.execute({
      bizType: 103,
      mekId: this.mekId
    });
    this.registerPukId = registerPukId;
  }
  static checkLogin() {
    if (!_MindLake.isConnected) {
      throw new Error("Please connect first");
    }
  }
  checkRegistered() {
    if (!this.isRegistered) {
      throw new Error("Register error, please reLogin to register");
    }
  }
};
var MindLake = _MindLake;
/**
 * mindLake version
 */
MindLake.version = import_package.default.version;
/**
 * isConnected mindDB
 */
MindLake.isConnected = false;
MindLake.log = false;
MindLake.DataType = import_types.DataType;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  MindLake
});
