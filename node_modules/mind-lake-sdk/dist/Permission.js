var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/Permission.ts
var Permission_exports = {};
__export(Permission_exports, {
  default: () => Permission
});
module.exports = __toCommonJS(Permission_exports);
var import_MindLake = require("./MindLake");
var import_bcl = require("./util/bcl");
var import_result = __toESM(require("./util/result"));
var Permission = class {
  constructor(sdk) {
    this.service = sdk.service;
    this.web3 = sdk.web3;
    this.sdk = sdk;
  }
  /**
   *
   * @param targetWalletAddress
   */
  async grant(targetWalletAddress, columns) {
    try {
      import_MindLake.MindLake.checkLogin();
      this.sdk.checkRegistered();
      if (!columns.length) {
        throw new Error("no columns to need grant");
      }
      const bcl = new import_bcl.Bcl(this.service);
      const res = await this.service.execute({ bizType: 119, targetWalletAddress });
      if (!res || !res.publicKeyId) {
        throw new Error(
          "Peer user (Subject)'s certificate hasn't been registered."
        );
      }
      await bcl.createBclBody(this.sdk.registerPukId, res.publicKeyId, "");
      const eachFunc = async (data) => {
        for (const tableColumn of data) {
          const [table, column] = tableColumn.split(".");
          await this._addColumnIntoBcl(bcl, table, column);
        }
      };
      await eachFunc(columns);
      const { privateKeyPem } = await this.sdk.web3.getPkPem();
      const sn = await bcl.issueBcl(privateKeyPem, 115);
      return import_result.default.success(sn);
    } catch (e) {
      console.error(e);
      return import_result.default.fail(e);
    }
  }
  /**
   *
   * @param policyId
   */
  async confirm(policyId) {
    try {
      import_MindLake.MindLake.checkLogin();
      this.sdk.checkRegistered();
      if (!policyId) {
        throw new Error("The policy id is empty");
      }
      const bcl = new import_bcl.Bcl(this.service);
      await bcl.loadBclBodyBySN(policyId);
      if (!bcl.bclBody || !bcl.bclBody.serial_num) {
        throw new Error("The policyID is not correct");
      }
      const { privateKeyPem } = await this.web3.getPkPem();
      const sn = await bcl.issueBcl(privateKeyPem, 117);
      return import_result.default.success(sn);
    } catch (e) {
      console.error(e);
      return import_result.default.fail(e);
    }
  }
  /**
   * revoke grant
   * @param targetWalletAddress
   * @param columns, if the columns is empty ,will revoke all
   */
  async revoke(targetWalletAddress, columns) {
    try {
      import_MindLake.MindLake.checkLogin();
      this.sdk.checkRegistered();
      const bcl = new import_bcl.Bcl(this.service);
      const res = await this.service.execute({ bizType: 119, targetWalletAddress });
      if (!res || !res.publicKeyId) {
        throw new Error(
          "Peer user (Subject)'s certificate hasn't been registered."
        );
      }
      await bcl.loadBclBodyByPukId(this.sdk.registerPukId, res.publicKeyId);
      if (!bcl.bclBody || !bcl.bclBody.serial_num) {
        throw new Error("No grant required to revoke!");
      }
      if (!columns || !columns.length) {
        bcl.removeDekGroupAll();
      } else {
        const groupIdArray = new Array();
        const eachFunc = async (data) => {
          for (const column of data) {
            const ccSelf = await this.service.execute({
              bizType: 108,
              schema: "public",
              table: column.table,
              column: column.column
            });
            if (!ccSelf.groupId) {
              throw new Error("groupId is not exist");
            }
            groupIdArray.push(ccSelf.groupId);
          }
        };
        await eachFunc(columns);
        bcl.removeDekGroup(groupIdArray);
      }
      const { privateKeyPem } = await this.web3.getPkPem();
      const sn = await bcl.issueBcl(privateKeyPem, 115);
      return import_result.default.success(sn);
    } catch (e) {
      console.error(e);
      return import_result.default.fail(e);
    }
  }
  async listGrantee() {
    try {
      const data = await this.service.execute({ bizType: 126 });
      return import_result.default.success(data);
    } catch (e) {
      console.error(e);
      return import_result.default.fail(e);
    }
  }
  async listOwner() {
    try {
      const data = await this.service.execute({ bizType: 130 });
      return import_result.default.success(data);
    } catch (e) {
      console.error(e);
      return import_result.default.fail(e);
    }
  }
  async listOwnerColumn(targetWalletAddress) {
    try {
      const data = await this.service.execute({
        bizType: 131,
        targetWalletAddress
      });
      return import_result.default.success(data);
    } catch (e) {
      console.error(e);
      return import_result.default.fail(e);
    }
  }
  async listGrantedColumn(targetWalletAddress) {
    try {
      const data = await this.service.execute({
        bizType: 127,
        targetWalletAddress
      });
      return import_result.default.success(data);
    } catch (e) {
      console.error(e);
      return import_result.default.fail(e);
    }
  }
  async _addColumnIntoBcl(bcl, table, column, minId = 1, maxId = 1e3) {
    const ccSelf = await this.service.execute({
      bizType: 108,
      table,
      column
    });
    if (!ccSelf.groupId) {
      throw new Error("groupId is not exist");
    }
    const issuerDekGroup = { groupid: ccSelf.groupId, min: minId, max: maxId };
    bcl.addDekGroup(issuerDekGroup);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
