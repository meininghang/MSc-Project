var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/util/bcl.ts
var bcl_exports = {};
__export(bcl_exports, {
  Bcl: () => Bcl
});
module.exports = __toCommonJS(bcl_exports);
var import_dayjs = __toESM(require("dayjs"));
var import_uuid = require("uuid");
var import_cipher = require("./cipher");
var Bcl = class {
  constructor(service) {
    this.bclBody = {
      version: 1,
      serial_num: "",
      issuer_pukid: "",
      subject_pukid: "",
      validity: {
        not_after: "",
        not_before: ""
      },
      policies: {
        issuer_dek_group: new Array(),
        subject_dek_group: new Array(),
        result_dek: "",
        operation: "",
        postproc: "",
        preproc: ""
      }
    };
    this.service = service;
  }
  /**
   *
   * @param issuerPukid
   * @param subjectPukid
   * @param serialNum
   * @param resultDek
   * @param operation
   * @param postProc
   * @param preProc
   * @param version
   * @param notBefore
   * @param notAfter
   */
  async createBclBody(issuerPukid, subjectPukid, serialNum, version = 1, resultDek = "SUBJECT", operation = ["*"], postProc = "NULL", preProc = "NULL", notBefore, notAfter) {
    if (issuerPukid && subjectPukid) {
      await this.loadBclBodyByPukId(issuerPukid, subjectPukid);
    } else if (serialNum) {
      await this.loadBclBodyBySN(serialNum);
    }
    if (this.bclBody.serial_num) {
      return this;
    }
    if (!serialNum) {
      serialNum = (0, import_uuid.v4)();
    }
    this.bclBody.version = version;
    this.bclBody["serial_num"] = serialNum;
    this.bclBody["issuer_pukid"] = issuerPukid;
    this.bclBody["subject_pukid"] = subjectPukid;
    const nowDate = (0, import_dayjs.default)();
    if (!notBefore) {
      notBefore = nowDate.valueOf();
    }
    if (!notAfter) {
      notAfter = nowDate.add(365, "day").valueOf();
    }
    this.bclBody["validity"]["not_after"] = (0, import_dayjs.default)(notAfter).format("YYYYMMDDHHmmssZZ");
    this.bclBody["validity"]["not_before"] = (0, import_dayjs.default)(notBefore).format("YYYYMMDDHHmmssZZ");
    this.bclBody["policies"] = this._initBlankBclPolicies(
      resultDek,
      operation,
      postProc,
      preProc
    );
    return this;
  }
  /**
   * get bcl body by serialNum
   * @param serialNum
   */
  async loadBclBodyBySN(serialNum) {
    const bclBodyJson = await this.service.execute({
      bizType: 116,
      serialNum
    });
    if (bclBodyJson) {
      this.bclBody = JSON.parse(bclBodyJson);
    }
    return this;
  }
  async loadBclBodyByPukId(issuePukId, subjectPukId) {
    const bclBodyJson = await this.service.execute({
      bizType: 118,
      issuePukId,
      subjectPukId
    });
    if (bclBodyJson) {
      this.bclBody = JSON.parse(bclBodyJson);
    }
    return this;
  }
  /**
   *
   * @param issuerDekGroup
   * @param subjectDekGroup
   */
  addDekGroup(issuerDekGroup, subjectDekGroup) {
    const preIssueDekGroup = this.bclBody["policies"]["issuer_dek_group"].filter((p) => p.groupid !== issuerDekGroup.groupid);
    preIssueDekGroup.push(issuerDekGroup);
    this.bclBody["policies"]["issuer_dek_group"] = preIssueDekGroup;
    if (subjectDekGroup) {
      const preSubjectDekGroup = this.bclBody["policies"]["subject_dek_group"].filter((p) => p.groupid !== subjectDekGroup.groupid);
      preSubjectDekGroup.push(subjectDekGroup);
      this.bclBody["policies"]["subject_dek_group"] = preSubjectDekGroup;
    }
    return this;
  }
  removeDekGroup(issueGroupId, subjectDekGroupId) {
    const newIssueDekGroup = this.bclBody["policies"]["issuer_dek_group"].filter((d) => !issueGroupId.includes(d.groupid));
    this.bclBody["policies"]["issuer_dek_group"] = newIssueDekGroup;
    if (subjectDekGroupId && subjectDekGroupId.length) {
      const newSubjectDekGroup = this.bclBody["policies"]["subject_dek_group"].filter((d) => !subjectDekGroupId.includes(d.groupid));
      this.bclBody["policies"]["subject_dek_group"] = newSubjectDekGroup;
    }
    return this;
  }
  removeDekGroupAll() {
    this.bclBody["policies"]["issuer_dek_group"] = [];
    this.bclBody["policies"]["subject_dek_group"] = [];
    return this;
  }
  /**
   *
   * @param privateKeyPem
   */
  _signBclBody(privateKeyPem) {
    const toBeSignedBytes = Buffer.from(JSON.stringify(this.bclBody), "utf8");
    const buffer = Buffer.concat([
      Buffer.from("01", "hex"),
      import_cipher.CipherHelper.rsaSign(privateKeyPem, toBeSignedBytes)
    ]);
    return buffer;
  }
  /**
   *
   * @param privateKeyPem
   */
  async issueBcl(privateKeyPem, bizType = 106) {
    if (!this.bclBody.serial_num) {
      throw new Error("Bcl is not init");
    }
    const bclRequestJson = JSON.stringify(this.bclBody);
    const bclSignBuffer = this._signBclBody(privateKeyPem);
    return await this.service.execute({
      bizType,
      bclBody: bclRequestJson,
      privateSig: bclSignBuffer.toString("base64")
    });
  }
  /**
   *
   * @param result_dek
   * @param operation
   * @param postproc
   * @param preproc
   * @private
   */
  _initBlankBclPolicies(result_dek, operation, postproc, preproc) {
    const policies = {
      issuer_dek_group: [],
      subject_dek_group: [],
      result_dek,
      operation,
      post_proc: postproc,
      pre_proc: preproc
    };
    return policies;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Bcl
});
