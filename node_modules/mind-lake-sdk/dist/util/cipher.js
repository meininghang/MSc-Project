var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/util/cipher.ts
var cipher_exports = {};
__export(cipher_exports, {
  CipherHelper: () => CipherHelper
});
module.exports = __toCommonJS(cipher_exports);
var CRYPTO = __toESM(require("crypto"));
var import_node_forge = __toESM(require("node-forge"));
var import_util = require("./util");
var import_decimal = __toESM(require("decimal.js"));
var import_types = require("../types");
var Rsa = require("node-rsa");
var CipherHelper = class {
  /**
   * Obtain bytes of random length
   * @param length
   * @return Buffer
   */
  static randomBytes(length = 16) {
    return CRYPTO.randomBytes(length);
  }
  /**
   * get hash
   * @param data
   */
  static sha256Hash(data) {
    return CRYPTO.createHash("sha256").update(data).digest("base64");
  }
  /**
   * rsa sign
   * @param privateKeyPem
   * @param data
   */
  static rsaSign(privateKeyPem, data) {
    const privateKey = import_node_forge.default.pki.privateKeyFromPem(privateKeyPem);
    const md = import_node_forge.default.md.sha256.create();
    if (typeof data === "string") {
      md.update(data, "utf8");
    } else {
      const str = data.toString("latin1");
      md.update(str, "latin1");
    }
    const pss = import_node_forge.default.pss.create({
      md: import_node_forge.default.md.sha256.create(),
      mgf: import_node_forge.default.mgf.mgf1.create(import_node_forge.default.md.sha256.create()),
      saltLength: 32
    });
    const signature = privateKey.sign(md, pss);
    return Buffer.from(signature, "latin1");
  }
  static rsaEncrypt(pubKey, data) {
    const forgePublicKey = import_node_forge.default.pki.publicKeyFromPem(pubKey);
    const byteString = import_util.Util.ab2str(data);
    const encrypted = forgePublicKey.encrypt(byteString, "RSA-OAEP", {
      md: import_node_forge.default.md.sha256.create(),
      mgf1: {
        md: import_node_forge.default.md.sha256.create()
      }
    });
    return Buffer.from(encrypted, "latin1");
  }
  /**
   * get hmac hash
   * @param key
   * @param data
   */
  static hmacHash(key, data) {
    const h = CRYPTO.createHmac("sha256", key);
    h.update(data);
    return h.digest();
  }
  /**
   * create RSA keys
   * @param b
   */
  static createKeyPemString(b = 2048) {
    const key = new Rsa({ b: 2048 });
    const publicKeyPem = key.exportKey("pkcs8-public-der");
    const privateKeyPem = key.exportKey("pkcs8-private-der");
    return { publicKeyPem, privateKeyPem };
  }
  static getPublicKeyPemFromPrivate(privateKeyDer) {
    const key = new Rsa(privateKeyDer, "pkcs8-der");
    const publicKeyPem = key.exportKey("pkcs8-public-pem");
    const privateKeyPem = key.exportKey("pkcs8-private-pem");
    return { publicKeyPem, privateKeyPem };
  }
  /**
   * aes encrypt
   * @param key
   * @param iv
   * @param data
   */
  static aesEncrypt(key, iv, data) {
    const cipher = CRYPTO.createCipheriv("aes-128-cbc", key, iv);
    let encrypted_data;
    cipher.setAutoPadding(true);
    encrypted_data = cipher.update(data);
    encrypted_data = Buffer.concat([encrypted_data, cipher.final()]);
    return encrypted_data;
  }
  /**
   * aes decrypt
   * @param key
   * @param iv
   * @param data
   */
  static aesDecrypt(key, iv, data) {
    const cipher = CRYPTO.createDecipheriv("aes-128-cbc", key, iv);
    const encrypted_data_b64 = Buffer.from(data).toString("base64");
    let decrypted_data = cipher.update(encrypted_data_b64, "base64");
    decrypted_data = Buffer.concat([decrypted_data, cipher.final()]);
    return decrypted_data;
  }
  /**
   * Generate hexadecimal mk
   */
  static generateMk() {
    const mk = CipherHelper.randomBytes();
    return mk.toString("hex");
  }
  /**
   *
   * @param mk
   * @param dekId
   * @param dek
   */
  static encryptDekToBase64(mk, dekId, dek) {
    const buffer = new ArrayBuffer(8);
    const view = new DataView(buffer);
    view.setUint32(0, dekId & 4294967295, true);
    view.setUint32(4, Math.floor(dekId / 4294967296), true);
    const dekid_dek = Buffer.concat([Buffer.from(buffer), dek], 24);
    const iv = CipherHelper.randomBytes();
    const encrypted_data = CipherHelper.aesEncrypt(mk, iv, dekid_dek);
    const dekCipher = Buffer.concat([Buffer.from([3]), iv, encrypted_data]);
    return dekCipher.toString("base64");
  }
  static decryptDekToBase64(mek, dekCipherStr) {
    const dekCipher = Buffer.from(dekCipherStr, "base64");
    const dekid_dek = CipherHelper.aesDecrypt(
      mek,
      dekCipher.slice(1, 17),
      dekCipher.slice(17)
    );
    const dekid = new DataView(dekid_dek.slice(0, 8).buffer).getUint16(0, true);
    const dek = dekid_dek.slice(8);
    return [dekid, dek];
  }
  static digest_gAuth(mek, grp_id, dek_id) {
    const buffer = new ArrayBuffer(8);
    const view = new DataView(buffer);
    view.setBigInt64(0, BigInt(dek_id), true);
    const dek_id_array = Buffer.from(buffer);
    const buf = Buffer.concat([grp_id, dek_id_array]);
    const gAuth = CipherHelper.hmacHash(mek, buf);
    return gAuth.toString("base64");
  }
  static encodeDataByType(data, encType) {
    let result;
    const buffer = new ArrayBuffer(8);
    const view = new DataView(buffer);
    switch (encType) {
      case import_types.DataType.int4:
        view.setInt32(0, data, true);
        result = new Uint8Array(buffer, 0, 4);
        break;
      case import_types.DataType.int8:
        view.setBigInt64(0, BigInt(data), true);
        result = new Uint8Array(buffer);
        break;
      case import_types.DataType.float4:
        view.setFloat32(0, data, true);
        result = new Uint8Array(buffer, 0, 4);
        break;
      case import_types.DataType.float8:
        view.setFloat64(0, data, true);
        result = new Uint8Array(buffer);
        break;
      case 6:
        const val = new import_decimal.default(data);
        result = new TextEncoder().encode(val.toString());
        break;
      case 7:
        result = new TextEncoder().encode(data);
        break;
      case 8:
        const uSec = BigInt(Math.floor(data * 1e3));
        const offset = BigInt(
          Math.floor(new Date().getTimezoneOffset() * 60 * 1e6)
        );
        const adjustedUSec = uSec - BigInt(9466848e8) + offset;
        view.setBigInt64(0, adjustedUSec, true);
        result = new Uint8Array(buffer);
        break;
      default:
        throw new Error("Unsupported encryption type");
    }
    return Buffer.from(result);
  }
  static decodeDataByType(data, encType) {
    let result;
    if (encType === import_types.DataType.int4) {
      const size = 4;
      const buf = data.slice(0, size);
      result = new Int32Array(buf.buffer)[0];
    } else if (encType === import_types.DataType.int8) {
      const size = 8;
      const buf = data.slice(0, size);
      result = new BigInt64Array(buf.buffer)[0];
      result = result.toString();
    } else if (encType === import_types.DataType.float4) {
      const size = 4;
      const buf = data.slice(0, size);
      result = new Float32Array(buf.buffer)[0];
    } else if (encType === import_types.DataType.float8) {
      const size = 8;
      const buf = data.slice(0, size);
      result = new Float64Array(buf.buffer)[0];
    } else if (encType === 6) {
      result = new import_decimal.default(Buffer.from(data).toString());
      result = result.toString();
    } else if (encType === 7) {
      result = new TextDecoder().decode(data);
    } else if (encType === 8) {
      const size = 8;
      const buf = data.slice(0, size);
      let u_sec = new BigInt64Array(buf.buffer)[0];
      u_sec += BigInt(9466848e8);
      u_sec -= BigInt(new Date().getTimezoneOffset() * 60 * 1e6);
      const time_stamp = Number(u_sec) / 1e6;
      result = time_stamp * 1e3;
    } else {
      throw new Error("Unsupported encryption type");
    }
    return result;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CipherHelper
});
