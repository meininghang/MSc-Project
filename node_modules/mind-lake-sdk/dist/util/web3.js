var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/util/web3.ts
var web3_exports = {};
__export(web3_exports, {
  Web3Interact: () => Web3Interact
});
module.exports = __toCommonJS(web3_exports);
var import_abi = __toESM(require("./abi"));
var import_web3 = __toESM(require("web3"));
var import_cipher = require("./cipher");
var import_eth_sig_util = require("@metamask/eth-sig-util");
var import_constant = require("./constant");
var import_MindLake = require("../MindLake");
var _Web3Interact = class {
  constructor() {
    if (!window.ethereum) {
      throw new Error("Please install a wallet");
    }
    let currentProvider;
    if (window.ethereum.providers) {
      currentProvider = window.ethereum.providers.find((p) => p.isMetaMask);
    } else {
      currentProvider = window.ethereum;
    }
    if (!currentProvider.isMetaMask) {
      throw new Error("Only MetamMask wallet is supported currently. Please install or replace");
    }
    this.provider = currentProvider;
    this.web3 = new import_web3.default(currentProvider);
    this.contract = new this.web3.eth.Contract(
      // @ts-ignore
      import_abi.default,
      _Web3Interact.CONTRACT_ADDRESS
    );
    this._onListen();
  }
  _onListen() {
    this.provider.on("accountsChanged", this._onAccountsChanged.bind(this));
    this.provider.on("chainChanged", this._onChainChanged.bind(this));
    this.provider.on("disconnect", this._onDisconnect.bind(this));
  }
  /**
   * connected wallet account change event
   * @param accounts
   * @private
   */
  _onAccountsChanged(accounts) {
    console.log("Wallet address changed:", accounts && accounts[0]);
    localStorage.setItem(import_constant.WALLET_key, accounts && accounts[0]);
    this.account = accounts && accounts[0];
    this._walletChange();
  }
  /**
   * chain change event
   * @param chainId
   * @private
   */
  _onChainChanged(chainId) {
    console.log("Chain changed:  ", chainId, this.account);
  }
  _walletChange() {
    if (this.account) {
      this.mkCipherBuffer = void 0;
      this.mkBuffer = void 0;
      this.privateKeyCipherBuffer = void 0;
      this.publicKey = void 0;
    }
  }
  /**
   * wallet disconnect
   * @private
   */
  _onDisconnect() {
    console.log("Wallet disconnect: ");
  }
  /**
   * get walletAddress
   */
  async getWalletAccount() {
    if (!this.account || !import_MindLake.MindLake.isConnected) {
      const accounts = await this.provider.request({
        method: "eth_requestAccounts"
      });
      if (!accounts.length) {
        throw new Error("No accounts returned");
      }
      this.account = accounts[0];
    }
    return this.account;
  }
  async checkConnection() {
    const accounts = await this.provider.request({
      method: "eth_accounts"
    });
    if (accounts.length) {
      this.account = accounts[0];
      localStorage.setItem(import_constant.WALLET_key, accounts[0]);
    }
  }
  /**
   * wallet signature
   * @param signData
   */
  async personalSignature(signData) {
    const signature = await this.provider.request({
      method: "personal_sign",
      params: [import_web3.default.utils.fromUtf8(signData), this.account]
    });
    return signature;
  }
  /**
   * get wallet publicKey
   * @private
   */
  async _getEncryptionPublicKey() {
    if (this.provider) {
      if (this.publicKey) {
        return this.publicKey;
      }
      const keyB64 = await this.provider.request({
        method: "eth_getEncryptionPublicKey",
        params: [this.account]
      });
      this.publicKey = keyB64;
      return this.publicKey;
    }
  }
  /**
   * get mk
   */
  async getMekBytes() {
    await this._loadKeysCipherFromChain();
    if (!this.mkCipherBuffer) {
      await this._generateKeysCipherToChain();
    }
    if (!this.mkBuffer) {
      this.mkBuffer = await this._decryptMk(this.mkCipherBuffer);
    }
    return this.mkBuffer;
  }
  /**
   * get pk
   */
  async getPkPem() {
    const mk = await this.getMekBytes();
    const iv = this.privateKeyCipherBuffer.slice(0, 16);
    const cipher = this.privateKeyCipherBuffer.slice(16);
    const decrypt = import_cipher.CipherHelper.aesDecrypt(mk, iv, cipher);
    const { publicKeyPem, privateKeyPem } = import_cipher.CipherHelper.getPublicKeyPemFromPrivate(decrypt);
    return { privateKeyPem, publicKeyPem };
  }
  /**
   *load keys form chain
   */
  async _loadKeysCipherFromChain() {
    if (this.mkCipherBuffer && this.privateKeyCipherBuffer) {
      return;
    }
    const account = await this.getWalletAccount();
    const keys = await this.contract.methods.getKeys(account).call();
    if (keys && keys.MK && keys.SK) {
      this.mkCipherBuffer = Buffer.from(keys.MK.slice(2), "hex");
      this.privateKeyCipherBuffer = Buffer.from(keys.SK.slice(2), "hex");
    }
  }
  /**
   * generateKeys form local to chain
   * @private
   */
  async _generateKeysCipherToChain() {
    if (this.mkCipherBuffer && this.privateKeyCipherBuffer) {
      return;
    }
    const account = await this.getWalletAccount();
    const checkAccount = await this.web3.utils.toChecksumAddress(account);
    const mk = import_cipher.CipherHelper.generateMk();
    const mekBuffer = Buffer.from(mk, "hex");
    const keys = import_cipher.CipherHelper.createKeyPemString();
    const iv = import_cipher.CipherHelper.randomBytes();
    const privateKeyCipherBuffer = Buffer.concat([
      iv,
      import_cipher.CipherHelper.aesEncrypt(mekBuffer, iv, keys.privateKeyPem)
    ]);
    const mkCipherBuffer = await this._encryptMk(mk);
    if (!mkCipherBuffer) {
      throw new Error("mk encrypt error");
    }
    const txHash = await this.contract.methods.setKeys(mkCipherBuffer, privateKeyCipherBuffer).send({ from: checkAccount });
    if (txHash && txHash.blockHash) {
      this.mkCipherBuffer = mkCipherBuffer;
      this.privateKeyCipherBuffer = privateKeyCipherBuffer;
    }
  }
  /**
   * encrypt mk
   * @param mk
   * @private
   */
  async _encryptMk(mk) {
    const pubKey = await this._getEncryptionPublicKey();
    if (pubKey) {
      const enc = (0, import_eth_sig_util.encrypt)({
        publicKey: pubKey,
        data: Buffer.from(mk, "hex").toString("base64"),
        version: "x25519-xsalsa20-poly1305"
      });
      const buf = Buffer.concat([
        Buffer.from(enc.ephemPublicKey, "base64"),
        Buffer.from(enc.nonce, "base64"),
        Buffer.from(enc.ciphertext, "base64")
      ]);
      return buf;
    }
  }
  /**
   * decrypt mk
   * @param data
   * @private
   */
  async _decryptMk(data) {
    const structuredData = {
      version: "x25519-xsalsa20-poly1305",
      ephemPublicKey: data.slice(0, 32).toString("base64"),
      nonce: data.slice(32, 56).toString("base64"),
      ciphertext: data.slice(56).toString("base64")
    };
    const ct = `0x${Buffer.from(
      JSON.stringify(structuredData),
      "utf8"
    ).toString("hex")}`;
    const decrypt = await this.provider.request({
      method: "eth_decrypt",
      params: [ct, this.account]
    });
    return Buffer.from(decrypt, "base64");
  }
};
var Web3Interact = _Web3Interact;
/**
 * contract address
 */
Web3Interact.CONTRACT_ADDRESS = "0xF5932e67e84F08965DC6D62C2B67f47a6826E5a7";
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Web3Interact
});
